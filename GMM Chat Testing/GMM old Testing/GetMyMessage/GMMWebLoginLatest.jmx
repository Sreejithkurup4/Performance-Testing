<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="4.0" jmeter="4.0 r1823414">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Test Plan" enabled="true">
      <stringProp name="TestPlan.comments"></stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.tearDown_on_shutdown">true</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments"/>
      </elementProp>
      <stringProp name="TestPlan.user_define_classpath"></stringProp>
    </TestPlan>
    <hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <ConfigTestElement guiclass="HttpDefaultsGui" testclass="ConfigTestElement" testname="HTTP Request Defaults" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments"/>
          </elementProp>
          <stringProp name="HTTPSampler.domain">adarshtest1.getmymessage.co</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.concurrentPool">6</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </ConfigTestElement>
        <hashTree/>
        <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
          <collectionProp name="HeaderManager.headers">
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">Host</stringProp>
              <stringProp name="Header.value">adarshtest1.getmymessage.co</stringProp>
            </elementProp>
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">Origin</stringProp>
              <stringProp name="Header.value">https://adarshtest1.getmymessage.co</stringProp>
            </elementProp>
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">Content-Type</stringProp>
              <stringProp name="Header.value">application/x-www-form-urlencoded</stringProp>
            </elementProp>
          </collectionProp>
        </HeaderManager>
        <hashTree/>
        <CookieManager guiclass="CookiePanel" testclass="CookieManager" testname="HTTP Cookie Manager" enabled="true">
          <collectionProp name="CookieManager.cookies"/>
          <boolProp name="CookieManager.clearEachIteration">false</boolProp>
        </CookieManager>
        <hashTree/>
        <CacheManager guiclass="CacheManagerGui" testclass="CacheManager" testname="HTTP Cache Manager" enabled="true">
          <boolProp name="clearEachIteration">false</boolProp>
          <boolProp name="useExpires">true</boolProp>
        </CacheManager>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="WebLogin" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="mode" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">true</boolProp>
                <stringProp name="Argument.name">mode</stringProp>
                <stringProp name="Argument.value">web</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="password" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">true</boolProp>
                <stringProp name="Argument.name">password</stringProp>
                <stringProp name="Argument.value">abcd1234</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="username" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">true</boolProp>
                <stringProp name="Argument.name">username</stringProp>
                <stringProp name="Argument.value">rosepv123+1@gmail.com</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">index/login</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header manager" enabled="false">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="Accept" elementType="Header">
                <stringProp name="Header.name">Accept</stringProp>
                <stringProp name="Header.value">*/*</stringProp>
              </elementProp>
              <elementProp name="Origin" elementType="Header">
                <stringProp name="Header.name">Origin</stringProp>
                <stringProp name="Header.value">https://adarshtest1.getmymessage.co</stringProp>
              </elementProp>
              <elementProp name="X-Requested-With" elementType="Header">
                <stringProp name="Header.name">X-Requested-With</stringProp>
                <stringProp name="Header.value">XMLHttpRequest</stringProp>
              </elementProp>
              <elementProp name="Content-Type" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/x-www-form-urlencoded; charset=UTF-8</stringProp>
              </elementProp>
              <elementProp name="Referer" elementType="Header">
                <stringProp name="Header.name">Referer</stringProp>
                <stringProp name="Header.value">https://adarshtest1.getmymessage.co/index</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <ConstantTimer guiclass="ConstantTimerGui" testclass="ConstantTimer" testname="Constant Timer" enabled="false">
            <stringProp name="ConstantTimer.delay">0</stringProp>
          </ConstantTimer>
          <hashTree/>
        </hashTree>
        <JMeter.plugins.functional.samplers.websocket.WebSocketSampler guiclass="JMeter.plugins.functional.samplers.websocket.WebSocketSamplerGui" testclass="JMeter.plugins.functional.samplers.websocket.WebSocketSampler" testname="Joining" enabled="false">
          <stringProp name="serverAddress">adarshtest1.messageboxapp.com</stringProp>
          <stringProp name="serverPort">4910</stringProp>
          <stringProp name="implementation">RFC6455 (v13)</stringProp>
          <stringProp name="protocol">wss</stringProp>
          <stringProp name="contextPath">socket.io/</stringProp>
          <stringProp name="contentEncoding">UTF-8</stringProp>
          <stringProp name="requestPayload"></stringProp>
          <stringProp name="connectionTimeout">5000</stringProp>
          <stringProp name="responseTimeout">20000</stringProp>
          <boolProp name="ignoreSslErrors">false</boolProp>
          <boolProp name="streamingConnection">false</boolProp>
          <stringProp name="connectionId">${sid}</stringProp>
          <stringProp name="responsePattern"></stringProp>
          <stringProp name="closeConncectionPattern"></stringProp>
          <stringProp name="proxyAddress"></stringProp>
          <stringProp name="proxyPassword"></stringProp>
          <stringProp name="proxyPort"></stringProp>
          <stringProp name="proxyUsername"></stringProp>
          <stringProp name="messageBacklog">3</stringProp>
          <elementProp name="queryStringParameters" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="transport" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">polling</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">transport</stringProp>
              </elementProp>
              <elementProp name="t" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">1528987561812-3</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">t</stringProp>
              </elementProp>
              <elementProp name="sid" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${sid}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">sid</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
        </JMeter.plugins.functional.samplers.websocket.WebSocketSampler>
        <hashTree>
          <JSR223Listener guiclass="TestBeanGUI" testclass="JSR223Listener" testname="JSR223 Listener" enabled="true">
            <stringProp name="cacheKey">true</stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">
var ioOptions ={
	host:&quot;adarshtest1&quot;,
hostname:&quot;adarshtest1&quot;,
path:&quot;/socket.io&quot;,
port:&quot;4910&quot;,
query:{userid: &quot;704&quot;, email: &quot;rosepv123+1@gmail.com&quot;, namespace: &quot;gmm-adarshtest1&quot;},
reconnection limit:1000,
secure:false
}
portjs = &quot;https://adarshtest1.messageboxapp.com/socket.io/socket.io.js&quot;;
socket = io.connect(portjs, ioOptions);
//refreshOpenRequests();
socket.on(&apos;connect&apos;, function(message) {
    ////
    console.info(&quot;__connected__&quot;);
    swal({
        title: gmmValAlerts[&quot;GMM_VAL_NW_CONNECTED_MSG&quot;],
        text: &quot;&quot;,
        type:&quot;success&quot;,
        showConfirmButton: false,
        allowEscapeKey: false
    });
    setTimeout(function() {
        swal.close();
        if(localStorage.getItem(&apos;browserAlertStatus&apos;) != &apos;true&apos;){
            showBrowserAlerts();
        }
    }, 1000);

    function showBrowserAlerts(){
        if(!categories){
            setTimeout(function(){
                swal(gmmValAlerts[&apos;GMM_WARNING&apos;], &quot;There are no active Service Categories in your account. Please create at least one category in Settings to start creating requests.&quot;)
            }, 3000);
        }
        if(!isChrome){
            setTimeout(function(){
                swal(gmmValAlerts[&apos;GMM_WARNING&apos;], gmmValAlerts[&quot;GMM_GOOGLE_CHROME_WARNING&quot;]);
                localStorage.setItem(&apos;browserAlertStatus&apos;, &apos;true&apos;);
            }, 4000);
        }
        var screenWidth = screen.width;
        if(screenWidth&lt;=1440){
            setTimeout(function(){
                swal(gmmValAlerts[&apos;GMM_WARNING&apos;], gmmValAlerts[&quot;GMM_SMALL_SCREEN_WARNING&quot;]);
                localStorage.setItem(&apos;browserAlertStatus&apos;, &apos;true&apos;);
            }, 6000);
        }
    }

    $(&apos;#network-status&apos;).html(&apos;&lt;div class=&quot;label&quot;&gt;&apos;+gmmValAlerts[&apos;GMM_NW_STATUS_MSG&apos;]+&apos;&amp;nbsp;&amp;nbsp;&apos;+gmmValAlerts[&apos;GMM_VAL_NW_CONNECTED_MSG&apos;]+&apos;&lt;/div&gt;&apos;).fadeOut(&apos;slow&apos;).fadeIn(&apos;slow&apos;);
    $(&apos;.nano1&apos;).removeClass(&apos;ajax-loader-kingsadmin&apos;);
    $(&apos;#load_contacts&apos;).removeClass(&apos;ajax-loader-kingsadmin&apos;);

    try
    {
        //        refreshOpenRequests();
        refreshContacts(0);
        var openedWindow = JSON.parse(localStorage.getItem(&apos;openedMsg&apos;));
        $.each(openedWindow, function(index, obj) {

            var explode = obj.split(&quot;#&quot;);

            if (explode[0] == &quot;CUSTOMER&quot;)
            {
                if( (explode[1])*1 ) {
                    getOldChat(removeChr(index), 1, explode[1]);
                    //console.log(&quot;Appending opened reference to widget table row.&quot;);
                    addOpenedRefToOpenRow(removeChr(index), explode[1]);
                }else{
                    if(!$(index).is(&apos;:visible&apos;) &amp;&amp; ($(&apos;.initialRequestWindow&apos;).length == 0))
                        getOldChat(removeChr(index), 1, explode[1]);
                }
            }
            else
            {
                var newIndex = appendChr(parseInt(removeChr(index)) -1);

                var internalChatId = removeChr(index);




                var reqData = new Object();
                reqData.chatId = internalChatId;
                ajax_loader_disable();
                $.ajax({
                    type: &apos;POST&apos;,
                    dataType: &quot;json&quot;,
                    url: baseUrl + &quot;/home/getrequestdetailsbyinternalchatid&quot;,
                    data: reqData,
                    success: function(data) {
                        if(data[0]){
                            setTimeout(function(){
                                $(&quot;#serviceregisterUpdateCHT&quot;+data[0][&apos;SR_ChatId&apos;]+&quot; .chtwitbut&quot;).click();
                            }, 2000);
                        }
                    }
                });
            }

        });
        if(companySelectedPackageId == 1) {
            if($.isEmptyObject(openedWindow)) {
                if($(&apos;.customerChat&apos;).length == 0) {
                    send_internalV3();
                }
            } else if (typeof(openedWindow.no) != &quot;undefined&quot;) { // Login condition
                if($(&apos;.customerChat&apos;).length == 0) {
                    send_internalV3();
                }
            }
        }
        else {
            if($.isEmptyObject(openedWindow)) {
                if($(&apos;.initialRequestWindow&apos;).length == 0) {
                    send_internalV3();
                }
            } else if (typeof(openedWindow.no) != &quot;undefined&quot;) { // Login condition
                if($(&apos;.initialRequestWindow&apos;).length == 0) {
                    send_internalV3();
                }
            }
        }

    }
    catch (e) {
        //        console.log(e);
    }

});
socket.on(&apos;disconnect&apos;, function(err) {
    errorconnection();
    socket.io.reconnect();
});
socket.on(&apos;reconnect&apos;, function(message) {

});
socket.on(&apos;reconnecting&apos;, function(message) {

});
socket.on(&apos;connecting&apos;, function(message) {

    //$(&apos;#msg&apos;).html(&quot;&lt;p class=&apos;ui-state-error ui-corner-all socket-connecting&apos; &gt;Connecting...&lt;/p&gt;&quot;);
    // $(&apos;#msg&apos;).html(&quot;&lt;div class=&apos;label label-warning&apos; &gt;&quot;+gmmValAlerts[&apos;GMM_VAL_CONNECTING_MSG&apos;]+&quot;...&lt;/div&gt;&quot;).fadeOut(&apos;slow&apos;).fadeIn(&apos;slow&apos;);
    //$(&apos;#network-status&apos;).removeClass(&apos;btn-success&apos;);
    //$(&apos;#network-status&apos;).addClass(&apos;btn-warning&apos;);
    $(&apos;#network-status&apos;).html(gmmValAlerts[&apos;GMM_VAL_CONNECTING_MSG&apos;]+&apos;...&apos;);

});


// sample emit function
socket.emit(&apos;clientLoginInternal&apos;,
        {&quot;userid&quot;: userId,
            &quot;companyid&quot;: lCompanyId,
            &quot;username&quot;: userName,
            &quot;password&quot;: &quot;&quot;,
            &quot;usertype&quot;: userType,
            &quot;usergroupid&quot;: usergroupid, //TODO
            &quot;usergroup&quot;: userGroup,
            &quot;firstname&quot;: firstName,
            &quot;lastname&quot;: lastName,
            &quot;propertycode&quot;: &quot;&quot;,
            &quot;chatcategoryid&quot;: chatCategoryId,
            &quot;chatcategory&quot;: &apos;&apos;, //TODO
            &quot;uniqueid&quot;: uniqueId,
            &quot;targetuniqueid&quot;: &quot;&quot;}); </stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </JSR223Listener>
          <hashTree/>
        </hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler" enabled="false">
          <stringProp name="scriptLanguage">javascript</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">
  /**
   * send a message
   * @param {client} client connection
   * @param {done}   callback function(err) {}
   */
  sendMessage : function (client, done) {
   // logger.error(&apos;Not implement method sendMessage in generator&apos;);
    // Your logic
    client.emit(&quot;userToUser&quot;, { 
&quot;chatid&quot;:&quot;0070300704&quot;,
&quot;chatmediatype&quot;:&quot;Text&quot;,
&quot;chattype&quot;:&quot;USER&quot;,
&quot;message&quot;:&quot;hello&quot;,
&quot;messageid&quot;:&quot;19161201529482155386&quot;,
&quot;targetuserid&quot;:&quot;703&quot;,
&quot;usergroupid&quot;:&quot;3&quot;,
&quot;userid&quot;:&quot;704&quot;,
&quot;username&quot;:&quot;rosepv123+1@gmail.com&quot;
});
    //client.publish(&apos;/test&apos;, { hello: &apos;world&apos; });
    done();
  
};</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler" enabled="false">
          <stringProp name="scriptLanguage">javascript</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">!function(e){if(&quot;object&quot;==typeof exports&amp;&amp;&quot;undefined&quot;!=typeof module)module.exports=e();else if(&quot;function&quot;==typeof define&amp;&amp;define.amd)define([],e);else{var f;&quot;undefined&quot;!=typeof window?f=window:&quot;undefined&quot;!=typeof global?f=global:&quot;undefined&quot;!=typeof self&amp;&amp;(f=self),f.io=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==&quot;function&quot;&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);throw new Error(&quot;Cannot find module &apos;&quot;+o+&quot;&apos;&quot;)}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==&quot;function&quot;&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){

module.exports = _dereq_(&apos;./lib/&apos;);

},{&quot;./lib/&quot;:2}],2:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var url = _dereq_(&apos;./url&apos;);
var parser = _dereq_(&apos;socket.io-parser&apos;);
var Manager = _dereq_(&apos;./manager&apos;);
var debug = _dereq_(&apos;debug&apos;)(&apos;socket.io-client&apos;);

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io(&apos;http://localhost/a&apos;);`
 *   `io(&apos;http://localhost/b&apos;);`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup(uri, opts) {
  if (typeof uri == &apos;object&apos;) {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var io;

  if (opts.forceNew || opts[&apos;force new connection&apos;] || false === opts.multiplex) {
    debug(&apos;ignoring socket cache for %s&apos;, source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug(&apos;new io instance for %s&apos;, source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }

  return io.socket(parsed.path);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = _dereq_(&apos;./manager&apos;);
exports.Socket = _dereq_(&apos;./socket&apos;);

},{&quot;./manager&quot;:3,&quot;./socket&quot;:5,&quot;./url&quot;:6,&quot;debug&quot;:10,&quot;socket.io-parser&quot;:46}],3:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var url = _dereq_(&apos;./url&apos;);
var eio = _dereq_(&apos;engine.io-client&apos;);
var Socket = _dereq_(&apos;./socket&apos;);
var Emitter = _dereq_(&apos;component-emitter&apos;);
var parser = _dereq_(&apos;socket.io-parser&apos;);
var on = _dereq_(&apos;./on&apos;);
var bind = _dereq_(&apos;component-bind&apos;);
var object = _dereq_(&apos;object-component&apos;);
var debug = _dereq_(&apos;debug&apos;)(&apos;socket.io-client:manager&apos;);
var indexOf = _dereq_(&apos;indexof&apos;);
var Backoff = _dereq_(&apos;backo2&apos;);

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts){
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri &amp;&amp; (&apos;object&apos; == typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || &apos;/socket.io&apos;;
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = &apos;closed&apos;;
  this.uri = uri;
  this.connected = [];
  this.encoding = false;
  this.packetBuffer = [];
  this.encoder = new parser.Encoder();
  this.decoder = new parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function() {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function(){
  for (var nsp in this.nsps) {
    this.nsps[nsp].id = this.engine.id;
  }
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function(v){
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function(v){
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function(v){
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff &amp;&amp; this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function(v){
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff &amp;&amp; this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function(v){
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff &amp;&amp; this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function(v){
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function() {
  // Only try to reconnect if it&apos;s the first time we&apos;re connecting
  if (!this.reconnecting &amp;&amp; this._reconnection &amp;&amp; this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};


/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function(fn){
  debug(&apos;readyState %s&apos;, this.readyState);
  if (~this.readyState.indexOf(&apos;open&apos;)) return this;

  debug(&apos;opening %s&apos;, this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = &apos;opening&apos;;
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, &apos;open&apos;, function() {
    self.onopen();
    fn &amp;&amp; fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, &apos;error&apos;, function(data){
    debug(&apos;connect_error&apos;);
    self.cleanup();
    self.readyState = &apos;closed&apos;;
    self.emitAll(&apos;connect_error&apos;, data);
    if (fn) {
      var err = new Error(&apos;Connection error&apos;);
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug(&apos;connect attempt will timeout after %d&apos;, timeout);

    // set timer
    var timer = setTimeout(function(){
      debug(&apos;connect attempt timed out after %d&apos;, timeout);
      openSub.destroy();
      socket.close();
      socket.emit(&apos;error&apos;, &apos;timeout&apos;);
      self.emitAll(&apos;connect_timeout&apos;, timeout);
    }, timeout);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function(){
  debug(&apos;open&apos;);

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = &apos;open&apos;;
  this.emit(&apos;open&apos;);

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, &apos;data&apos;, bind(this, &apos;ondata&apos;)));
  this.subs.push(on(this.decoder, &apos;decoded&apos;, bind(this, &apos;ondecoded&apos;)));
  this.subs.push(on(socket, &apos;error&apos;, bind(this, &apos;onerror&apos;)));
  this.subs.push(on(socket, &apos;close&apos;, bind(this, &apos;onclose&apos;)));
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function(data){
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function(packet) {
  this.emit(&apos;packet&apos;, packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function(err){
  debug(&apos;error&apos;, err);
  this.emitAll(&apos;error&apos;, err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function(nsp){
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on(&apos;connect&apos;, function(){
      socket.id = self.engine.id;
      if (!~indexOf(self.connected, socket)) {
        self.connected.push(socket);
      }
    });
  }
  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function(socket){
  var index = indexOf(this.connected, socket);
  if (~index) this.connected.splice(index, 1);
  if (this.connected.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function(packet){
  debug(&apos;writing packet %j&apos;, packet);
  var self = this;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function(encodedPackets) {
      for (var i = 0; i &lt; encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i]);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function() {
  if (this.packetBuffer.length &gt; 0 &amp;&amp; !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function(){
  var sub;
  while (sub = this.subs.shift()) sub.destroy();

  this.packetBuffer = [];
  this.encoding = false;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function(){
  this.skipReconnect = true;
  this.backoff.reset();
  this.readyState = &apos;closed&apos;;
  this.engine &amp;&amp; this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function(reason){
  debug(&apos;close&apos;);
  this.cleanup();
  this.backoff.reset();
  this.readyState = &apos;closed&apos;;
  this.emit(&apos;close&apos;, reason);
  if (this._reconnection &amp;&amp; !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function(){
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts &gt;= this._reconnectionAttempts) {
    debug(&apos;reconnect failed&apos;);
    this.backoff.reset();
    this.emitAll(&apos;reconnect_failed&apos;);
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug(&apos;will wait %dms before reconnect attempt&apos;, delay);

    this.reconnecting = true;
    var timer = setTimeout(function(){
      if (self.skipReconnect) return;

      debug(&apos;attempting reconnect&apos;);
      self.emitAll(&apos;reconnect_attempt&apos;, self.backoff.attempts);
      self.emitAll(&apos;reconnecting&apos;, self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function(err){
        if (err) {
          debug(&apos;reconnect attempt error&apos;);
          self.reconnecting = false;
          self.reconnect();
          self.emitAll(&apos;reconnect_error&apos;, err.data);
        } else {
          debug(&apos;reconnect success&apos;);
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function(){
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll(&apos;reconnect&apos;, attempt);
};

},{&quot;./on&quot;:4,&quot;./socket&quot;:5,&quot;./url&quot;:6,&quot;backo2&quot;:7,&quot;component-bind&quot;:8,&quot;component-emitter&quot;:9,&quot;debug&quot;:10,&quot;engine.io-client&quot;:11,&quot;indexof&quot;:42,&quot;object-component&quot;:43,&quot;socket.io-parser&quot;:46}],4:[function(_dereq_,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function(){
      obj.removeListener(ev, fn);
    }
  };
}

},{}],5:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var parser = _dereq_(&apos;socket.io-parser&apos;);
var Emitter = _dereq_(&apos;component-emitter&apos;);
var toArray = _dereq_(&apos;to-array&apos;);
var on = _dereq_(&apos;./on&apos;);
var bind = _dereq_(&apos;component-bind&apos;);
var debug = _dereq_(&apos;debug&apos;)(&apos;socket.io-client:socket&apos;);
var hasBin = _dereq_(&apos;has-binary&apos;);

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can&apos;t be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket(io, nsp){
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  if (this.io.autoConnect) this.open();
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function() {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, &apos;open&apos;, bind(this, &apos;onopen&apos;)),
    on(io, &apos;packet&apos;, bind(this, &apos;onpacket&apos;)),
    on(io, &apos;close&apos;, bind(this, &apos;onclose&apos;))
  ];
};

/**
 * &quot;Opens&quot; the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function(){
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if (&apos;open&apos; == this.io.readyState) this.onopen();
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function(){
  var args = toArray(arguments);
  args.unshift(&apos;message&apos;);
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it&apos;s emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function(ev){
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var parserType = parser.EVENT; // default
  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
  var packet = { type: parserType, data: args };

  // event ack callback
  if (&apos;function&apos; == typeof args[args.length - 1]) {
    debug(&apos;emitting packet with ack id %d&apos;, this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function(packet){
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function(){
  debug(&apos;transport is open - connecting&apos;);

  // write connect packet if necessary
  if (&apos;/&apos; != this.nsp) {
    this.packet({ type: parser.CONNECT });
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function(reason){
  debug(&apos;close (%s)&apos;, reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit(&apos;disconnect&apos;, reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function(packet){
  if (packet.nsp != this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit(&apos;error&apos;, packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function(packet){
  var args = packet.data || [];
  debug(&apos;emitting event %j&apos;, args);

  if (null != packet.id) {
    debug(&apos;attaching ack callback to event&apos;);
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function(id){
  var self = this;
  var sent = false;
  return function(){
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug(&apos;sending ack %j&apos;, args);

    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
    self.packet({
      type: type,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function(packet){
  debug(&apos;calling ack %s with %j&apos;, packet.id, packet.data);
  var fn = this.acks[packet.id];
  fn.apply(this, packet.data);
  delete this.acks[packet.id];
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function(){
  this.connected = true;
  this.disconnected = false;
  this.emit(&apos;connect&apos;);
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function(){
  var i;
  for (i = 0; i &lt; this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i &lt; this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function(){
  debug(&apos;server disconnect (%s)&apos;, this.nsp);
  this.destroy();
  this.onclose(&apos;io server disconnect&apos;);
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don&apos;t get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function(){
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i &lt; this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function(){
  if (this.connected) {
    debug(&apos;performing disconnect (%s)&apos;, this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose(&apos;io client disconnect&apos;);
  }
  return this;
};

},{&quot;./on&quot;:4,&quot;component-bind&quot;:8,&quot;component-emitter&quot;:9,&quot;debug&quot;:10,&quot;has-binary&quot;:38,&quot;socket.io-parser&quot;:46,&quot;to-array&quot;:50}],6:[function(_dereq_,module,exports){
(function (global){

/**
 * Module dependencies.
 */

var parseuri = _dereq_(&apos;parseuri&apos;);
var debug = _dereq_(&apos;debug&apos;)(&apos;socket.io-client:url&apos;);

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc){
  var obj = uri;

  // default to window.location
  var loc = loc || global.location;
  if (null == uri) uri = loc.protocol + &apos;//&apos; + loc.host;

  // relative path support
  if (&apos;string&apos; == typeof uri) {
    if (&apos;/&apos; == uri.charAt(0)) {
      if (&apos;/&apos; == uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.hostname + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug(&apos;protocol-less url %s&apos;, uri);
      if (&apos;undefined&apos; != typeof loc) {
        uri = loc.protocol + &apos;//&apos; + uri;
      } else {
        uri = &apos;https://&apos; + uri;
      }
    }

    // parse
    debug(&apos;parse %s&apos;, uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = &apos;80&apos;;
    }
    else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = &apos;443&apos;;
    }
  }

  obj.path = obj.path || &apos;/&apos;;

  // define unique id
  obj.id = obj.protocol + &apos;://&apos; + obj.host + &apos;:&apos; + obj.port;
  // define href
  obj.href = obj.protocol + &apos;://&apos; + obj.host + (loc &amp;&amp; loc.port == obj.port ? &apos;&apos; : (&apos;:&apos; + obj.port));

  return obj;
}

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;debug&quot;:10,&quot;parseuri&quot;:44}],7:[function(_dereq_,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter &gt; 0 &amp;&amp; opts.jitter &lt;= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) &amp; 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],8:[function(_dereq_,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if (&apos;string&apos; == typeof fn) fn = obj[fn];
  if (&apos;function&apos; != typeof fn) throw new Error(&apos;bind() requires a function&apos;);
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],9:[function(_dereq_,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i &lt; callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i &lt; len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],10:[function(_dereq_,module,exports){

/**
 * Expose `debug()` as the module.
 */

module.exports = debug;

/**
 * Create a debugger with the given `name`.
 *
 * @param {String} name
 * @return {Type}
 * @api public
 */

function debug(name) {
  if (!debug.enabled(name)) return function(){};

  return function(fmt){
    fmt = coerce(fmt);

    var curr = new Date;
    var ms = curr - (debug[name] || curr);
    debug[name] = curr;

    fmt = name
      + &apos; &apos;
      + fmt
      + &apos; +&apos; + debug.humanize(ms);

    // This hackery is required for IE8
    // where `console.log` doesn&apos;t have &apos;apply&apos;
    window.console
      &amp;&amp; console.log
      &amp;&amp; Function.prototype.apply.call(console.log, console, arguments);
  }
}

/**
 * The currently active debug mode names.
 */

debug.names = [];
debug.skips = [];

/**
 * Enables a debug mode by name. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} name
 * @api public
 */

debug.enable = function(name) {
  try {
    localStorage.debug = name;
  } catch(e){}

  var split = (name || &apos;&apos;).split(/[\s,]+/)
    , len = split.length;

  for (var i = 0; i &lt; len; i++) {
    name = split[i].replace(&apos;*&apos;, &apos;.*?&apos;);
    if (name[0] === &apos;-&apos;) {
      debug.skips.push(new RegExp(&apos;^&apos; + name.substr(1) + &apos;$&apos;));
    }
    else {
      debug.names.push(new RegExp(&apos;^&apos; + name + &apos;$&apos;));
    }
  }
};

/**
 * Disable debug output.
 *
 * @api public
 */

debug.disable = function(){
  debug.enable(&apos;&apos;);
};

/**
 * Humanize the given `ms`.
 *
 * @param {Number} m
 * @return {String}
 * @api private
 */

debug.humanize = function(ms) {
  var sec = 1000
    , min = 60 * 1000
    , hour = 60 * min;

  if (ms &gt;= hour) return (ms / hour).toFixed(1) + &apos;h&apos;;
  if (ms &gt;= min) return (ms / min).toFixed(1) + &apos;m&apos;;
  if (ms &gt;= sec) return (ms / sec | 0) + &apos;s&apos;;
  return ms + &apos;ms&apos;;
};

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

debug.enabled = function(name) {
  for (var i = 0, len = debug.skips.length; i &lt; len; i++) {
    if (debug.skips[i].test(name)) {
      return false;
    }
  }
  for (var i = 0, len = debug.names.length; i &lt; len; i++) {
    if (debug.names[i].test(name)) {
      return true;
    }
  }
  return false;
};

/**
 * Coerce `val`.
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

// persist

try {
  if (window.localStorage) debug.enable(localStorage.debug);
} catch(e){}

},{}],11:[function(_dereq_,module,exports){

module.exports =  _dereq_(&apos;./lib/&apos;);

},{&quot;./lib/&quot;:12}],12:[function(_dereq_,module,exports){

module.exports = _dereq_(&apos;./socket&apos;);

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = _dereq_(&apos;engine.io-parser&apos;);

},{&quot;./socket&quot;:13,&quot;engine.io-parser&quot;:25}],13:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var transports = _dereq_(&apos;./transports&apos;);
var Emitter = _dereq_(&apos;component-emitter&apos;);
var debug = _dereq_(&apos;debug&apos;)(&apos;engine.io-client:socket&apos;);
var index = _dereq_(&apos;indexof&apos;);
var parser = _dereq_(&apos;engine.io-parser&apos;);
var parseuri = _dereq_(&apos;parseuri&apos;);
var parsejson = _dereq_(&apos;parsejson&apos;);
var parseqs = _dereq_(&apos;parseqs&apos;);

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Noop function.
 *
 * @api private
 */

function noop(){}

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts){
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri &amp;&amp; &apos;object&apos; == typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.host = uri.host;
    opts.secure = uri.protocol == &apos;https&apos; || uri.protocol == &apos;wss&apos;;
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  }

  this.secure = null != opts.secure ? opts.secure :
    (global.location &amp;&amp; &apos;https:&apos; == location.protocol);

  if (opts.host) {
    var pieces = opts.host.split(&apos;:&apos;);
    opts.hostname = pieces.shift();
    if (pieces.length) {
      opts.port = pieces.pop();
    } else if (!opts.port) {
      // if no port is specified manually, use the protocol default
      opts.port = this.secure ? &apos;443&apos; : &apos;80&apos;;
    }
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : &apos;localhost&apos;);
  this.port = opts.port || (global.location &amp;&amp; location.port ?
       location.port :
       (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if (&apos;string&apos; == typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || &apos;/engine.io&apos;).replace(/\/$/, &apos;&apos;) + &apos;/&apos;;
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || &apos;t&apos;;
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || [&apos;polling&apos;, &apos;websocket&apos;];
  this.readyState = &apos;&apos;;
  this.writeBuffer = [];
  this.callbackBuffer = [];
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized || null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = _dereq_(&apos;./transport&apos;);
Socket.transports = _dereq_(&apos;./transports&apos;);
Socket.parser = _dereq_(&apos;engine.io-parser&apos;);

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug(&apos;creating transport &quot;%s&quot;&apos;, name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    agent: this.agent,
    hostname: this.hostname,
    port: this.port,
    secure: this.secure,
    path: this.path,
    query: query,
    forceJSONP: this.forceJSONP,
    jsonp: this.jsonp,
    forceBase64: this.forceBase64,
    enablesXDR: this.enablesXDR,
    timestampRequests: this.timestampRequests,
    timestampParam: this.timestampParam,
    policyPort: this.policyPort,
    socket: this,
    pfx: this.pfx,
    key: this.key,
    passphrase: this.passphrase,
    cert: this.cert,
    ca: this.ca,
    ciphers: this.ciphers,
    rejectUnauthorized: this.rejectUnauthorized
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade &amp;&amp; Socket.priorWebsocketSuccess &amp;&amp; this.transports.indexOf(&apos;websocket&apos;) != -1) {
    transport = &apos;websocket&apos;;
  } else if (0 == this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function() {
      self.emit(&apos;error&apos;, &apos;No transports available&apos;);
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = &apos;opening&apos;;

  // Retry with the next transport if the transport is disabled (jsonp: false)
  var transport;
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function(transport){
  debug(&apos;setting transport %s&apos;, transport.name);
  var self = this;

  if (this.transport) {
    debug(&apos;clearing existing transport %s&apos;, this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on(&apos;drain&apos;, function(){
    self.onDrain();
  })
  .on(&apos;packet&apos;, function(packet){
    self.onPacket(packet);
  })
  .on(&apos;error&apos;, function(e){
    self.onError(e);
  })
  .on(&apos;close&apos;, function(){
    self.onClose(&apos;transport close&apos;);
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug(&apos;probing transport &quot;%s&quot;&apos;, name);
  var transport = this.createTransport(name, { probe: 1 })
    , failed = false
    , self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen(){
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary &amp;&amp; self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug(&apos;probe transport &quot;%s&quot; opened&apos;, name);
    transport.send([{ type: &apos;ping&apos;, data: &apos;probe&apos; }]);
    transport.once(&apos;packet&apos;, function (msg) {
      if (failed) return;
      if (&apos;pong&apos; == msg.type &amp;&amp; &apos;probe&apos; == msg.data) {
        debug(&apos;probe transport &quot;%s&quot; pong&apos;, name);
        self.upgrading = true;
        self.emit(&apos;upgrading&apos;, transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = &apos;websocket&apos; == transport.name;

        debug(&apos;pausing current transport &quot;%s&quot;&apos;, self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if (&apos;closed&apos; == self.readyState) return;
          debug(&apos;changing transport and sending upgrade packet&apos;);

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: &apos;upgrade&apos; }]);
          self.emit(&apos;upgrade&apos;, transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug(&apos;probe transport &quot;%s&quot; failed&apos;, name);
        var err = new Error(&apos;probe error&apos;);
        err.transport = transport.name;
        self.emit(&apos;upgradeError&apos;, err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  //Handle any error that happens while probing
  function onerror(err) {
    var error = new Error(&apos;probe error: &apos; + err);
    error.transport = transport.name;

    freezeTransport();

    debug(&apos;probe transport &quot;%s&quot; failed because of error: %s&apos;, name, err);

    self.emit(&apos;upgradeError&apos;, error);
  }

  function onTransportClose(){
    onerror(&quot;transport closed&quot;);
  }

  //When the socket is closed while we&apos;re probing
  function onclose(){
    onerror(&quot;socket closed&quot;);
  }

  //When the socket is upgraded while we&apos;re probing
  function onupgrade(to){
    if (transport &amp;&amp; to.name != transport.name) {
      debug(&apos;&quot;%s&quot; works - aborting &quot;%s&quot;&apos;, to.name, transport.name);
      freezeTransport();
    }
  }

  //Remove all listeners on the transport and on self
  function cleanup(){
    transport.removeListener(&apos;open&apos;, onTransportOpen);
    transport.removeListener(&apos;error&apos;, onerror);
    transport.removeListener(&apos;close&apos;, onTransportClose);
    self.removeListener(&apos;close&apos;, onclose);
    self.removeListener(&apos;upgrading&apos;, onupgrade);
  }

  transport.once(&apos;open&apos;, onTransportOpen);
  transport.once(&apos;error&apos;, onerror);
  transport.once(&apos;close&apos;, onTransportClose);

  this.once(&apos;close&apos;, onclose);
  this.once(&apos;upgrading&apos;, onupgrade);

  transport.open();

};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug(&apos;socket open&apos;);
  this.readyState = &apos;open&apos;;
  Socket.priorWebsocketSuccess = &apos;websocket&apos; == this.transport.name;
  this.emit(&apos;open&apos;);
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if (&apos;open&apos; == this.readyState &amp;&amp; this.upgrade &amp;&amp; this.transport.pause) {
    debug(&apos;starting upgrade probes&apos;);
    for (var i = 0, l = this.upgrades.length; i &lt; l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if (&apos;opening&apos; == this.readyState || &apos;open&apos; == this.readyState) {
    debug(&apos;socket receive: type &quot;%s&quot;, data &quot;%s&quot;&apos;, packet.type, packet.data);

    this.emit(&apos;packet&apos;, packet);

    // Socket is live - any packet counts
    this.emit(&apos;heartbeat&apos;);

    switch (packet.type) {
      case &apos;open&apos;:
        this.onHandshake(parsejson(packet.data));
        break;

      case &apos;pong&apos;:
        this.setPing();
        break;

      case &apos;error&apos;:
        var err = new Error(&apos;server error&apos;);
        err.code = packet.data;
        this.emit(&apos;error&apos;, err);
        break;

      case &apos;message&apos;:
        this.emit(&apos;data&apos;, packet.data);
        this.emit(&apos;message&apos;, packet.data);
        break;
    }
  } else {
    debug(&apos;packet received with socket readyState &quot;%s&quot;&apos;, this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit(&apos;handshake&apos;, data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if  (&apos;closed&apos; == this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener(&apos;heartbeat&apos;, this.onHeartbeat);
  this.on(&apos;heartbeat&apos;, this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if (&apos;closed&apos; == self.readyState) return;
    self.onClose(&apos;ping timeout&apos;);
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug(&apos;writing ping packet - expecting pong within %sms&apos;, self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api public
*/

Socket.prototype.ping = function () {
  this.sendPacket(&apos;ping&apos;);
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function() {
  for (var i = 0; i &lt; this.prevBufferLen; i++) {
    if (this.callbackBuffer[i]) {
      this.callbackBuffer[i]();
    }
  }

  this.writeBuffer.splice(0, this.prevBufferLen);
  this.callbackBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (this.writeBuffer.length == 0) {
    this.emit(&apos;drain&apos;);
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if (&apos;closed&apos; != this.readyState &amp;&amp; this.transport.writable &amp;&amp;
    !this.upgrading &amp;&amp; this.writeBuffer.length) {
    debug(&apos;flushing %d packets in socket&apos;, this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit(&apos;flush&apos;);
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, fn) {
  this.sendPacket(&apos;message&apos;, msg, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, fn) {
  if (&apos;closing&apos; == this.readyState || &apos;closed&apos; == this.readyState) {
    return;
  }

  var packet = { type: type, data: data };
  this.emit(&apos;packetCreate&apos;, packet);
  this.writeBuffer.push(packet);
  this.callbackBuffer.push(fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if (&apos;opening&apos; == this.readyState || &apos;open&apos; == this.readyState) {
    this.readyState = &apos;closing&apos;;

    var self = this;

    function close() {
      self.onClose(&apos;forced close&apos;);
      debug(&apos;socket closing - telling transport to close&apos;);
      self.transport.close();
    }

    function cleanupAndClose() {
      self.removeListener(&apos;upgrade&apos;, cleanupAndClose);
      self.removeListener(&apos;upgradeError&apos;, cleanupAndClose);
      close();
    }

    function waitForUpgrade() {
      // wait for upgrade to finish since we can&apos;t send packets while pausing a transport
      self.once(&apos;upgrade&apos;, cleanupAndClose);
      self.once(&apos;upgradeError&apos;, cleanupAndClose);
    }

    if (this.writeBuffer.length) {
      this.once(&apos;drain&apos;, function() {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug(&apos;socket error %j&apos;, err);
  Socket.priorWebsocketSuccess = false;
  this.emit(&apos;error&apos;, err);
  this.onClose(&apos;transport error&apos;, err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if (&apos;opening&apos; == this.readyState || &apos;open&apos; == this.readyState || &apos;closing&apos; == this.readyState) {
    debug(&apos;socket close with reason: &quot;%s&quot;&apos;, reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // clean buffers in next tick, so developers can still
    // grab the buffers on `close` event
    setTimeout(function() {
      self.writeBuffer = [];
      self.callbackBuffer = [];
      self.prevBufferLen = 0;
    }, 0);

    // stop event from firing again for transport
    this.transport.removeAllListeners(&apos;close&apos;);

    // ensure transport won&apos;t stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = &apos;closed&apos;;

    // clear session id
    this.id = null;

    // emit close event
    this.emit(&apos;close&apos;, reason, desc);
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i&lt;j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;./transport&quot;:14,&quot;./transports&quot;:15,&quot;component-emitter&quot;:9,&quot;debug&quot;:22,&quot;engine.io-parser&quot;:25,&quot;indexof&quot;:42,&quot;parsejson&quot;:34,&quot;parseqs&quot;:35,&quot;parseuri&quot;:36}],14:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var parser = _dereq_(&apos;engine.io-parser&apos;);
var Emitter = _dereq_(&apos;component-emitter&apos;);

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = &apos;&apos;;
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * A counter used to prevent collisions in the timestamps used
 * for cache busting.
 */

Transport.timestamps = 0;

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = &apos;TransportError&apos;;
  err.description = desc;
  this.emit(&apos;error&apos;, err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if (&apos;closed&apos; == this.readyState || &apos;&apos; == this.readyState) {
    this.readyState = &apos;opening&apos;;
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if (&apos;opening&apos; == this.readyState || &apos;open&apos; == this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function(packets){
  if (&apos;open&apos; == this.readyState) {
    this.write(packets);
  } else {
    throw new Error(&apos;Transport not open&apos;);
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = &apos;open&apos;;
  this.writable = true;
  this.emit(&apos;open&apos;);
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function(data){
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit(&apos;packet&apos;, packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = &apos;closed&apos;;
  this.emit(&apos;close&apos;);
};

},{&quot;component-emitter&quot;:9,&quot;engine.io-parser&quot;:25}],15:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies
 */

var XMLHttpRequest = _dereq_(&apos;xmlhttprequest&apos;);
var XHR = _dereq_(&apos;./polling-xhr&apos;);
var JSONP = _dereq_(&apos;./polling-jsonp&apos;);
var websocket = _dereq_(&apos;./websocket&apos;);

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts){
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = &apos;https:&apos; == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname != location.hostname || port != opts.port;
    xs = opts.secure != isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if (&apos;open&apos; in xhr &amp;&amp; !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error(&apos;JSONP disabled&apos;);
    return new JSONP(opts);
  }
}

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;./polling-jsonp&quot;:16,&quot;./polling-xhr&quot;:17,&quot;./websocket&quot;:19,&quot;xmlhttprequest&quot;:20}],16:[function(_dereq_,module,exports){
(function (global){

/**
 * Module requirements.
 */

var Polling = _dereq_(&apos;./polling&apos;);
var inherit = _dereq_(&apos;component-inherit&apos;);

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Callbacks count.
 */

var index = 0;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document &amp;&amp; global.addEventListener) {
    global.addEventListener(&apos;beforeunload&apos;, function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement(&apos;script&apos;);

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function(e){
    self.onError(&apos;jsonp poll error&apos;,e);
  };

  var insertAt = document.getElementsByTagName(&apos;script&apos;)[0];
  insertAt.parentNode.insertBefore(script, insertAt);
  this.script = script;

  var isUAgecko = &apos;undefined&apos; != typeof navigator &amp;&amp; /gecko/i.test(navigator.userAgent);
  
  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement(&apos;iframe&apos;);
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement(&apos;form&apos;);
    var area = document.createElement(&apos;textarea&apos;);
    var id = this.iframeId = &apos;eio_iframe_&apos; + this.index;
    var iframe;

    form.className = &apos;socketio&apos;;
    form.style.position = &apos;absolute&apos;;
    form.style.top = &apos;-1000px&apos;;
    form.style.left = &apos;-1000px&apos;;
    form.target = id;
    form.method = &apos;POST&apos;;
    form.setAttribute(&apos;accept-charset&apos;, &apos;utf-8&apos;);
    area.name = &apos;d&apos;;
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError(&apos;jsonp polling iframe removal error&apos;, e);
      }
    }

    try {
      // ie6 dynamic iframes with target=&quot;&quot; support (thanks Chris Lambacher)
      var html = &apos;&lt;iframe src=&quot;javascript:0&quot; name=&quot;&apos;+ self.iframeId +&apos;&quot;&gt;&apos;;
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement(&apos;iframe&apos;);
      iframe.name = self.iframeId;
      iframe.src = &apos;javascript:0&apos;;
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, &apos;\\\n&apos;);
  this.area.value = data.replace(rNewline, &apos;\\n&apos;);

  try {
    this.form.submit();
  } catch(e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function(){
      if (self.iframe.readyState == &apos;complete&apos;) {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;./polling&quot;:18,&quot;component-inherit&quot;:21}],17:[function(_dereq_,module,exports){
(function (global){
/**
 * Module requirements.
 */

var XMLHttpRequest = _dereq_(&apos;xmlhttprequest&apos;);
var Polling = _dereq_(&apos;./polling&apos;);
var Emitter = _dereq_(&apos;component-emitter&apos;);
var inherit = _dereq_(&apos;component-inherit&apos;);
var debug = _dereq_(&apos;debug&apos;)(&apos;engine.io-client:polling-xhr&apos;);

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty(){}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR(opts){
  Polling.call(this, opts);

  if (global.location) {
    var isSSL = &apos;https:&apos; == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname != global.location.hostname ||
      port != opts.port;
    this.xs = opts.secure != isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function(opts){
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function(data, fn){
  var isBinary = typeof data !== &apos;string&apos; &amp;&amp; data !== undefined;
  var req = this.request({ method: &apos;POST&apos;, data: data, isBinary: isBinary });
  var self = this;
  req.on(&apos;success&apos;, fn);
  req.on(&apos;error&apos;, function(err){
    self.onError(&apos;xhr post error&apos;, err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function(){
  debug(&apos;xhr poll&apos;);
  var req = this.request();
  var self = this;
  req.on(&apos;data&apos;, function(data){
    self.onData(data);
  });
  req.on(&apos;error&apos;, function(err){
    self.onError(&apos;xhr poll error&apos;, err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request(opts){
  this.method = opts.method || &apos;GET&apos;;
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined != opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function(){
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug(&apos;xhr open %s: %s&apos;, this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    if (this.supportsBinary) {
      // This has to be done after open because Firefox is stupid
      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
      xhr.responseType = &apos;arraybuffer&apos;;
    }

    if (&apos;POST&apos; == this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader(&apos;Content-type&apos;, &apos;application/octet-stream&apos;);
        } else {
          xhr.setRequestHeader(&apos;Content-type&apos;, &apos;text/plain;charset=UTF-8&apos;);
        }
      } catch (e) {}
    }

    // ie6 check
    if (&apos;withCredentials&apos; in xhr) {
      xhr.withCredentials = true;
    }

    if (this.hasXDR()) {
      xhr.onload = function(){
        self.onLoad();
      };
      xhr.onerror = function(){
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function(){
        if (4 != xhr.readyState) return;
        if (200 == xhr.status || 1223 == xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that&apos;s user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function(){
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug(&apos;xhr data %s&apos;, this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the &apos;error&apos; event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function() {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function(){
  this.emit(&apos;success&apos;);
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function(data){
  this.emit(&apos;data&apos;, data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function(err){
  this.emit(&apos;error&apos;, err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function(fromError){
  if (&apos;undefined&apos; == typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch(e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function(){
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader(&apos;Content-Type&apos;).split(&apos;;&apos;)[0];
    } catch (e) {}
    if (contentType === &apos;application/octet-stream&apos;) {
      data = this.xhr.response;
    } else {
      if (!this.supportsBinary) {
        data = this.xhr.responseText;
      } else {
        data = &apos;ok&apos;;
      }
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function(){
  return &apos;undefined&apos; !== typeof global.XDomainRequest &amp;&amp; !this.xs &amp;&amp; this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function(){
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

if (global.document) {
  Request.requestsCount = 0;
  Request.requests = {};
  if (global.attachEvent) {
    global.attachEvent(&apos;onunload&apos;, unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener(&apos;beforeunload&apos;, unloadHandler, false);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;./polling&quot;:18,&quot;component-emitter&quot;:9,&quot;component-inherit&quot;:21,&quot;debug&quot;:22,&quot;xmlhttprequest&quot;:20}],18:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var Transport = _dereq_(&apos;../transport&apos;);
var parseqs = _dereq_(&apos;parseqs&apos;);
var parser = _dereq_(&apos;engine.io-parser&apos;);
var inherit = _dereq_(&apos;component-inherit&apos;);
var debug = _dereq_(&apos;debug&apos;)(&apos;engine.io-client:polling&apos;);

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function() {
  var XMLHttpRequest = _dereq_(&apos;xmlhttprequest&apos;);
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling(opts){
  var forceBase64 = (opts &amp;&amp; opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = &apos;polling&apos;;

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function(){
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function(onPause){
  var pending = 0;
  var self = this;

  this.readyState = &apos;pausing&apos;;

  function pause(){
    debug(&apos;paused&apos;);
    self.readyState = &apos;paused&apos;;
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug(&apos;we are currently polling - waiting to pause&apos;);
      total++;
      this.once(&apos;pollComplete&apos;, function(){
        debug(&apos;pre-pause polling complete&apos;);
        --total || pause();
      });
    }

    if (!this.writable) {
      debug(&apos;we are currently writing - waiting to pause&apos;);
      total++;
      this.once(&apos;drain&apos;, function(){
        debug(&apos;pre-pause writing complete&apos;);
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function(){
  debug(&apos;polling&apos;);
  this.polling = true;
  this.doPoll();
  this.emit(&apos;poll&apos;);
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function(data){
  var self = this;
  debug(&apos;polling got data %s&apos;, data);
  var callback = function(packet, index, total) {
    // if its the first message we consider the transport open
    if (&apos;opening&apos; == self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if (&apos;close&apos; == packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if (&apos;closed&apos; != this.readyState) {
    // if we got data we&apos;re not polling
    this.polling = false;
    this.emit(&apos;pollComplete&apos;);

    if (&apos;open&apos; == this.readyState) {
      this.poll();
    } else {
      debug(&apos;ignoring poll - transport state &quot;%s&quot;&apos;, this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function(){
  var self = this;

  function close(){
    debug(&apos;writing close packet&apos;);
    self.write([{ type: &apos;close&apos; }]);
  }

  if (&apos;open&apos; == this.readyState) {
    debug(&apos;transport open - closing&apos;);
    close();
  } else {
    // in case we&apos;re trying to close while
    // handshaking is in progress (GH-164)
    debug(&apos;transport not open - deferring close&apos;);
    this.once(&apos;open&apos;, close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  var callbackfn = function() {
    self.writable = true;
    self.emit(&apos;drain&apos;);
  };

  var self = this;
  parser.encodePayload(packets, this.supportsBinary, function(data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? &apos;https&apos; : &apos;http&apos;;
  var port = &apos;&apos;;

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = +new Date + &apos;-&apos; + Transport.timestamps++;
  }

  if (!this.supportsBinary &amp;&amp; !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port &amp;&amp; ((&apos;https&apos; == schema &amp;&amp; this.port != 443) ||
     (&apos;http&apos; == schema &amp;&amp; this.port != 80))) {
    port = &apos;:&apos; + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = &apos;?&apos; + query;
  }

  return schema + &apos;://&apos; + this.hostname + port + this.path + query;
};

},{&quot;../transport&quot;:14,&quot;component-inherit&quot;:21,&quot;debug&quot;:22,&quot;engine.io-parser&quot;:25,&quot;parseqs&quot;:35,&quot;xmlhttprequest&quot;:20}],19:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var Transport = _dereq_(&apos;../transport&apos;);
var parser = _dereq_(&apos;engine.io-parser&apos;);
var parseqs = _dereq_(&apos;parseqs&apos;);
var inherit = _dereq_(&apos;component-inherit&apos;);
var debug = _dereq_(&apos;debug&apos;)(&apos;engine.io-client:websocket&apos;);

/**
 * `ws` exposes a WebSocket-compatible interface in
 * Node, or the `WebSocket` or `MozWebSocket` globals
 * in the browser.
 */

var WebSocket = _dereq_(&apos;ws&apos;);

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts){
  var forceBase64 = (opts &amp;&amp; opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = &apos;websocket&apos;;

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function(){
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var self = this;
  var uri = this.uri();
  var protocols = void(0);
  var opts = { agent: this.agent };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  this.ws = new WebSocket(uri, protocols, opts);

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  this.ws.binaryType = &apos;arraybuffer&apos;;
  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function(){
  var self = this;

  this.ws.onopen = function(){
    self.onOpen();
  };
  this.ws.onclose = function(){
    self.onClose();
  };
  this.ws.onmessage = function(ev){
    self.onData(ev.data);
  };
  this.ws.onerror = function(e){
    self.onError(&apos;websocket error&apos;, e);
  };
};

/**
 * Override `onData` to use a timer on iOS.
 * See: https://gist.github.com/mloughran/2052006
 *
 * @api private
 */

if (&apos;undefined&apos; != typeof navigator
  &amp;&amp; /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
  WS.prototype.onData = function(data){
    var self = this;
    setTimeout(function(){
      Transport.prototype.onData.call(self, data);
    }, 0);
  };
}

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  for (var i = 0, l = packets.length; i &lt; l; i++) {
    parser.encodePacket(packets[i], this.supportsBinary, function(data) {
      //Sometimes the websocket has already been closed but the browser didn&apos;t
      //have a chance of informing us about it yet, in that case send will
      //throw an error
      try {
        self.ws.send(data);
      } catch (e){
        debug(&apos;websocket closed before onclose event&apos;);
      }
    });
  }

  function ondrain() {
    self.writable = true;
    self.emit(&apos;drain&apos;);
  }
  // fake drain
  // defer to next tick to allow Socket to clear writeBuffer
  setTimeout(ondrain, 0);
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function(){
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function(){
  if (typeof this.ws !== &apos;undefined&apos;) {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? &apos;wss&apos; : &apos;ws&apos;;
  var port = &apos;&apos;;

  // avoid port if default for schema
  if (this.port &amp;&amp; ((&apos;wss&apos; == schema &amp;&amp; this.port != 443)
    || (&apos;ws&apos; == schema &amp;&amp; this.port != 80))) {
    port = &apos;:&apos; + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = +new Date;
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = &apos;?&apos; + query;
  }

  return schema + &apos;://&apos; + this.hostname + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function(){
  return !!WebSocket &amp;&amp; !(&apos;__initialize&apos; in WebSocket &amp;&amp; this.name === WS.prototype.name);
};

},{&quot;../transport&quot;:14,&quot;component-inherit&quot;:21,&quot;debug&quot;:22,&quot;engine.io-parser&quot;:25,&quot;parseqs&quot;:35,&quot;ws&quot;:37}],20:[function(_dereq_,module,exports){
// browser shim for xmlhttprequest module
var hasCORS = _dereq_(&apos;has-cors&apos;);

module.exports = function(opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if (&apos;undefined&apos; != typeof XMLHttpRequest &amp;&amp; (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if (&apos;undefined&apos; != typeof XDomainRequest &amp;&amp; !xscheme &amp;&amp; enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);
    } catch(e) { }
  }
}

},{&quot;has-cors&quot;:40}],21:[function(_dereq_,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],22:[function(_dereq_,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = _dereq_(&apos;./debug&apos;);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [
  &apos;lightseagreen&apos;,
  &apos;forestgreen&apos;,
  &apos;goldenrod&apos;,
  &apos;dodgerblue&apos;,
  &apos;darkorchid&apos;,
  &apos;crimson&apos;
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox &gt;= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support &quot;%c&quot; CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return (&apos;WebkitAppearance&apos; in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console &amp;&amp; (console.firebug || (console.exception &amp;&amp; console.table))) ||
    // is firefox &gt;= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &amp;&amp; parseInt(RegExp.$1, 10) &gt;= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? &apos;%c&apos; : &apos;&apos;)
    + this.namespace
    + (useColors ? &apos; %c&apos; : &apos; &apos;)
    + args[0]
    + (useColors ? &apos;%c &apos; : &apos; &apos;)
    + &apos;+&apos; + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = &apos;color: &apos; + this.color;
  args = [args[0], c, &apos;color: inherit&apos;].concat(Array.prototype.slice.call(args, 1));

  // the final &quot;%c&quot; is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if (&apos;%&apos; === match) return;
    index++;
    if (&apos;%c&apos; === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a &quot;function&quot;.
 *
 * @api public
 */

function log() {
  // This hackery is required for IE8,
  // where the `console.log` function doesn&apos;t have &apos;apply&apos;
  return &apos;object&apos; == typeof console
    &amp;&amp; &apos;function&apos; == typeof console.log
    &amp;&amp; Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      localStorage.removeItem(&apos;debug&apos;);
    } else {
      localStorage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = localStorage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

},{&quot;./debug&quot;:23}],23:[function(_dereq_,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = _dereq_(&apos;ms&apos;);

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special &quot;%n&quot; handling functions, for the debug &quot;format&quot; argument.
 *
 * Valid key names are a single, lowercased letter, i.e. &quot;n&quot;.
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color &amp;&amp; self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if (&apos;string&apos; !== typeof args[0]) {
      // anything else let&apos;s inspect with %o
      args = [&apos;%o&apos;].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don&apos;t increase the array index
      if (match === &apos;%&apos;) return match;
      index++;
      var formatter = exports.formatters[format];
      if (&apos;function&apos; === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it&apos;s inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if (&apos;function&apos; === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || &apos;&apos;).split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i &lt; len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, &apos;.*?&apos;);
    if (namespaces[0] === &apos;-&apos;) {
      exports.skips.push(new RegExp(&apos;^&apos; + namespaces.substr(1) + &apos;$&apos;));
    } else {
      exports.names.push(new RegExp(&apos;^&apos; + namespaces + &apos;$&apos;));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable(&apos;&apos;);
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i &lt; len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i &lt; len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{&quot;ms&quot;:24}],24:[function(_dereq_,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if (&apos;string&apos; == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || &apos;ms&apos;).toLowerCase();
  switch (type) {
    case &apos;years&apos;:
    case &apos;year&apos;:
    case &apos;y&apos;:
      return n * y;
    case &apos;days&apos;:
    case &apos;day&apos;:
    case &apos;d&apos;:
      return n * d;
    case &apos;hours&apos;:
    case &apos;hour&apos;:
    case &apos;h&apos;:
      return n * h;
    case &apos;minutes&apos;:
    case &apos;minute&apos;:
    case &apos;m&apos;:
      return n * m;
    case &apos;seconds&apos;:
    case &apos;second&apos;:
    case &apos;s&apos;:
      return n * s;
    case &apos;ms&apos;:
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms &gt;= d) return Math.round(ms / d) + &apos;d&apos;;
  if (ms &gt;= h) return Math.round(ms / h) + &apos;h&apos;;
  if (ms &gt;= m) return Math.round(ms / m) + &apos;m&apos;;
  if (ms &gt;= s) return Math.round(ms / s) + &apos;s&apos;;
  return ms + &apos;ms&apos;;
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, &apos;day&apos;)
    || plural(ms, h, &apos;hour&apos;)
    || plural(ms, m, &apos;minute&apos;)
    || plural(ms, s, &apos;second&apos;)
    || ms + &apos; ms&apos;;
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms &lt; n) return;
  if (ms &lt; n * 1.5) return Math.floor(ms / n) + &apos; &apos; + name;
  return Math.ceil(ms / n) + &apos; &apos; + name + &apos;s&apos;;
}

},{}],25:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var keys = _dereq_(&apos;./keys&apos;);
var hasBinary = _dereq_(&apos;has-binary&apos;);
var sliceBuffer = _dereq_(&apos;arraybuffer.slice&apos;);
var base64encoder = _dereq_(&apos;base64-arraybuffer&apos;);
var after = _dereq_(&apos;after&apos;);
var utf8 = _dereq_(&apos;utf8&apos;);

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = navigator.userAgent.match(/Android/i);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: &apos;error&apos;, data: &apos;parser error&apos; };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = _dereq_(&apos;blob&apos;);

/**
 * Encodes a packet.
 *
 *     &lt;packet type id&gt; [ &lt;data&gt; ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if (&apos;function&apos; == typeof supportsBinary) {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if (&apos;function&apos; == typeof utf8encode) {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer &amp;&amp; data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob &amp;&amp; data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data &amp;&amp; data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
  }

  return callback(&apos;&apos; + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = &apos;b&apos; + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i &lt; contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = &apos;b&apos; + exports.packets[packet.type];
  if (Blob &amp;&amp; packet.data instanceof Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(&apos;,&apos;)[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn&apos;t let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i &lt; typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  // String data
  if (typeof data == &apos;string&apos; || data === undefined) {
    if (data.charAt(0) == &apos;b&apos;) {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      try {
        data = utf8.decode(data);
      } catch (e) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length &gt; 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob &amp;&amp; binaryType === &apos;blob&apos;) {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!global.ArrayBuffer) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === &apos;blob&apos; &amp;&amp; Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     &lt;length&gt;:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary == &apos;function&apos;) {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary &amp;&amp; isBinary) {
    if (Blob &amp;&amp; !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback(&apos;0:&apos;);
  }

  function setLengthHeader(message) {
    return message.length + &apos;:&apos; + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(&apos;&apos;));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i &lt; ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data != &apos;string&apos;) {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === &apos;function&apos;) {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data == &apos;&apos;) {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = &apos;&apos;
    , n, msg;

  for (var i = 0, l = data.length; i &lt; l; i++) {
    var chr = data.charAt(i);

    if (&apos;:&apos; != chr) {
      length += chr;
    } else {
      if (&apos;&apos; == length || (length != (n = Number(length)))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType, true);

        if (err.type == packet.type &amp;&amp; err.data == packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      }

      // advance cursor
      i += n;
      length = &apos;&apos;;
    }
  }

  if (length != &apos;&apos;) {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * &lt;1 = binary, 0 = string&gt;&lt;number from 0-9&gt;&lt;number from 0-9&gt;[...]&lt;number
 * 255&gt;&lt;data&gt;
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === &apos;string&apos;){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === &apos;string&apos;;
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i &lt; p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i &lt; lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i &lt; view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === &apos;string&apos;) {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i &lt; encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i &lt; lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === &apos;function&apos;) {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  var numberTooLong = false;
  while (bufferTail.byteLength &gt; 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = &apos;&apos;;

    for (var i = 1; ; i++) {
      if (tailArray[i] == 255) break;

      if (msgLength.length &gt; 310) {
        numberTooLong = true;
        break;
      }

      msgLength += tailArray[i];
    }

    if(numberTooLong) return callback(err, 0, 1);

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn&apos;t let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = &apos;&apos;;
        for (var i = 0; i &lt; typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;./keys&quot;:26,&quot;after&quot;:27,&quot;arraybuffer.slice&quot;:28,&quot;base64-arraybuffer&quot;:29,&quot;blob&quot;:30,&quot;has-binary&quot;:31,&quot;utf8&quot;:33}],26:[function(_dereq_,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],27:[function(_dereq_,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count &lt;= 0) {
            throw new Error(&apos;after called too many times&apos;)
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 &amp;&amp; !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],28:[function(_dereq_,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start &lt; 0) { start += bytes; }
  if (end &lt; 0) { end += bytes; }
  if (end &gt; bytes) { end = bytes; }

  if (start &gt;= bytes || start &gt;= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i &lt; end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],29:[function(_dereq_,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(chars){
  &quot;use strict&quot;;

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = &quot;&quot;;

    for (i = 0; i &lt; len; i+=3) {
      base64 += chars[bytes[i] &gt;&gt; 2];
      base64 += chars[((bytes[i] &amp; 3) &lt;&lt; 4) | (bytes[i + 1] &gt;&gt; 4)];
      base64 += chars[((bytes[i + 1] &amp; 15) &lt;&lt; 2) | (bytes[i + 2] &gt;&gt; 6)];
      base64 += chars[bytes[i + 2] &amp; 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + &quot;=&quot;;
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + &quot;==&quot;;
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === &quot;=&quot;) {
      bufferLength--;
      if (base64[base64.length - 2] === &quot;=&quot;) {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i &lt; len; i+=4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i+1]);
      encoded3 = chars.indexOf(base64[i+2]);
      encoded4 = chars.indexOf(base64[i+3]);

      bytes[p++] = (encoded1 &lt;&lt; 2) | (encoded2 &gt;&gt; 4);
      bytes[p++] = ((encoded2 &amp; 15) &lt;&lt; 4) | (encoded3 &gt;&gt; 2);
      bytes[p++] = ((encoded3 &amp; 3) &lt;&lt; 6) | (encoded4 &amp; 63);
    }

    return arraybuffer;
  };
})(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;);

},{}],30:[function(_dereq_,module,exports){
(function (global){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var b = new Blob([&apos;hi&apos;]);
    return b.size == 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  &amp;&amp; BlobBuilder.prototype.append
  &amp;&amp; BlobBuilder.prototype.getBlob;

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  for (var i = 0; i &lt; ary.length; i++) {
    bb.append(ary[i]);
  }
  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

module.exports = (function() {
  if (blobSupported) {
    return global.Blob;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{}],31:[function(_dereq_,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = _dereq_(&apos;isarray&apos;);

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer &amp;&amp; global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer &amp;&amp; obj instanceof ArrayBuffer) ||
         (global.Blob &amp;&amp; obj instanceof Blob) ||
         (global.File &amp;&amp; obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i &lt; obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj &amp;&amp; &apos;object&apos; == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (obj.hasOwnProperty(key) &amp;&amp; _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;isarray&quot;:32}],32:[function(_dereq_,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == &apos;[object Array]&apos;;
};

},{}],33:[function(_dereq_,module,exports){
(function (global){
/*! http://mths.be/utf8js v2.0.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == &apos;object&apos; &amp;&amp; exports;

	// Detect free variable `module`
	var freeModule = typeof module == &apos;object&apos; &amp;&amp; module &amp;&amp;
		module.exports == freeExports &amp;&amp; module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == &apos;object&apos; &amp;&amp; global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from http://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter &lt; length) {
			value = string.charCodeAt(counter++);
			if (value &gt;= 0xD800 &amp;&amp; value &lt;= 0xDBFF &amp;&amp; counter &lt; length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra &amp; 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value &amp; 0x3FF) &lt;&lt; 10) + (extra &amp; 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from http://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = &apos;&apos;;
		while (++index &lt; length) {
			value = array[index];
			if (value &gt; 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value &gt;&gt;&gt; 10 &amp; 0x3FF | 0xD800);
				value = 0xDC00 | value &amp; 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint &gt;&gt; shift) &amp; 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint &amp; 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = &apos;&apos;;
		if ((codePoint &amp; 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint &gt;&gt; 6) &amp; 0x1F) | 0xC0);
		}
		else if ((codePoint &amp; 0xFFFF0000) == 0) { // 3-byte sequence
			symbol = stringFromCharCode(((codePoint &gt;&gt; 12) &amp; 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint &amp; 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint &gt;&gt; 18) &amp; 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint &amp; 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);

		// console.log(JSON.stringify(codePoints.map(function(x) {
		// 	return &apos;U+&apos; + x.toString(16).toUpperCase();
		// })));

		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = &apos;&apos;;
		while (++index &lt; length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex &gt;= byteCount) {
			throw Error(&apos;Invalid byte index&apos;);
		}

		var continuationByte = byteArray[byteIndex] &amp; 0xFF;
		byteIndex++;

		if ((continuationByte &amp; 0xC0) == 0x80) {
			return continuationByte &amp; 0x3F;
		}

		// If we end up here, its not a continuation byte
		throw Error(&apos;Invalid continuation byte&apos;);
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex &gt; byteCount) {
			throw Error(&apos;Invalid byte index&apos;);
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] &amp; 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 &amp; 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 &amp; 0xE0) == 0xC0) {
			var byte2 = readContinuationByte();
			codePoint = ((byte1 &amp; 0x1F) &lt;&lt; 6) | byte2;
			if (codePoint &gt;= 0x80) {
				return codePoint;
			} else {
				throw Error(&apos;Invalid continuation byte&apos;);
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 &amp; 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 &amp; 0x0F) &lt;&lt; 12) | (byte2 &lt;&lt; 6) | byte3;
			if (codePoint &gt;= 0x0800) {
				return codePoint;
			} else {
				throw Error(&apos;Invalid continuation byte&apos;);
			}
		}

		// 4-byte sequence
		if ((byte1 &amp; 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 &amp; 0x0F) &lt;&lt; 0x12) | (byte2 &lt;&lt; 0x0C) |
				(byte3 &lt;&lt; 0x06) | byte4;
			if (codePoint &gt;= 0x010000 &amp;&amp; codePoint &lt;= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error(&apos;Invalid UTF-8 detected&apos;);
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		&apos;version&apos;: &apos;2.0.0&apos;,
		&apos;encode&apos;: utf8encode,
		&apos;decode&apos;: utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == &apos;function&apos; &amp;&amp;
		typeof define.amd == &apos;object&apos; &amp;&amp;
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports &amp;&amp; !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) &amp;&amp; (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{}],34:[function(_dereq_,module,exports){
(function (global){
/**
 * JSON parse.
 *
 * @see Based on jQuery#parseJSON (MIT) and JSON2
 * @api private
 */

var rvalidchars = /^[\],:{}\s]*$/;
var rvalidescape = /\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rvalidtokens = /&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
var rtrimLeft = /^\s+/;
var rtrimRight = /\s+$/;

module.exports = function parsejson(data) {
  if (&apos;string&apos; != typeof data || !data) {
    return null;
  }

  data = data.replace(rtrimLeft, &apos;&apos;).replace(rtrimRight, &apos;&apos;);

  // Attempt to parse using the native JSON parser first
  if (global.JSON &amp;&amp; JSON.parse) {
    return JSON.parse(data);
  }

  if (rvalidchars.test(data.replace(rvalidescape, &apos;@&apos;)
      .replace(rvalidtokens, &apos;]&apos;)
      .replace(rvalidbraces, &apos;&apos;))) {
    return (new Function(&apos;return &apos; + data))();
  }
};
}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{}],35:[function(_dereq_,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = &apos;&apos;;

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += &apos;&amp;&apos;;
      str += encodeURIComponent(i) + &apos;=&apos; + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split(&apos;&amp;&apos;);
  for (var i = 0, l = pairs.length; i &lt; l; i++) {
    var pair = pairs[i].split(&apos;=&apos;);
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],36:[function(_dereq_,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan &lt;stevenlevithan.com&gt; (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    &apos;source&apos;, &apos;protocol&apos;, &apos;authority&apos;, &apos;userInfo&apos;, &apos;user&apos;, &apos;password&apos;, &apos;host&apos;, &apos;port&apos;, &apos;relative&apos;, &apos;path&apos;, &apos;directory&apos;, &apos;file&apos;, &apos;query&apos;, &apos;anchor&apos;
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf(&apos;[&apos;),
        e = str.indexOf(&apos;]&apos;);

    if (b != -1 &amp;&amp; e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, &apos;;&apos;) + str.substring(e, str.length);
    }

    var m = re.exec(str || &apos;&apos;),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || &apos;&apos;;
    }

    if (b != -1 &amp;&amp; e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, &apos;:&apos;);
        uri.authority = uri.authority.replace(&apos;[&apos;, &apos;&apos;).replace(&apos;]&apos;, &apos;&apos;).replace(/;/g, &apos;:&apos;);
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],37:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var global = (function() { return this; })();

/**
 * WebSocket constructor.
 */

var WebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Module exports.
 */

module.exports = WebSocket ? ws : null;

/**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it&apos;s
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object) opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
  var instance;
  if (protocols) {
    instance = new WebSocket(uri, protocols);
  } else {
    instance = new WebSocket(uri);
  }
  return instance;
}

if (WebSocket) ws.prototype = WebSocket.prototype;

},{}],38:[function(_dereq_,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = _dereq_(&apos;isarray&apos;);

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer &amp;&amp; global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer &amp;&amp; obj instanceof ArrayBuffer) ||
         (global.Blob &amp;&amp; obj instanceof Blob) ||
         (global.File &amp;&amp; obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i &lt; obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj &amp;&amp; &apos;object&apos; == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) &amp;&amp; _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;isarray&quot;:39}],39:[function(_dereq_,module,exports){
module.exports=_dereq_(32)
},{}],40:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var global = _dereq_(&apos;global&apos;);

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = &apos;XMLHttpRequest&apos; in global &amp;&amp;
    &apos;withCredentials&apos; in new global.XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{&quot;global&quot;:41}],41:[function(_dereq_,module,exports){

/**
 * Returns `this`. Execute this without a &quot;context&quot; (i.e. without it being
 * attached to an object of the left-hand side), and `this` points to the
 * &quot;global&quot; scope of the current JS execution.
 */

module.exports = (function () { return this; })();

},{}],42:[function(_dereq_,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i &lt; arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],43:[function(_dereq_,module,exports){

/**
 * HOP ref.
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Return own keys in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.keys = Object.keys || function(obj){
  var keys = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
};

/**
 * Return own values in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.values = function(obj){
  var vals = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      vals.push(obj[key]);
    }
  }
  return vals;
};

/**
 * Merge `b` into `a`.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api public
 */

exports.merge = function(a, b){
  for (var key in b) {
    if (has.call(b, key)) {
      a[key] = b[key];
    }
  }
  return a;
};

/**
 * Return length of `obj`.
 *
 * @param {Object} obj
 * @return {Number}
 * @api public
 */

exports.length = function(obj){
  return exports.keys(obj).length;
};

/**
 * Check if `obj` is empty.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api public
 */

exports.isEmpty = function(obj){
  return 0 == exports.length(obj);
};
},{}],44:[function(_dereq_,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan &lt;stevenlevithan.com&gt; (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    &apos;source&apos;, &apos;protocol&apos;, &apos;authority&apos;, &apos;userInfo&apos;, &apos;user&apos;, &apos;password&apos;, &apos;host&apos;
  , &apos;port&apos;, &apos;relative&apos;, &apos;path&apos;, &apos;directory&apos;, &apos;file&apos;, &apos;query&apos;, &apos;anchor&apos;
];

module.exports = function parseuri(str) {
  var m = re.exec(str || &apos;&apos;)
    , uri = {}
    , i = 14;

  while (i--) {
    uri[parts[i]] = m[i] || &apos;&apos;;
  }

  return uri;
};

},{}],45:[function(_dereq_,module,exports){
(function (global){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = _dereq_(&apos;isarray&apos;);
var isBuf = _dereq_(&apos;./is-buffer&apos;);

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet){
  var buffers = [];
  var packetData = packet.data;

  function _deconstructPacket(data) {
    if (!data) return data;

    if (isBuf(data)) {
      var placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (isArray(data)) {
      var newData = new Array(data.length);
      for (var i = 0; i &lt; data.length; i++) {
        newData[i] = _deconstructPacket(data[i]);
      }
      return newData;
    } else if (&apos;object&apos; == typeof data &amp;&amp; !(data instanceof Date)) {
      var newData = {};
      for (var key in data) {
        newData[key] = _deconstructPacket(data[key]);
      }
      return newData;
    }
    return data;
  }

  var pack = packet;
  pack.data = _deconstructPacket(packetData);
  pack.attachments = buffers.length; // number of binary &apos;attachments&apos;
  return {packet: pack, buffers: buffers};
};

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  var curPlaceHolder = 0;

  function _reconstructPacket(data) {
    if (data &amp;&amp; data._placeholder) {
      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
      return buf;
    } else if (isArray(data)) {
      for (var i = 0; i &lt; data.length; i++) {
        data[i] = _reconstructPacket(data[i]);
      }
      return data;
    } else if (data &amp;&amp; &apos;object&apos; == typeof data) {
      for (var key in data) {
        data[key] = _reconstructPacket(data[key]);
      }
      return data;
    }
    return data;
  }

  packet.data = _reconstructPacket(packet.data);
  packet.attachments = undefined; // no longer useful
  return packet;
};

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader&apos;s readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((global.Blob &amp;&amp; obj instanceof Blob) ||
        (global.File &amp;&amp; obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -&gt; arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i &lt; obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (obj &amp;&amp; &apos;object&apos; == typeof obj &amp;&amp; !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;./is-buffer&quot;:47,&quot;isarray&quot;:48}],46:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var debug = _dereq_(&apos;debug&apos;)(&apos;socket.io-parser&apos;);
var json = _dereq_(&apos;json3&apos;);
var isArray = _dereq_(&apos;isarray&apos;);
var Emitter = _dereq_(&apos;component-emitter&apos;);
var binary = _dereq_(&apos;./binary&apos;);
var isBuf = _dereq_(&apos;./is-buffer&apos;);

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  &apos;CONNECT&apos;,
  &apos;DISCONNECT&apos;,
  &apos;EVENT&apos;,
  &apos;BINARY_EVENT&apos;,
  &apos;ACK&apos;,
  &apos;BINARY_ACK&apos;,
  &apos;ERROR&apos;
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type &apos;binary event&apos;
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug(&apos;encoding packet %j&apos;, obj);

  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {
  var str = &apos;&apos;;
  var nsp = false;

  // first is type
  str += obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    str += obj.attachments;
    str += &apos;-&apos;;
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp &amp;&amp; &apos;/&apos; != obj.nsp) {
    nsp = true;
    str += obj.nsp;
  }

  // immediately followed by the id
  if (null != obj.id) {
    if (nsp) {
      str += &apos;,&apos;;
      nsp = false;
    }
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    if (nsp) str += &apos;,&apos;;
    str += json.stringify(obj.data);
  }

  debug(&apos;encoded %j as %s&apos;, obj, str);
  return str;
}

/**
 * Encode packet as &apos;buffer sequence&apos; by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if (&apos;string&apos; == typeof obj) {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet&apos;s json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit(&apos;decoded&apos;, packet);
      }
    } else { // non-binary full packet
      this.emit(&apos;decoded&apos;, packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error(&apos;got binary data when not reconstructing a packet&apos;);
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit(&apos;decoded&apos;, packet);
      }
    }
  }
  else {
    throw new Error(&apos;Unknown type: &apos; + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var p = {};
  var i = 0;

  // look up type
  p.type = Number(str.charAt(0));
  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
    var buf = &apos;&apos;;
    while (str.charAt(++i) != &apos;-&apos;) {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) != &apos;-&apos;) {
      throw new Error(&apos;Illegal attachments&apos;);
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if (&apos;/&apos; == str.charAt(i + 1)) {
    p.nsp = &apos;&apos;;
    while (++i) {
      var c = str.charAt(i);
      if (&apos;,&apos; == c) break;
      p.nsp += c;
      if (i == str.length) break;
    }
  } else {
    p.nsp = &apos;/&apos;;
  }

  // look up id
  var next = str.charAt(i + 1);
  if (&apos;&apos; !== next &amp;&amp; Number(next) == next) {
    p.id = &apos;&apos;;
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i == str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    try {
      p.data = json.parse(str.substr(i));
    } catch(e){
      return error();
    }
  }

  debug(&apos;decoded %s as %j&apos;, str, p);
  return p;
}

/**
 * Deallocates a parser&apos;s resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event&apos;s &apos;buffer sequence&apos;. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(data){
  return {
    type: exports.ERROR,
    data: &apos;parser error&apos;
  };
}

},{&quot;./binary&quot;:45,&quot;./is-buffer&quot;:47,&quot;component-emitter&quot;:9,&quot;debug&quot;:10,&quot;isarray&quot;:48,&quot;json3&quot;:49}],47:[function(_dereq_,module,exports){
(function (global){

module.exports = isBuf;

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (global.Buffer &amp;&amp; global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer &amp;&amp; obj instanceof ArrayBuffer);
}

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{}],48:[function(_dereq_,module,exports){
module.exports=_dereq_(32)
},{}],49:[function(_dereq_,module,exports){
/*! JSON v3.2.6 | http://bestiejs.github.io/json3 | Copyright 2012-2013, Kit Cambridge | http://kit.mit-license.org */
;(function (window) {
  // Convenience aliases.
  var getClass = {}.toString, isProperty, forEach, undef;

  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === &quot;function&quot; &amp;&amp; define.amd;

  // Detect native implementations.
  var nativeJSON = typeof JSON == &quot;object&quot; &amp;&amp; JSON;

  // Set up the JSON 3 namespace, preferring the CommonJS `exports` object if
  // available.
  var JSON3 = typeof exports == &quot;object&quot; &amp;&amp; exports &amp;&amp; !exports.nodeType &amp;&amp; exports;

  if (JSON3 &amp;&amp; nativeJSON) {
    // Explicitly delegate to the native `stringify` and `parse`
    // implementations in CommonJS environments.
    JSON3.stringify = nativeJSON.stringify;
    JSON3.parse = nativeJSON.parse;
  } else {
    // Export for web browsers, JavaScript engines, and asynchronous module
    // loaders, using the global `JSON` object if available.
    JSON3 = window.JSON = nativeJSON || {};
  }

  // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
  var isExtended = new Date(-3509827334573292);
  try {
    // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
    // results for certain dates in Opera &gt;= 10.53.
    isExtended = isExtended.getUTCFullYear() == -109252 &amp;&amp; isExtended.getUTCMonth() === 0 &amp;&amp; isExtended.getUTCDate() === 1 &amp;&amp;
      // Safari &lt; 2.0.2 stores the internal millisecond time value correctly,
      // but clips the values returned by the date methods to the range of
      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
      isExtended.getUTCHours() == 10 &amp;&amp; isExtended.getUTCMinutes() == 37 &amp;&amp; isExtended.getUTCSeconds() == 6 &amp;&amp; isExtended.getUTCMilliseconds() == 708;
  } catch (exception) {}

  // Internal: Determines whether the native `JSON.stringify` and `parse`
  // implementations are spec-compliant. Based on work by Ken Snyder.
  function has(name) {
    if (has[name] !== undef) {
      // Return cached feature test result.
      return has[name];
    }

    var isSupported;
    if (name == &quot;bug-string-char-index&quot;) {
      // IE &lt;= 7 doesn&apos;t support accessing string characters using square
      // bracket notation. IE 8 only supports this for primitives.
      isSupported = &quot;a&quot;[0] != &quot;a&quot;;
    } else if (name == &quot;json&quot;) {
      // Indicates whether both `JSON.stringify` and `JSON.parse` are
      // supported.
      isSupported = has(&quot;json-stringify&quot;) &amp;&amp; has(&quot;json-parse&quot;);
    } else {
      var value, serialized = &apos;{&quot;a&quot;:[1,true,false,null,&quot;\\u0000\\b\\n\\f\\r\\t&quot;]}&apos;;
      // Test `JSON.stringify`.
      if (name == &quot;json-stringify&quot;) {
        var stringify = JSON3.stringify, stringifySupported = typeof stringify == &quot;function&quot; &amp;&amp; isExtended;
        if (stringifySupported) {
          // A test function object with a custom `toJSON` method.
          (value = function () {
            return 1;
          }).toJSON = value;
          try {
            stringifySupported =
              // Firefox 3.1b1 and b2 serialize string, number, and boolean
              // primitives as object literals.
              stringify(0) === &quot;0&quot; &amp;&amp;
              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
              // literals.
              stringify(new Number()) === &quot;0&quot; &amp;&amp;
              stringify(new String()) == &apos;&quot;&quot;&apos; &amp;&amp;
              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
              // does not define a canonical JSON representation (this applies to
              // objects with `toJSON` properties as well, *unless* they are nested
              // within an object or array).
              stringify(getClass) === undef &amp;&amp;
              // IE 8 serializes `undefined` as `&quot;undefined&quot;`. Safari &lt;= 5.1.7 and
              // FF 3.1b3 pass this test.
              stringify(undef) === undef &amp;&amp;
              // Safari &lt;= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
              // respectively, if the value is omitted entirely.
              stringify() === undef &amp;&amp;
              // FF 3.1b1, 2 throw an error if the given value is not a number,
              // string, array, object, Boolean, or `null` literal. This applies to
              // objects with custom `toJSON` methods as well, unless they are nested
              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
              // methods entirely.
              stringify(value) === &quot;1&quot; &amp;&amp;
              stringify([value]) == &quot;[1]&quot; &amp;&amp;
              // Prototype &lt;= 1.6.1 serializes `[undefined]` as `&quot;[]&quot;` instead of
              // `&quot;[null]&quot;`.
              stringify([undef]) == &quot;[null]&quot; &amp;&amp;
              // YUI 3.0.0b1 fails to serialize `null` literals.
              stringify(null) == &quot;null&quot; &amp;&amp;
              // FF 3.1b1, 2 halts serialization if an array contains a function:
              // `[1, true, getClass, 1]` serializes as &quot;[1,true,],&quot;. FF 3.1b3
              // elides non-JSON values from objects and arrays, unless they
              // define custom `toJSON` methods.
              stringify([undef, getClass, null]) == &quot;[null,null,null]&quot; &amp;&amp;
              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
              // where character escape codes are expected (e.g., `\b` =&gt; `\u0008`).
              stringify({ &quot;a&quot;: [value, true, false, null, &quot;\x00\b\n\f\r\t&quot;] }) == serialized &amp;&amp;
              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
              stringify(null, value) === &quot;1&quot; &amp;&amp;
              stringify([1, 2], null, 1) == &quot;[\n 1,\n 2\n]&quot; &amp;&amp;
              // JSON 2, Prototype &lt;= 1.7, and older WebKit builds incorrectly
              // serialize extended years.
              stringify(new Date(-8.64e15)) == &apos;&quot;-271821-04-20T00:00:00.000Z&quot;&apos; &amp;&amp;
              // The milliseconds are optional in ES 5, but required in 5.1.
              stringify(new Date(8.64e15)) == &apos;&quot;+275760-09-13T00:00:00.000Z&quot;&apos; &amp;&amp;
              // Firefox &lt;= 11.0 incorrectly serializes years prior to 0 as negative
              // four-digit years instead of six-digit years. Credits: @Yaffle.
              stringify(new Date(-621987552e5)) == &apos;&quot;-000001-01-01T00:00:00.000Z&quot;&apos; &amp;&amp;
              // Safari &lt;= 5.1.5 and Opera &gt;= 10.53 incorrectly serialize millisecond
              // values less than 1000. Credits: @Yaffle.
              stringify(new Date(-1)) == &apos;&quot;1969-12-31T23:59:59.999Z&quot;&apos;;
          } catch (exception) {
            stringifySupported = false;
          }
        }
        isSupported = stringifySupported;
      }
      // Test `JSON.parse`.
      if (name == &quot;json-parse&quot;) {
        var parse = JSON3.parse;
        if (typeof parse == &quot;function&quot;) {
          try {
            // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
            // Conforming implementations should also coerce the initial argument to
            // a string prior to parsing.
            if (parse(&quot;0&quot;) === 0 &amp;&amp; !parse(false)) {
              // Simple parsing test.
              value = parse(serialized);
              var parseSupported = value[&quot;a&quot;].length == 5 &amp;&amp; value[&quot;a&quot;][0] === 1;
              if (parseSupported) {
                try {
                  // Safari &lt;= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                  parseSupported = !parse(&apos;&quot;\t&quot;&apos;);
                } catch (exception) {}
                if (parseSupported) {
                  try {
                    // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                    // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                    // certain octal literals.
                    parseSupported = parse(&quot;01&quot;) !== 1;
                  } catch (exception) {}
                }
                if (parseSupported) {
                  try {
                    // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                    // points. These environments, along with FF 3.1b1 and 2,
                    // also allow trailing commas in JSON objects and arrays.
                    parseSupported = parse(&quot;1.&quot;) !== 1;
                  } catch (exception) {}
                }
              }
            }
          } catch (exception) {
            parseSupported = false;
          }
        }
        isSupported = parseSupported;
      }
    }
    return has[name] = !!isSupported;
  }

  if (!has(&quot;json&quot;)) {
    // Common `[[Class]]` name aliases.
    var functionClass = &quot;[object Function]&quot;;
    var dateClass = &quot;[object Date]&quot;;
    var numberClass = &quot;[object Number]&quot;;
    var stringClass = &quot;[object String]&quot;;
    var arrayClass = &quot;[object Array]&quot;;
    var booleanClass = &quot;[object Boolean]&quot;;

    // Detect incomplete support for accessing string characters by index.
    var charIndexBuggy = has(&quot;bug-string-char-index&quot;);

    // Define additional utility methods if the `Date` methods are buggy.
    if (!isExtended) {
      var floor = Math.floor;
      // A mapping between the months of the year and the number of days between
      // January 1st and the first of the respective month.
      var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      // Internal: Calculates the number of days between the Unix epoch and the
      // first day of the given month.
      var getDay = function (year, month) {
        return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month &gt; 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
      };
    }

    // Internal: Determines if a property is a direct property of the given
    // object. Delegates to the native `Object#hasOwnProperty` method.
    if (!(isProperty = {}.hasOwnProperty)) {
      isProperty = function (property) {
        var members = {}, constructor;
        if ((members.__proto__ = null, members.__proto__ = {
          // The *proto* property cannot be set multiple times in recent
          // versions of Firefox and SeaMonkey.
          &quot;toString&quot;: 1
        }, members).toString != getClass) {
          // Safari &lt;= 2.0.3 doesn&apos;t implement `Object#hasOwnProperty`, but
          // supports the mutable *proto* property.
          isProperty = function (property) {
            // Capture and break the object&apos;s prototype chain (see section 8.6.2
            // of the ES 5.1 spec). The parenthesized expression prevents an
            // unsafe transformation by the Closure Compiler.
            var original = this.__proto__, result = property in (this.__proto__ = null, this);
            // Restore the original prototype chain.
            this.__proto__ = original;
            return result;
          };
        } else {
          // Capture a reference to the top-level `Object` constructor.
          constructor = members.constructor;
          // Use the `constructor` property to simulate `Object#hasOwnProperty` in
          // other environments.
          isProperty = function (property) {
            var parent = (this.constructor || constructor).prototype;
            return property in this &amp;&amp; !(property in parent &amp;&amp; this[property] === parent[property]);
          };
        }
        members = null;
        return isProperty.call(this, property);
      };
    }

    // Internal: A set of primitive types used by `isHostType`.
    var PrimitiveTypes = {
      &apos;boolean&apos;: 1,
      &apos;number&apos;: 1,
      &apos;string&apos;: 1,
      &apos;undefined&apos;: 1
    };

    // Internal: Determines if the given object `property` value is a
    // non-primitive.
    var isHostType = function (object, property) {
      var type = typeof object[property];
      return type == &apos;object&apos; ? !!object[property] : !PrimitiveTypes[type];
    };

    // Internal: Normalizes the `for...in` iteration algorithm across
    // environments. Each enumerated key is yielded to a `callback` function.
    forEach = function (object, callback) {
      var size = 0, Properties, members, property;

      // Tests for bugs in the current environment&apos;s `for...in` algorithm. The
      // `valueOf` property inherits the non-enumerable flag from
      // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
      (Properties = function () {
        this.valueOf = 0;
      }).prototype.valueOf = 0;

      // Iterate over a new instance of the `Properties` class.
      members = new Properties();
      for (property in members) {
        // Ignore all properties inherited from `Object.prototype`.
        if (isProperty.call(members, property)) {
          size++;
        }
      }
      Properties = members = null;

      // Normalize the iteration algorithm.
      if (!size) {
        // A list of non-enumerable properties inherited from `Object.prototype`.
        members = [&quot;valueOf&quot;, &quot;toString&quot;, &quot;toLocaleString&quot;, &quot;propertyIsEnumerable&quot;, &quot;isPrototypeOf&quot;, &quot;hasOwnProperty&quot;, &quot;constructor&quot;];
        // IE &lt;= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
        // properties.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, length;
          var hasProperty = !isFunction &amp;&amp; typeof object.constructor != &apos;function&apos; &amp;&amp; isHostType(object, &apos;hasOwnProperty&apos;) ? object.hasOwnProperty : isProperty;
          for (property in object) {
            // Gecko &lt;= 1.0 enumerates the `prototype` property of functions under
            // certain conditions; IE does not.
            if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; hasProperty.call(object, property)) {
              callback(property);
            }
          }
          // Manually invoke the callback for each non-enumerable property.
          for (length = members.length; property = members[--length]; hasProperty.call(object, property) &amp;&amp; callback(property));
        };
      } else if (size == 2) {
        // Safari &lt;= 2.0.4 enumerates shadowed properties twice.
        forEach = function (object, callback) {
          // Create a set of iterated properties.
          var members = {}, isFunction = getClass.call(object) == functionClass, property;
          for (property in object) {
            // Store each property name to prevent double enumeration. The
            // `prototype` property of functions is not enumerated due to cross-
            // environment inconsistencies.
            if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; !isProperty.call(members, property) &amp;&amp; (members[property] = 1) &amp;&amp; isProperty.call(object, property)) {
              callback(property);
            }
          }
        };
      } else {
        // No bugs detected; use the standard `for...in` algorithm.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, isConstructor;
          for (property in object) {
            if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; isProperty.call(object, property) &amp;&amp; !(isConstructor = property === &quot;constructor&quot;)) {
              callback(property);
            }
          }
          // Manually invoke the callback for the `constructor` property due to
          // cross-environment inconsistencies.
          if (isConstructor || isProperty.call(object, (property = &quot;constructor&quot;))) {
            callback(property);
          }
        };
      }
      return forEach(object, callback);
    };

    // Public: Serializes a JavaScript `value` as a JSON string. The optional
    // `filter` argument may specify either a function that alters how object and
    // array members are serialized, or an array of strings and numbers that
    // indicates which properties should be serialized. The optional `width`
    // argument may be either a string or number that specifies the indentation
    // level of the output.
    if (!has(&quot;json-stringify&quot;)) {
      // Internal: A map of control characters and their escaped equivalents.
      var Escapes = {
        92: &quot;\\\\&quot;,
        34: &apos;\\&quot;&apos;,
        8: &quot;\\b&quot;,
        12: &quot;\\f&quot;,
        10: &quot;\\n&quot;,
        13: &quot;\\r&quot;,
        9: &quot;\\t&quot;
      };

      // Internal: Converts `value` into a zero-padded string such that its
      // length is at least equal to `width`. The `width` must be &lt;= 6.
      var leadingZeroes = &quot;000000&quot;;
      var toPaddedString = function (width, value) {
        // The `|| 0` expression is necessary to work around a bug in
        // Opera &lt;= 7.54u2 where `0 == -0`, but `String(-0) !== &quot;0&quot;`.
        return (leadingZeroes + (value || 0)).slice(-width);
      };

      // Internal: Double-quotes a string `value`, replacing all ASCII control
      // characters (characters with code unit values between 0 and 31) with
      // their escaped equivalents. This is an implementation of the
      // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
      var unicodePrefix = &quot;\\u00&quot;;
      var quote = function (value) {
        var result = &apos;&quot;&apos;, index = 0, length = value.length, isLarge = length &gt; 10 &amp;&amp; charIndexBuggy, symbols;
        if (isLarge) {
          symbols = value.split(&quot;&quot;);
        }
        for (; index &lt; length; index++) {
          var charCode = value.charCodeAt(index);
          // If the character is a control character, append its Unicode or
          // shorthand escape sequence; otherwise, append the character as-is.
          switch (charCode) {
            case 8: case 9: case 10: case 12: case 13: case 34: case 92:
              result += Escapes[charCode];
              break;
            default:
              if (charCode &lt; 32) {
                result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                break;
              }
              result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];
          }
        }
        return result + &apos;&quot;&apos;;
      };

      // Internal: Recursively serializes an object. Implements the
      // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
      var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
        var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
        try {
          // Necessary for host object support.
          value = object[property];
        } catch (exception) {}
        if (typeof value == &quot;object&quot; &amp;&amp; value) {
          className = getClass.call(value);
          if (className == dateClass &amp;&amp; !isProperty.call(value, &quot;toJSON&quot;)) {
            if (value &gt; -1 / 0 &amp;&amp; value &lt; 1 / 0) {
              // Dates are serialized according to the `Date#toJSON` method
              // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
              // for the ISO 8601 date time string format.
              if (getDay) {
                // Manually compute the year, month, date, hours, minutes,
                // seconds, and milliseconds if the `getUTC*` methods are
                // buggy. Adapted from @Yaffle&apos;s `date-shim` project.
                date = floor(value / 864e5);
                for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) &lt;= date; year++);
                for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) &lt;= date; month++);
                date = 1 + date - getDay(year, month);
                // The `time` value specifies the time within the day (see ES
                // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                // to compute `A modulo B`, as the `%` operator does not
                // correspond to the `modulo` operation for negative numbers.
                time = (value % 864e5 + 864e5) % 864e5;
                // The hours, minutes, seconds, and milliseconds are obtained by
                // decomposing the time within the day. See section 15.9.1.10.
                hours = floor(time / 36e5) % 24;
                minutes = floor(time / 6e4) % 60;
                seconds = floor(time / 1e3) % 60;
                milliseconds = time % 1e3;
              } else {
                year = value.getUTCFullYear();
                month = value.getUTCMonth();
                date = value.getUTCDate();
                hours = value.getUTCHours();
                minutes = value.getUTCMinutes();
                seconds = value.getUTCSeconds();
                milliseconds = value.getUTCMilliseconds();
              }
              // Serialize extended years correctly.
              value = (year &lt;= 0 || year &gt;= 1e4 ? (year &lt; 0 ? &quot;-&quot; : &quot;+&quot;) + toPaddedString(6, year &lt; 0 ? -year : year) : toPaddedString(4, year)) +
                &quot;-&quot; + toPaddedString(2, month + 1) + &quot;-&quot; + toPaddedString(2, date) +
                // Months, dates, hours, minutes, and seconds should have two
                // digits; milliseconds should have three.
                &quot;T&quot; + toPaddedString(2, hours) + &quot;:&quot; + toPaddedString(2, minutes) + &quot;:&quot; + toPaddedString(2, seconds) +
                // Milliseconds are optional in ES 5.0, but required in 5.1.
                &quot;.&quot; + toPaddedString(3, milliseconds) + &quot;Z&quot;;
            } else {
              value = null;
            }
          } else if (typeof value.toJSON == &quot;function&quot; &amp;&amp; ((className != numberClass &amp;&amp; className != stringClass &amp;&amp; className != arrayClass) || isProperty.call(value, &quot;toJSON&quot;))) {
            // Prototype &lt;= 1.6.1 adds non-standard `toJSON` methods to the
            // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
            // ignores all `toJSON` methods on these objects unless they are
            // defined directly on an instance.
            value = value.toJSON(property);
          }
        }
        if (callback) {
          // If a replacement function was provided, call it to obtain the value
          // for serialization.
          value = callback.call(object, property, value);
        }
        if (value === null) {
          return &quot;null&quot;;
        }
        className = getClass.call(value);
        if (className == booleanClass) {
          // Booleans are represented literally.
          return &quot;&quot; + value;
        } else if (className == numberClass) {
          // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
          // `&quot;null&quot;`.
          return value &gt; -1 / 0 &amp;&amp; value &lt; 1 / 0 ? &quot;&quot; + value : &quot;null&quot;;
        } else if (className == stringClass) {
          // Strings are double-quoted and escaped.
          return quote(&quot;&quot; + value);
        }
        // Recursively serialize objects and arrays.
        if (typeof value == &quot;object&quot;) {
          // Check for cyclic structures. This is a linear search; performance
          // is inversely proportional to the number of unique nested objects.
          for (length = stack.length; length--;) {
            if (stack[length] === value) {
              // Cyclic structures cannot be serialized by `JSON.stringify`.
              throw TypeError();
            }
          }
          // Add the object to the stack of traversed objects.
          stack.push(value);
          results = [];
          // Save the current indentation level and indent one additional level.
          prefix = indentation;
          indentation += whitespace;
          if (className == arrayClass) {
            // Recursively serialize array elements.
            for (index = 0, length = value.length; index &lt; length; index++) {
              element = serialize(index, value, callback, properties, whitespace, indentation, stack);
              results.push(element === undef ? &quot;null&quot; : element);
            }
            result = results.length ? (whitespace ? &quot;[\n&quot; + indentation + results.join(&quot;,\n&quot; + indentation) + &quot;\n&quot; + prefix + &quot;]&quot; : (&quot;[&quot; + results.join(&quot;,&quot;) + &quot;]&quot;)) : &quot;[]&quot;;
          } else {
            // Recursively serialize object members. Members are selected from
            // either a user-specified list of property names, or the object
            // itself.
            forEach(properties || value, function (property) {
              var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
              if (element !== undef) {
                // According to ES 5.1 section 15.12.3: &quot;If `gap` {whitespace}
                // is not the empty string, let `member` {quote(property) + &quot;:&quot;}
                // be the concatenation of `member` and the `space` character.&quot;
                // The &quot;`space` character&quot; refers to the literal space
                // character, not the `space` {width} argument provided to
                // `JSON.stringify`.
                results.push(quote(property) + &quot;:&quot; + (whitespace ? &quot; &quot; : &quot;&quot;) + element);
              }
            });
            result = results.length ? (whitespace ? &quot;{\n&quot; + indentation + results.join(&quot;,\n&quot; + indentation) + &quot;\n&quot; + prefix + &quot;}&quot; : (&quot;{&quot; + results.join(&quot;,&quot;) + &quot;}&quot;)) : &quot;{}&quot;;
          }
          // Remove the object from the traversed object stack.
          stack.pop();
          return result;
        }
      };

      // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
      JSON3.stringify = function (source, filter, width) {
        var whitespace, callback, properties, className;
        if (typeof filter == &quot;function&quot; || typeof filter == &quot;object&quot; &amp;&amp; filter) {
          if ((className = getClass.call(filter)) == functionClass) {
            callback = filter;
          } else if (className == arrayClass) {
            // Convert the property names array into a makeshift set.
            properties = {};
            for (var index = 0, length = filter.length, value; index &lt; length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) &amp;&amp; (properties[value] = 1));
          }
        }
        if (width) {
          if ((className = getClass.call(width)) == numberClass) {
            // Convert the `width` to an integer and create a string containing
            // `width` number of space characters.
            if ((width -= width % 1) &gt; 0) {
              for (whitespace = &quot;&quot;, width &gt; 10 &amp;&amp; (width = 10); whitespace.length &lt; width; whitespace += &quot; &quot;);
            }
          } else if (className == stringClass) {
            whitespace = width.length &lt;= 10 ? width : width.slice(0, 10);
          }
        }
        // Opera &lt;= 7.54u2 discards the values associated with empty string keys
        // (`&quot;&quot;`) only if they are used directly within an object member list
        // (e.g., `!(&quot;&quot; in { &quot;&quot;: 1})`).
        return serialize(&quot;&quot;, (value = {}, value[&quot;&quot;] = source, value), callback, properties, whitespace, &quot;&quot;, []);
      };
    }

    // Public: Parses a JSON source string.
    if (!has(&quot;json-parse&quot;)) {
      var fromCharCode = String.fromCharCode;

      // Internal: A map of escaped control characters and their unescaped
      // equivalents.
      var Unescapes = {
        92: &quot;\\&quot;,
        34: &apos;&quot;&apos;,
        47: &quot;/&quot;,
        98: &quot;\b&quot;,
        116: &quot;\t&quot;,
        110: &quot;\n&quot;,
        102: &quot;\f&quot;,
        114: &quot;\r&quot;
      };

      // Internal: Stores the parser state.
      var Index, Source;

      // Internal: Resets the parser state and throws a `SyntaxError`.
      var abort = function() {
        Index = Source = null;
        throw SyntaxError();
      };

      // Internal: Returns the next token, or `&quot;$&quot;` if the parser has reached
      // the end of the source string. A token may be a string, number, `null`
      // literal, or Boolean literal.
      var lex = function () {
        var source = Source, length = source.length, value, begin, position, isSigned, charCode;
        while (Index &lt; length) {
          charCode = source.charCodeAt(Index);
          switch (charCode) {
            case 9: case 10: case 13: case 32:
              // Skip whitespace tokens, including tabs, carriage returns, line
              // feeds, and space characters.
              Index++;
              break;
            case 123: case 125: case 91: case 93: case 58: case 44:
              // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
              // the current position.
              value = charIndexBuggy ? source.charAt(Index) : source[Index];
              Index++;
              return value;
            case 34:
              // `&quot;` delimits a JSON string; advance to the next character and
              // begin parsing the string. String tokens are prefixed with the
              // sentinel `@` character to distinguish them from punctuators and
              // end-of-string tokens.
              for (value = &quot;@&quot;, Index++; Index &lt; length;) {
                charCode = source.charCodeAt(Index);
                if (charCode &lt; 32) {
                  // Unescaped ASCII control characters (those with a code unit
                  // less than the space character) are not permitted.
                  abort();
                } else if (charCode == 92) {
                  // A reverse solidus (`\`) marks the beginning of an escaped
                  // control character (including `&quot;`, `\`, and `/`) or Unicode
                  // escape sequence.
                  charCode = source.charCodeAt(++Index);
                  switch (charCode) {
                    case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                      // Revive escaped control characters.
                      value += Unescapes[charCode];
                      Index++;
                      break;
                    case 117:
                      // `\u` marks the beginning of a Unicode escape sequence.
                      // Advance to the first character and validate the
                      // four-digit code point.
                      begin = ++Index;
                      for (position = Index + 4; Index &lt; position; Index++) {
                        charCode = source.charCodeAt(Index);
                        // A valid sequence comprises four hexdigits (case-
                        // insensitive) that form a single hexadecimal value.
                        if (!(charCode &gt;= 48 &amp;&amp; charCode &lt;= 57 || charCode &gt;= 97 &amp;&amp; charCode &lt;= 102 || charCode &gt;= 65 &amp;&amp; charCode &lt;= 70)) {
                          // Invalid Unicode escape sequence.
                          abort();
                        }
                      }
                      // Revive the escaped character.
                      value += fromCharCode(&quot;0x&quot; + source.slice(begin, Index));
                      break;
                    default:
                      // Invalid escape sequence.
                      abort();
                  }
                } else {
                  if (charCode == 34) {
                    // An unescaped double-quote character marks the end of the
                    // string.
                    break;
                  }
                  charCode = source.charCodeAt(Index);
                  begin = Index;
                  // Optimize for the common case where a string is valid.
                  while (charCode &gt;= 32 &amp;&amp; charCode != 92 &amp;&amp; charCode != 34) {
                    charCode = source.charCodeAt(++Index);
                  }
                  // Append the string as-is.
                  value += source.slice(begin, Index);
                }
              }
              if (source.charCodeAt(Index) == 34) {
                // Advance to the next character and return the revived string.
                Index++;
                return value;
              }
              // Unterminated string.
              abort();
            default:
              // Parse numbers and literals.
              begin = Index;
              // Advance past the negative sign, if one is specified.
              if (charCode == 45) {
                isSigned = true;
                charCode = source.charCodeAt(++Index);
              }
              // Parse an integer or floating-point value.
              if (charCode &gt;= 48 &amp;&amp; charCode &lt;= 57) {
                // Leading zeroes are interpreted as octal literals.
                if (charCode == 48 &amp;&amp; ((charCode = source.charCodeAt(Index + 1)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57)) {
                  // Illegal octal literal.
                  abort();
                }
                isSigned = false;
                // Parse the integer component.
                for (; Index &lt; length &amp;&amp; ((charCode = source.charCodeAt(Index)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57); Index++);
                // Floats cannot contain a leading decimal point; however, this
                // case is already accounted for by the parser.
                if (source.charCodeAt(Index) == 46) {
                  position = ++Index;
                  // Parse the decimal component.
                  for (; position &lt; length &amp;&amp; ((charCode = source.charCodeAt(position)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57); position++);
                  if (position == Index) {
                    // Illegal trailing decimal.
                    abort();
                  }
                  Index = position;
                }
                // Parse exponents. The `e` denoting the exponent is
                // case-insensitive.
                charCode = source.charCodeAt(Index);
                if (charCode == 101 || charCode == 69) {
                  charCode = source.charCodeAt(++Index);
                  // Skip past the sign following the exponent, if one is
                  // specified.
                  if (charCode == 43 || charCode == 45) {
                    Index++;
                  }
                  // Parse the exponential component.
                  for (position = Index; position &lt; length &amp;&amp; ((charCode = source.charCodeAt(position)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57); position++);
                  if (position == Index) {
                    // Illegal empty exponent.
                    abort();
                  }
                  Index = position;
                }
                // Coerce the parsed value to a JavaScript number.
                return +source.slice(begin, Index);
              }
              // A negative sign may only precede numbers.
              if (isSigned) {
                abort();
              }
              // `true`, `false`, and `null` literals.
              if (source.slice(Index, Index + 4) == &quot;true&quot;) {
                Index += 4;
                return true;
              } else if (source.slice(Index, Index + 5) == &quot;false&quot;) {
                Index += 5;
                return false;
              } else if (source.slice(Index, Index + 4) == &quot;null&quot;) {
                Index += 4;
                return null;
              }
              // Unrecognized token.
              abort();
          }
        }
        // Return the sentinel `$` character if the parser has reached the end
        // of the source string.
        return &quot;$&quot;;
      };

      // Internal: Parses a JSON `value` token.
      var get = function (value) {
        var results, hasMembers;
        if (value == &quot;$&quot;) {
          // Unexpected end of input.
          abort();
        }
        if (typeof value == &quot;string&quot;) {
          if ((charIndexBuggy ? value.charAt(0) : value[0]) == &quot;@&quot;) {
            // Remove the sentinel `@` character.
            return value.slice(1);
          }
          // Parse object and array literals.
          if (value == &quot;[&quot;) {
            // Parses a JSON array, returning a new JavaScript array.
            results = [];
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing square bracket marks the end of the array literal.
              if (value == &quot;]&quot;) {
                break;
              }
              // If the array literal contains elements, the current token
              // should be a comma separating the previous element from the
              // next.
              if (hasMembers) {
                if (value == &quot;,&quot;) {
                  value = lex();
                  if (value == &quot;]&quot;) {
                    // Unexpected trailing `,` in array literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each array element.
                  abort();
                }
              }
              // Elisions and leading commas are not permitted.
              if (value == &quot;,&quot;) {
                abort();
              }
              results.push(get(value));
            }
            return results;
          } else if (value == &quot;{&quot;) {
            // Parses a JSON object, returning a new JavaScript object.
            results = {};
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing curly brace marks the end of the object literal.
              if (value == &quot;}&quot;) {
                break;
              }
              // If the object literal contains members, the current token
              // should be a comma separator.
              if (hasMembers) {
                if (value == &quot;,&quot;) {
                  value = lex();
                  if (value == &quot;}&quot;) {
                    // Unexpected trailing `,` in object literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each object member.
                  abort();
                }
              }
              // Leading commas are not permitted, object property names must be
              // double-quoted strings, and a `:` must separate each property
              // name and value.
              if (value == &quot;,&quot; || typeof value != &quot;string&quot; || (charIndexBuggy ? value.charAt(0) : value[0]) != &quot;@&quot; || lex() != &quot;:&quot;) {
                abort();
              }
              results[value.slice(1)] = get(lex());
            }
            return results;
          }
          // Unexpected token encountered.
          abort();
        }
        return value;
      };

      // Internal: Updates a traversed object member.
      var update = function(source, property, callback) {
        var element = walk(source, property, callback);
        if (element === undef) {
          delete source[property];
        } else {
          source[property] = element;
        }
      };

      // Internal: Recursively traverses a parsed JSON object, invoking the
      // `callback` function for each value. This is an implementation of the
      // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
      var walk = function (source, property, callback) {
        var value = source[property], length;
        if (typeof value == &quot;object&quot; &amp;&amp; value) {
          // `forEach` can&apos;t be used to traverse an array in Opera &lt;= 8.54
          // because its `Object#hasOwnProperty` implementation returns `false`
          // for array indices (e.g., `![1, 2, 3].hasOwnProperty(&quot;0&quot;)`).
          if (getClass.call(value) == arrayClass) {
            for (length = value.length; length--;) {
              update(value, length, callback);
            }
          } else {
            forEach(value, function (property) {
              update(value, property, callback);
            });
          }
        }
        return callback.call(source, property, value);
      };

      // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
      JSON3.parse = function (source, callback) {
        var result, value;
        Index = 0;
        Source = &quot;&quot; + source;
        result = get(lex());
        // If a JSON string contains multiple tokens, it is invalid.
        if (lex() != &quot;$&quot;) {
          abort();
        }
        // Reset the parser state.
        Index = Source = null;
        return callback &amp;&amp; getClass.call(callback) == functionClass ? walk((value = {}, value[&quot;&quot;] = result, value), &quot;&quot;, callback) : result;
      };
    }
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}(this));

},{}],50:[function(_dereq_,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i &lt; list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}]},{},[1])
(1)
});</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler" enabled="false">
          <stringProp name="scriptLanguage">javascript</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">!function(e){if(&quot;object&quot;==typeof exports&amp;&amp;&quot;undefined&quot;!=typeof module)module.exports=e();else if(&quot;function&quot;==typeof define&amp;&amp;define.amd)define([],e);else{var f;&quot;undefined&quot;!=typeof window?f=window:&quot;undefined&quot;!=typeof global?f=global:&quot;undefined&quot;!=typeof self&amp;&amp;(f=self)}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==&quot;function&quot;&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);throw new Error(&quot;Cannot find module &apos;&quot;+o+&quot;&apos;&quot;)}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==&quot;function&quot;&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){

module.exports = _dereq_(&apos;./lib/&apos;);

},{&quot;./lib/&quot;:2}],2:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var url = _dereq_(&apos;./url&apos;);
var parser = _dereq_(&apos;socket.io-parser&apos;);
var Manager = _dereq_(&apos;./manager&apos;);
var debug = _dereq_(&apos;debug&apos;)(&apos;socket.io-client&apos;);

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io(&apos;http://localhost/a&apos;);`
 *   `io(&apos;http://localhost/b&apos;);`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup(uri, opts) {
  if (typeof uri == &apos;object&apos;) {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var io;

  if (opts.forceNew || opts[&apos;force new connection&apos;] || false === opts.multiplex) {
    debug(&apos;ignoring socket cache for %s&apos;, source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug(&apos;new io instance for %s&apos;, source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }

  return io.socket(parsed.path);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = _dereq_(&apos;./manager&apos;);
exports.Socket = _dereq_(&apos;./socket&apos;);

},{&quot;./manager&quot;:3,&quot;./socket&quot;:5,&quot;./url&quot;:6,&quot;debug&quot;:10,&quot;socket.io-parser&quot;:46}],3:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var url = _dereq_(&apos;./url&apos;);
var eio = _dereq_(&apos;engine.io-client&apos;);
var Socket = _dereq_(&apos;./socket&apos;);
var Emitter = _dereq_(&apos;component-emitter&apos;);
var parser = _dereq_(&apos;socket.io-parser&apos;);
var on = _dereq_(&apos;./on&apos;);
var bind = _dereq_(&apos;component-bind&apos;);
var object = _dereq_(&apos;object-component&apos;);
var debug = _dereq_(&apos;debug&apos;)(&apos;socket.io-client:manager&apos;);
var indexOf = _dereq_(&apos;indexof&apos;);
var Backoff = _dereq_(&apos;backo2&apos;);

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts){
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri &amp;&amp; (&apos;object&apos; == typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || &apos;/socket.io&apos;;
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = &apos;closed&apos;;
  this.uri = uri;
  this.connected = [];
  this.encoding = false;
  this.packetBuffer = [];
  this.encoder = new parser.Encoder();
  this.decoder = new parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function() {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function(){
  for (var nsp in this.nsps) {
    this.nsps[nsp].id = this.engine.id;
  }
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function(v){
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function(v){
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function(v){
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff &amp;&amp; this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function(v){
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff &amp;&amp; this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function(v){
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff &amp;&amp; this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function(v){
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function() {
  // Only try to reconnect if it&apos;s the first time we&apos;re connecting
  if (!this.reconnecting &amp;&amp; this._reconnection &amp;&amp; this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};


/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function(fn){
  debug(&apos;readyState %s&apos;, this.readyState);
  if (~this.readyState.indexOf(&apos;open&apos;)) return this;

  debug(&apos;opening %s&apos;, this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = &apos;opening&apos;;
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, &apos;open&apos;, function() {
    self.onopen();
    fn &amp;&amp; fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, &apos;error&apos;, function(data){
    debug(&apos;connect_error&apos;);
    self.cleanup();
    self.readyState = &apos;closed&apos;;
    self.emitAll(&apos;connect_error&apos;, data);
    if (fn) {
      var err = new Error(&apos;Connection error&apos;);
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug(&apos;connect attempt will timeout after %d&apos;, timeout);

    // set timer
    var timer = setTimeout(function(){
      debug(&apos;connect attempt timed out after %d&apos;, timeout);
      openSub.destroy();
      socket.close();
      socket.emit(&apos;error&apos;, &apos;timeout&apos;);
      self.emitAll(&apos;connect_timeout&apos;, timeout);
    }, timeout);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function(){
  debug(&apos;open&apos;);

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = &apos;open&apos;;
  this.emit(&apos;open&apos;);

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, &apos;data&apos;, bind(this, &apos;ondata&apos;)));
  this.subs.push(on(this.decoder, &apos;decoded&apos;, bind(this, &apos;ondecoded&apos;)));
  this.subs.push(on(socket, &apos;error&apos;, bind(this, &apos;onerror&apos;)));
  this.subs.push(on(socket, &apos;close&apos;, bind(this, &apos;onclose&apos;)));
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function(data){
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function(packet) {
  this.emit(&apos;packet&apos;, packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function(err){
  debug(&apos;error&apos;, err);
  this.emitAll(&apos;error&apos;, err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function(nsp){
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on(&apos;connect&apos;, function(){
      socket.id = self.engine.id;
      if (!~indexOf(self.connected, socket)) {
        self.connected.push(socket);
      }
    });
  }
  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function(socket){
  var index = indexOf(this.connected, socket);
  if (~index) this.connected.splice(index, 1);
  if (this.connected.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function(packet){
  debug(&apos;writing packet %j&apos;, packet);
  var self = this;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function(encodedPackets) {
      for (var i = 0; i &lt; encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i]);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function() {
  if (this.packetBuffer.length &gt; 0 &amp;&amp; !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function(){
  var sub;
  while (sub = this.subs.shift()) sub.destroy();

  this.packetBuffer = [];
  this.encoding = false;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function(){
  this.skipReconnect = true;
  this.backoff.reset();
  this.readyState = &apos;closed&apos;;
  this.engine &amp;&amp; this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function(reason){
  debug(&apos;close&apos;);
  this.cleanup();
  this.backoff.reset();
  this.readyState = &apos;closed&apos;;
  this.emit(&apos;close&apos;, reason);
  if (this._reconnection &amp;&amp; !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function(){
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts &gt;= this._reconnectionAttempts) {
    debug(&apos;reconnect failed&apos;);
    this.backoff.reset();
    this.emitAll(&apos;reconnect_failed&apos;);
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug(&apos;will wait %dms before reconnect attempt&apos;, delay);

    this.reconnecting = true;
    var timer = setTimeout(function(){
      if (self.skipReconnect) return;

      debug(&apos;attempting reconnect&apos;);
      self.emitAll(&apos;reconnect_attempt&apos;, self.backoff.attempts);
      self.emitAll(&apos;reconnecting&apos;, self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function(err){
        if (err) {
          debug(&apos;reconnect attempt error&apos;);
          self.reconnecting = false;
          self.reconnect();
          self.emitAll(&apos;reconnect_error&apos;, err.data);
        } else {
          debug(&apos;reconnect success&apos;);
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function(){
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll(&apos;reconnect&apos;, attempt);
};

},{&quot;./on&quot;:4,&quot;./socket&quot;:5,&quot;./url&quot;:6,&quot;backo2&quot;:7,&quot;component-bind&quot;:8,&quot;component-emitter&quot;:9,&quot;debug&quot;:10,&quot;engine.io-client&quot;:11,&quot;indexof&quot;:42,&quot;object-component&quot;:43,&quot;socket.io-parser&quot;:46}],4:[function(_dereq_,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function(){
      obj.removeListener(ev, fn);
    }
  };
}

},{}],5:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var parser = _dereq_(&apos;socket.io-parser&apos;);
var Emitter = _dereq_(&apos;component-emitter&apos;);
var toArray = _dereq_(&apos;to-array&apos;);
var on = _dereq_(&apos;./on&apos;);
var bind = _dereq_(&apos;component-bind&apos;);
var debug = _dereq_(&apos;debug&apos;)(&apos;socket.io-client:socket&apos;);
var hasBin = _dereq_(&apos;has-binary&apos;);

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can&apos;t be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket(io, nsp){
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  if (this.io.autoConnect) this.open();
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function() {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, &apos;open&apos;, bind(this, &apos;onopen&apos;)),
    on(io, &apos;packet&apos;, bind(this, &apos;onpacket&apos;)),
    on(io, &apos;close&apos;, bind(this, &apos;onclose&apos;))
  ];
};

/**
 * &quot;Opens&quot; the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function(){
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if (&apos;open&apos; == this.io.readyState) this.onopen();
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function(){
  var args = toArray(arguments);
  args.unshift(&apos;message&apos;);
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it&apos;s emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function(ev){
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var parserType = parser.EVENT; // default
  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
  var packet = { type: parserType, data: args };

  // event ack callback
  if (&apos;function&apos; == typeof args[args.length - 1]) {
    debug(&apos;emitting packet with ack id %d&apos;, this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function(packet){
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function(){
  debug(&apos;transport is open - connecting&apos;);

  // write connect packet if necessary
  if (&apos;/&apos; != this.nsp) {
    this.packet({ type: parser.CONNECT });
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function(reason){
  debug(&apos;close (%s)&apos;, reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit(&apos;disconnect&apos;, reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function(packet){
  if (packet.nsp != this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit(&apos;error&apos;, packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function(packet){
  var args = packet.data || [];
  debug(&apos;emitting event %j&apos;, args);

  if (null != packet.id) {
    debug(&apos;attaching ack callback to event&apos;);
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function(id){
  var self = this;
  var sent = false;
  return function(){
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug(&apos;sending ack %j&apos;, args);

    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
    self.packet({
      type: type,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function(packet){
  debug(&apos;calling ack %s with %j&apos;, packet.id, packet.data);
  var fn = this.acks[packet.id];
  fn.apply(this, packet.data);
  delete this.acks[packet.id];
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function(){
  this.connected = true;
  this.disconnected = false;
  this.emit(&apos;connect&apos;);
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function(){
  var i;
  for (i = 0; i &lt; this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i &lt; this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function(){
  debug(&apos;server disconnect (%s)&apos;, this.nsp);
  this.destroy();
  this.onclose(&apos;io server disconnect&apos;);
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don&apos;t get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function(){
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i &lt; this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function(){
  if (this.connected) {
    debug(&apos;performing disconnect (%s)&apos;, this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose(&apos;io client disconnect&apos;);
  }
  return this;
};

},{&quot;./on&quot;:4,&quot;component-bind&quot;:8,&quot;component-emitter&quot;:9,&quot;debug&quot;:10,&quot;has-binary&quot;:38,&quot;socket.io-parser&quot;:46,&quot;to-array&quot;:50}],6:[function(_dereq_,module,exports){
(function (global){

/**
 * Module dependencies.
 */

var parseuri = _dereq_(&apos;parseuri&apos;);
var debug = _dereq_(&apos;debug&apos;)(&apos;socket.io-client:url&apos;);

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc){
  var obj = uri;

  // default to window.location
  var loc = loc || global.location;
  if (null == uri) uri = loc.protocol + &apos;//&apos; + loc.host;

  // relative path support
  if (&apos;string&apos; == typeof uri) {
    if (&apos;/&apos; == uri.charAt(0)) {
      if (&apos;/&apos; == uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.hostname + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug(&apos;protocol-less url %s&apos;, uri);
      if (&apos;undefined&apos; != typeof loc) {
        uri = loc.protocol + &apos;//&apos; + uri;
      } else {
        uri = &apos;https://&apos; + uri;
      }
    }

    // parse
    debug(&apos;parse %s&apos;, uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = &apos;80&apos;;
    }
    else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = &apos;443&apos;;
    }
  }

  obj.path = obj.path || &apos;/&apos;;

  // define unique id
  obj.id = obj.protocol + &apos;://&apos; + obj.host + &apos;:&apos; + obj.port;
  // define href
  obj.href = obj.protocol + &apos;://&apos; + obj.host + (loc &amp;&amp; loc.port == obj.port ? &apos;&apos; : (&apos;:&apos; + obj.port));

  return obj;
}

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;debug&quot;:10,&quot;parseuri&quot;:44}],7:[function(_dereq_,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter &gt; 0 &amp;&amp; opts.jitter &lt;= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) &amp; 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],8:[function(_dereq_,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if (&apos;string&apos; == typeof fn) fn = obj[fn];
  if (&apos;function&apos; != typeof fn) throw new Error(&apos;bind() requires a function&apos;);
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],9:[function(_dereq_,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i &lt; callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i &lt; len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],10:[function(_dereq_,module,exports){

/**
 * Expose `debug()` as the module.
 */

module.exports = debug;

/**
 * Create a debugger with the given `name`.
 *
 * @param {String} name
 * @return {Type}
 * @api public
 */

function debug(name) {
  if (!debug.enabled(name)) return function(){};

  return function(fmt){
    fmt = coerce(fmt);

    var curr = new Date;
    var ms = curr - (debug[name] || curr);
    debug[name] = curr;

    fmt = name
      + &apos; &apos;
      + fmt
      + &apos; +&apos; + debug.humanize(ms);

    // This hackery is required for IE8
    // where `console.log` doesn&apos;t have &apos;apply&apos;
    window.console
      &amp;&amp; console.log
      &amp;&amp; Function.prototype.apply.call(console.log, console, arguments);
  }
}

/**
 * The currently active debug mode names.
 */

debug.names = [];
debug.skips = [];

/**
 * Enables a debug mode by name. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} name
 * @api public
 */

debug.enable = function(name) {
  try {
    localStorage.debug = name;
  } catch(e){}

  var split = (name || &apos;&apos;).split(/[\s,]+/)
    , len = split.length;

  for (var i = 0; i &lt; len; i++) {
    name = split[i].replace(&apos;*&apos;, &apos;.*?&apos;);
    if (name[0] === &apos;-&apos;) {
      debug.skips.push(new RegExp(&apos;^&apos; + name.substr(1) + &apos;$&apos;));
    }
    else {
      debug.names.push(new RegExp(&apos;^&apos; + name + &apos;$&apos;));
    }
  }
};

/**
 * Disable debug output.
 *
 * @api public
 */

debug.disable = function(){
  debug.enable(&apos;&apos;);
};

/**
 * Humanize the given `ms`.
 *
 * @param {Number} m
 * @return {String}
 * @api private
 */

debug.humanize = function(ms) {
  var sec = 1000
    , min = 60 * 1000
    , hour = 60 * min;

  if (ms &gt;= hour) return (ms / hour).toFixed(1) + &apos;h&apos;;
  if (ms &gt;= min) return (ms / min).toFixed(1) + &apos;m&apos;;
  if (ms &gt;= sec) return (ms / sec | 0) + &apos;s&apos;;
  return ms + &apos;ms&apos;;
};

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

debug.enabled = function(name) {
  for (var i = 0, len = debug.skips.length; i &lt; len; i++) {
    if (debug.skips[i].test(name)) {
      return false;
    }
  }
  for (var i = 0, len = debug.names.length; i &lt; len; i++) {
    if (debug.names[i].test(name)) {
      return true;
    }
  }
  return false;
};

/**
 * Coerce `val`.
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

// persist

try {
  if (window.localStorage) debug.enable(localStorage.debug);
} catch(e){}

},{}],11:[function(_dereq_,module,exports){

module.exports =  _dereq_(&apos;./lib/&apos;);

},{&quot;./lib/&quot;:12}],12:[function(_dereq_,module,exports){

module.exports = _dereq_(&apos;./socket&apos;);

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = _dereq_(&apos;engine.io-parser&apos;);

},{&quot;./socket&quot;:13,&quot;engine.io-parser&quot;:25}],13:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var transports = _dereq_(&apos;./transports&apos;);
var Emitter = _dereq_(&apos;component-emitter&apos;);
var debug = _dereq_(&apos;debug&apos;)(&apos;engine.io-client:socket&apos;);
var index = _dereq_(&apos;indexof&apos;);
var parser = _dereq_(&apos;engine.io-parser&apos;);
var parseuri = _dereq_(&apos;parseuri&apos;);
var parsejson = _dereq_(&apos;parsejson&apos;);
var parseqs = _dereq_(&apos;parseqs&apos;);

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Noop function.
 *
 * @api private
 */

function noop(){}

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts){
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri &amp;&amp; &apos;object&apos; == typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.host = uri.host;
    opts.secure = uri.protocol == &apos;https&apos; || uri.protocol == &apos;wss&apos;;
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  }

  this.secure = null != opts.secure ? opts.secure :
    (global.location &amp;&amp; &apos;https:&apos; == location.protocol);

  if (opts.host) {
    var pieces = opts.host.split(&apos;:&apos;);
    opts.hostname = pieces.shift();
    if (pieces.length) {
      opts.port = pieces.pop();
    } else if (!opts.port) {
      // if no port is specified manually, use the protocol default
      opts.port = this.secure ? &apos;443&apos; : &apos;80&apos;;
    }
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : &apos;localhost&apos;);
  this.port = opts.port || (global.location &amp;&amp; location.port ?
       location.port :
       (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if (&apos;string&apos; == typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || &apos;/engine.io&apos;).replace(/\/$/, &apos;&apos;) + &apos;/&apos;;
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || &apos;t&apos;;
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || [&apos;polling&apos;, &apos;websocket&apos;];
  this.readyState = &apos;&apos;;
  this.writeBuffer = [];
  this.callbackBuffer = [];
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized || null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = _dereq_(&apos;./transport&apos;);
Socket.transports = _dereq_(&apos;./transports&apos;);
Socket.parser = _dereq_(&apos;engine.io-parser&apos;);

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug(&apos;creating transport &quot;%s&quot;&apos;, name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    agent: this.agent,
    hostname: this.hostname,
    port: this.port,
    secure: this.secure,
    path: this.path,
    query: query,
    forceJSONP: this.forceJSONP,
    jsonp: this.jsonp,
    forceBase64: this.forceBase64,
    enablesXDR: this.enablesXDR,
    timestampRequests: this.timestampRequests,
    timestampParam: this.timestampParam,
    policyPort: this.policyPort,
    socket: this,
    pfx: this.pfx,
    key: this.key,
    passphrase: this.passphrase,
    cert: this.cert,
    ca: this.ca,
    ciphers: this.ciphers,
    rejectUnauthorized: this.rejectUnauthorized
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade &amp;&amp; Socket.priorWebsocketSuccess &amp;&amp; this.transports.indexOf(&apos;websocket&apos;) != -1) {
    transport = &apos;websocket&apos;;
  } else if (0 == this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function() {
      self.emit(&apos;error&apos;, &apos;No transports available&apos;);
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = &apos;opening&apos;;

  // Retry with the next transport if the transport is disabled (jsonp: false)
  var transport;
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function(transport){
  debug(&apos;setting transport %s&apos;, transport.name);
  var self = this;

  if (this.transport) {
    debug(&apos;clearing existing transport %s&apos;, this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on(&apos;drain&apos;, function(){
    self.onDrain();
  })
  .on(&apos;packet&apos;, function(packet){
    self.onPacket(packet);
  })
  .on(&apos;error&apos;, function(e){
    self.onError(e);
  })
  .on(&apos;close&apos;, function(){
    self.onClose(&apos;transport close&apos;);
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug(&apos;probing transport &quot;%s&quot;&apos;, name);
  var transport = this.createTransport(name, { probe: 1 })
    , failed = false
    , self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen(){
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary &amp;&amp; self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug(&apos;probe transport &quot;%s&quot; opened&apos;, name);
    transport.send([{ type: &apos;ping&apos;, data: &apos;probe&apos; }]);
    transport.once(&apos;packet&apos;, function (msg) {
      if (failed) return;
      if (&apos;pong&apos; == msg.type &amp;&amp; &apos;probe&apos; == msg.data) {
        debug(&apos;probe transport &quot;%s&quot; pong&apos;, name);
        self.upgrading = true;
        self.emit(&apos;upgrading&apos;, transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = &apos;websocket&apos; == transport.name;

        debug(&apos;pausing current transport &quot;%s&quot;&apos;, self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if (&apos;closed&apos; == self.readyState) return;
          debug(&apos;changing transport and sending upgrade packet&apos;);

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: &apos;upgrade&apos; }]);
          self.emit(&apos;upgrade&apos;, transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug(&apos;probe transport &quot;%s&quot; failed&apos;, name);
        var err = new Error(&apos;probe error&apos;);
        err.transport = transport.name;
        self.emit(&apos;upgradeError&apos;, err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  //Handle any error that happens while probing
  function onerror(err) {
    var error = new Error(&apos;probe error: &apos; + err);
    error.transport = transport.name;

    freezeTransport();

    debug(&apos;probe transport &quot;%s&quot; failed because of error: %s&apos;, name, err);

    self.emit(&apos;upgradeError&apos;, error);
  }

  function onTransportClose(){
    onerror(&quot;transport closed&quot;);
  }

  //When the socket is closed while we&apos;re probing
  function onclose(){
    onerror(&quot;socket closed&quot;);
  }

  //When the socket is upgraded while we&apos;re probing
  function onupgrade(to){
    if (transport &amp;&amp; to.name != transport.name) {
      debug(&apos;&quot;%s&quot; works - aborting &quot;%s&quot;&apos;, to.name, transport.name);
      freezeTransport();
    }
  }

  //Remove all listeners on the transport and on self
  function cleanup(){
    transport.removeListener(&apos;open&apos;, onTransportOpen);
    transport.removeListener(&apos;error&apos;, onerror);
    transport.removeListener(&apos;close&apos;, onTransportClose);
    self.removeListener(&apos;close&apos;, onclose);
    self.removeListener(&apos;upgrading&apos;, onupgrade);
  }

  transport.once(&apos;open&apos;, onTransportOpen);
  transport.once(&apos;error&apos;, onerror);
  transport.once(&apos;close&apos;, onTransportClose);

  this.once(&apos;close&apos;, onclose);
  this.once(&apos;upgrading&apos;, onupgrade);

  transport.open();

};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug(&apos;socket open&apos;);
  this.readyState = &apos;open&apos;;
  Socket.priorWebsocketSuccess = &apos;websocket&apos; == this.transport.name;
  this.emit(&apos;open&apos;);
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if (&apos;open&apos; == this.readyState &amp;&amp; this.upgrade &amp;&amp; this.transport.pause) {
    debug(&apos;starting upgrade probes&apos;);
    for (var i = 0, l = this.upgrades.length; i &lt; l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if (&apos;opening&apos; == this.readyState || &apos;open&apos; == this.readyState) {
    debug(&apos;socket receive: type &quot;%s&quot;, data &quot;%s&quot;&apos;, packet.type, packet.data);

    this.emit(&apos;packet&apos;, packet);

    // Socket is live - any packet counts
    this.emit(&apos;heartbeat&apos;);

    switch (packet.type) {
      case &apos;open&apos;:
        this.onHandshake(parsejson(packet.data));
        break;

      case &apos;pong&apos;:
        this.setPing();
        break;

      case &apos;error&apos;:
        var err = new Error(&apos;server error&apos;);
        err.code = packet.data;
        this.emit(&apos;error&apos;, err);
        break;

      case &apos;message&apos;:
        this.emit(&apos;data&apos;, packet.data);
        this.emit(&apos;message&apos;, packet.data);
        break;
    }
  } else {
    debug(&apos;packet received with socket readyState &quot;%s&quot;&apos;, this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit(&apos;handshake&apos;, data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if  (&apos;closed&apos; == this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener(&apos;heartbeat&apos;, this.onHeartbeat);
  this.on(&apos;heartbeat&apos;, this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if (&apos;closed&apos; == self.readyState) return;
    self.onClose(&apos;ping timeout&apos;);
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug(&apos;writing ping packet - expecting pong within %sms&apos;, self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api public
*/

Socket.prototype.ping = function () {
  this.sendPacket(&apos;ping&apos;);
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function() {
  for (var i = 0; i &lt; this.prevBufferLen; i++) {
    if (this.callbackBuffer[i]) {
      this.callbackBuffer[i]();
    }
  }

  this.writeBuffer.splice(0, this.prevBufferLen);
  this.callbackBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (this.writeBuffer.length == 0) {
    this.emit(&apos;drain&apos;);
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if (&apos;closed&apos; != this.readyState &amp;&amp; this.transport.writable &amp;&amp;
    !this.upgrading &amp;&amp; this.writeBuffer.length) {
    debug(&apos;flushing %d packets in socket&apos;, this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit(&apos;flush&apos;);
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, fn) {
  this.sendPacket(&apos;message&apos;, msg, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, fn) {
  if (&apos;closing&apos; == this.readyState || &apos;closed&apos; == this.readyState) {
    return;
  }

  var packet = { type: type, data: data };
  this.emit(&apos;packetCreate&apos;, packet);
  this.writeBuffer.push(packet);
  this.callbackBuffer.push(fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if (&apos;opening&apos; == this.readyState || &apos;open&apos; == this.readyState) {
    this.readyState = &apos;closing&apos;;

    var self = this;

    function close() {
      self.onClose(&apos;forced close&apos;);
      debug(&apos;socket closing - telling transport to close&apos;);
      self.transport.close();
    }

    function cleanupAndClose() {
      self.removeListener(&apos;upgrade&apos;, cleanupAndClose);
      self.removeListener(&apos;upgradeError&apos;, cleanupAndClose);
      close();
    }

    function waitForUpgrade() {
      // wait for upgrade to finish since we can&apos;t send packets while pausing a transport
      self.once(&apos;upgrade&apos;, cleanupAndClose);
      self.once(&apos;upgradeError&apos;, cleanupAndClose);
    }

    if (this.writeBuffer.length) {
      this.once(&apos;drain&apos;, function() {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug(&apos;socket error %j&apos;, err);
  Socket.priorWebsocketSuccess = false;
  this.emit(&apos;error&apos;, err);
  this.onClose(&apos;transport error&apos;, err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if (&apos;opening&apos; == this.readyState || &apos;open&apos; == this.readyState || &apos;closing&apos; == this.readyState) {
    debug(&apos;socket close with reason: &quot;%s&quot;&apos;, reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // clean buffers in next tick, so developers can still
    // grab the buffers on `close` event
    setTimeout(function() {
      self.writeBuffer = [];
      self.callbackBuffer = [];
      self.prevBufferLen = 0;
    }, 0);

    // stop event from firing again for transport
    this.transport.removeAllListeners(&apos;close&apos;);

    // ensure transport won&apos;t stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = &apos;closed&apos;;

    // clear session id
    this.id = null;

    // emit close event
    this.emit(&apos;close&apos;, reason, desc);
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i&lt;j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;./transport&quot;:14,&quot;./transports&quot;:15,&quot;component-emitter&quot;:9,&quot;debug&quot;:22,&quot;engine.io-parser&quot;:25,&quot;indexof&quot;:42,&quot;parsejson&quot;:34,&quot;parseqs&quot;:35,&quot;parseuri&quot;:36}],14:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var parser = _dereq_(&apos;engine.io-parser&apos;);
var Emitter = _dereq_(&apos;component-emitter&apos;);

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = &apos;&apos;;
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * A counter used to prevent collisions in the timestamps used
 * for cache busting.
 */

Transport.timestamps = 0;

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = &apos;TransportError&apos;;
  err.description = desc;
  this.emit(&apos;error&apos;, err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if (&apos;closed&apos; == this.readyState || &apos;&apos; == this.readyState) {
    this.readyState = &apos;opening&apos;;
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if (&apos;opening&apos; == this.readyState || &apos;open&apos; == this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function(packets){
  if (&apos;open&apos; == this.readyState) {
    this.write(packets);
  } else {
    throw new Error(&apos;Transport not open&apos;);
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = &apos;open&apos;;
  this.writable = true;
  this.emit(&apos;open&apos;);
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function(data){
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit(&apos;packet&apos;, packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = &apos;closed&apos;;
  this.emit(&apos;close&apos;);
};

},{&quot;component-emitter&quot;:9,&quot;engine.io-parser&quot;:25}],15:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies
 */

var XMLHttpRequest = _dereq_(&apos;xmlhttprequest&apos;);
var XHR = _dereq_(&apos;./polling-xhr&apos;);
var JSONP = _dereq_(&apos;./polling-jsonp&apos;);
var websocket = _dereq_(&apos;./websocket&apos;);

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts){
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = &apos;https:&apos; == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname != location.hostname || port != opts.port;
    xs = opts.secure != isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if (&apos;open&apos; in xhr &amp;&amp; !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error(&apos;JSONP disabled&apos;);
    return new JSONP(opts);
  }
}

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;./polling-jsonp&quot;:16,&quot;./polling-xhr&quot;:17,&quot;./websocket&quot;:19,&quot;xmlhttprequest&quot;:20}],16:[function(_dereq_,module,exports){
(function (global){

/**
 * Module requirements.
 */

var Polling = _dereq_(&apos;./polling&apos;);
var inherit = _dereq_(&apos;component-inherit&apos;);

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Callbacks count.
 */

var index = 0;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document &amp;&amp; global.addEventListener) {
    global.addEventListener(&apos;beforeunload&apos;, function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement(&apos;script&apos;);

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function(e){
    self.onError(&apos;jsonp poll error&apos;,e);
  };

  var insertAt = document.getElementsByTagName(&apos;script&apos;)[0];
  insertAt.parentNode.insertBefore(script, insertAt);
  this.script = script;

  var isUAgecko = &apos;undefined&apos; != typeof navigator &amp;&amp; /gecko/i.test(navigator.userAgent);
  
  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement(&apos;iframe&apos;);
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement(&apos;form&apos;);
    var area = document.createElement(&apos;textarea&apos;);
    var id = this.iframeId = &apos;eio_iframe_&apos; + this.index;
    var iframe;

    form.className = &apos;socketio&apos;;
    form.style.position = &apos;absolute&apos;;
    form.style.top = &apos;-1000px&apos;;
    form.style.left = &apos;-1000px&apos;;
    form.target = id;
    form.method = &apos;POST&apos;;
    form.setAttribute(&apos;accept-charset&apos;, &apos;utf-8&apos;);
    area.name = &apos;d&apos;;
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError(&apos;jsonp polling iframe removal error&apos;, e);
      }
    }

    try {
      // ie6 dynamic iframes with target=&quot;&quot; support (thanks Chris Lambacher)
      var html = &apos;&lt;iframe src=&quot;javascript:0&quot; name=&quot;&apos;+ self.iframeId +&apos;&quot;&gt;&apos;;
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement(&apos;iframe&apos;);
      iframe.name = self.iframeId;
      iframe.src = &apos;javascript:0&apos;;
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, &apos;\\\n&apos;);
  this.area.value = data.replace(rNewline, &apos;\\n&apos;);

  try {
    this.form.submit();
  } catch(e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function(){
      if (self.iframe.readyState == &apos;complete&apos;) {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;./polling&quot;:18,&quot;component-inherit&quot;:21}],17:[function(_dereq_,module,exports){
(function (global){
/**
 * Module requirements.
 */

var XMLHttpRequest = _dereq_(&apos;xmlhttprequest&apos;);
var Polling = _dereq_(&apos;./polling&apos;);
var Emitter = _dereq_(&apos;component-emitter&apos;);
var inherit = _dereq_(&apos;component-inherit&apos;);
var debug = _dereq_(&apos;debug&apos;)(&apos;engine.io-client:polling-xhr&apos;);

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty(){}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR(opts){
  Polling.call(this, opts);

  if (global.location) {
    var isSSL = &apos;https:&apos; == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname != global.location.hostname ||
      port != opts.port;
    this.xs = opts.secure != isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function(opts){
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function(data, fn){
  var isBinary = typeof data !== &apos;string&apos; &amp;&amp; data !== undefined;
  var req = this.request({ method: &apos;POST&apos;, data: data, isBinary: isBinary });
  var self = this;
  req.on(&apos;success&apos;, fn);
  req.on(&apos;error&apos;, function(err){
    self.onError(&apos;xhr post error&apos;, err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function(){
  debug(&apos;xhr poll&apos;);
  var req = this.request();
  var self = this;
  req.on(&apos;data&apos;, function(data){
    self.onData(data);
  });
  req.on(&apos;error&apos;, function(err){
    self.onError(&apos;xhr poll error&apos;, err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request(opts){
  this.method = opts.method || &apos;GET&apos;;
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined != opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function(){
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug(&apos;xhr open %s: %s&apos;, this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    if (this.supportsBinary) {
      // This has to be done after open because Firefox is stupid
      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
      xhr.responseType = &apos;arraybuffer&apos;;
    }

    if (&apos;POST&apos; == this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader(&apos;Content-type&apos;, &apos;application/octet-stream&apos;);
        } else {
          xhr.setRequestHeader(&apos;Content-type&apos;, &apos;text/plain;charset=UTF-8&apos;);
        }
      } catch (e) {}
    }

    // ie6 check
    if (&apos;withCredentials&apos; in xhr) {
      xhr.withCredentials = true;
    }

    if (this.hasXDR()) {
      xhr.onload = function(){
        self.onLoad();
      };
      xhr.onerror = function(){
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function(){
        if (4 != xhr.readyState) return;
        if (200 == xhr.status || 1223 == xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that&apos;s user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function(){
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug(&apos;xhr data %s&apos;, this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the &apos;error&apos; event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function() {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function(){
  this.emit(&apos;success&apos;);
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function(data){
  this.emit(&apos;data&apos;, data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function(err){
  this.emit(&apos;error&apos;, err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function(fromError){
  if (&apos;undefined&apos; == typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch(e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function(){
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader(&apos;Content-Type&apos;).split(&apos;;&apos;)[0];
    } catch (e) {}
    if (contentType === &apos;application/octet-stream&apos;) {
      data = this.xhr.response;
    } else {
      if (!this.supportsBinary) {
        data = this.xhr.responseText;
      } else {
        data = &apos;ok&apos;;
      }
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function(){
  return &apos;undefined&apos; !== typeof global.XDomainRequest &amp;&amp; !this.xs &amp;&amp; this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function(){
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

if (global.document) {
  Request.requestsCount = 0;
  Request.requests = {};
  if (global.attachEvent) {
    global.attachEvent(&apos;onunload&apos;, unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener(&apos;beforeunload&apos;, unloadHandler, false);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;./polling&quot;:18,&quot;component-emitter&quot;:9,&quot;component-inherit&quot;:21,&quot;debug&quot;:22,&quot;xmlhttprequest&quot;:20}],18:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var Transport = _dereq_(&apos;../transport&apos;);
var parseqs = _dereq_(&apos;parseqs&apos;);
var parser = _dereq_(&apos;engine.io-parser&apos;);
var inherit = _dereq_(&apos;component-inherit&apos;);
var debug = _dereq_(&apos;debug&apos;)(&apos;engine.io-client:polling&apos;);

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function() {
  var XMLHttpRequest = _dereq_(&apos;xmlhttprequest&apos;);
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling(opts){
  var forceBase64 = (opts &amp;&amp; opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = &apos;polling&apos;;

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function(){
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function(onPause){
  var pending = 0;
  var self = this;

  this.readyState = &apos;pausing&apos;;

  function pause(){
    debug(&apos;paused&apos;);
    self.readyState = &apos;paused&apos;;
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug(&apos;we are currently polling - waiting to pause&apos;);
      total++;
      this.once(&apos;pollComplete&apos;, function(){
        debug(&apos;pre-pause polling complete&apos;);
        --total || pause();
      });
    }

    if (!this.writable) {
      debug(&apos;we are currently writing - waiting to pause&apos;);
      total++;
      this.once(&apos;drain&apos;, function(){
        debug(&apos;pre-pause writing complete&apos;);
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function(){
  debug(&apos;polling&apos;);
  this.polling = true;
  this.doPoll();
  this.emit(&apos;poll&apos;);
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function(data){
  var self = this;
  debug(&apos;polling got data %s&apos;, data);
  var callback = function(packet, index, total) {
    // if its the first message we consider the transport open
    if (&apos;opening&apos; == self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if (&apos;close&apos; == packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if (&apos;closed&apos; != this.readyState) {
    // if we got data we&apos;re not polling
    this.polling = false;
    this.emit(&apos;pollComplete&apos;);

    if (&apos;open&apos; == this.readyState) {
      this.poll();
    } else {
      debug(&apos;ignoring poll - transport state &quot;%s&quot;&apos;, this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function(){
  var self = this;

  function close(){
    debug(&apos;writing close packet&apos;);
    self.write([{ type: &apos;close&apos; }]);
  }

  if (&apos;open&apos; == this.readyState) {
    debug(&apos;transport open - closing&apos;);
    close();
  } else {
    // in case we&apos;re trying to close while
    // handshaking is in progress (GH-164)
    debug(&apos;transport not open - deferring close&apos;);
    this.once(&apos;open&apos;, close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  var callbackfn = function() {
    self.writable = true;
    self.emit(&apos;drain&apos;);
  };

  var self = this;
  parser.encodePayload(packets, this.supportsBinary, function(data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? &apos;https&apos; : &apos;http&apos;;
  var port = &apos;&apos;;

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = +new Date + &apos;-&apos; + Transport.timestamps++;
  }

  if (!this.supportsBinary &amp;&amp; !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port &amp;&amp; ((&apos;https&apos; == schema &amp;&amp; this.port != 443) ||
     (&apos;http&apos; == schema &amp;&amp; this.port != 80))) {
    port = &apos;:&apos; + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = &apos;?&apos; + query;
  }

  return schema + &apos;://&apos; + this.hostname + port + this.path + query;
};

},{&quot;../transport&quot;:14,&quot;component-inherit&quot;:21,&quot;debug&quot;:22,&quot;engine.io-parser&quot;:25,&quot;parseqs&quot;:35,&quot;xmlhttprequest&quot;:20}],19:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var Transport = _dereq_(&apos;../transport&apos;);
var parser = _dereq_(&apos;engine.io-parser&apos;);
var parseqs = _dereq_(&apos;parseqs&apos;);
var inherit = _dereq_(&apos;component-inherit&apos;);
var debug = _dereq_(&apos;debug&apos;)(&apos;engine.io-client:websocket&apos;);

/**
 * `ws` exposes a WebSocket-compatible interface in
 * Node, or the `WebSocket` or `MozWebSocket` globals
 * in the browser.
 */

var WebSocket = _dereq_(&apos;ws&apos;);

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts){
  var forceBase64 = (opts &amp;&amp; opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = &apos;websocket&apos;;

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function(){
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var self = this;
  var uri = this.uri();
  var protocols = void(0);
  var opts = { agent: this.agent };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  this.ws = new WebSocket(uri, protocols, opts);

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  this.ws.binaryType = &apos;arraybuffer&apos;;
  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function(){
  var self = this;

  this.ws.onopen = function(){
    self.onOpen();
  };
  this.ws.onclose = function(){
    self.onClose();
  };
  this.ws.onmessage = function(ev){
    self.onData(ev.data);
  };
  this.ws.onerror = function(e){
    self.onError(&apos;websocket error&apos;, e);
  };
};

/**
 * Override `onData` to use a timer on iOS.
 * See: https://gist.github.com/mloughran/2052006
 *
 * @api private
 */

if (&apos;undefined&apos; != typeof navigator
  &amp;&amp; /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
  WS.prototype.onData = function(data){
    var self = this;
    setTimeout(function(){
      Transport.prototype.onData.call(self, data);
    }, 0);
  };
}

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  for (var i = 0, l = packets.length; i &lt; l; i++) {
    parser.encodePacket(packets[i], this.supportsBinary, function(data) {
      //Sometimes the websocket has already been closed but the browser didn&apos;t
      //have a chance of informing us about it yet, in that case send will
      //throw an error
      try {
        self.ws.send(data);
      } catch (e){
        debug(&apos;websocket closed before onclose event&apos;);
      }
    });
  }

  function ondrain() {
    self.writable = true;
    self.emit(&apos;drain&apos;);
  }
  // fake drain
  // defer to next tick to allow Socket to clear writeBuffer
  setTimeout(ondrain, 0);
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function(){
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function(){
  if (typeof this.ws !== &apos;undefined&apos;) {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? &apos;wss&apos; : &apos;ws&apos;;
  var port = &apos;&apos;;

  // avoid port if default for schema
  if (this.port &amp;&amp; ((&apos;wss&apos; == schema &amp;&amp; this.port != 443)
    || (&apos;ws&apos; == schema &amp;&amp; this.port != 80))) {
    port = &apos;:&apos; + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = +new Date;
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = &apos;?&apos; + query;
  }

  return schema + &apos;://&apos; + this.hostname + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function(){
  return !!WebSocket &amp;&amp; !(&apos;__initialize&apos; in WebSocket &amp;&amp; this.name === WS.prototype.name);
};

},{&quot;../transport&quot;:14,&quot;component-inherit&quot;:21,&quot;debug&quot;:22,&quot;engine.io-parser&quot;:25,&quot;parseqs&quot;:35,&quot;ws&quot;:37}],20:[function(_dereq_,module,exports){
// browser shim for xmlhttprequest module
var hasCORS = _dereq_(&apos;has-cors&apos;);

module.exports = function(opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if (&apos;undefined&apos; != typeof XMLHttpRequest &amp;&amp; (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if (&apos;undefined&apos; != typeof XDomainRequest &amp;&amp; !xscheme &amp;&amp; enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);
    } catch(e) { }
  }
}

},{&quot;has-cors&quot;:40}],21:[function(_dereq_,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],22:[function(_dereq_,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = _dereq_(&apos;./debug&apos;);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [
  &apos;lightseagreen&apos;,
  &apos;forestgreen&apos;,
  &apos;goldenrod&apos;,
  &apos;dodgerblue&apos;,
  &apos;darkorchid&apos;,
  &apos;crimson&apos;
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox &gt;= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support &quot;%c&quot; CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return (&apos;WebkitAppearance&apos; in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console &amp;&amp; (console.firebug || (console.exception &amp;&amp; console.table))) ||
    // is firefox &gt;= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &amp;&amp; parseInt(RegExp.$1, 10) &gt;= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? &apos;%c&apos; : &apos;&apos;)
    + this.namespace
    + (useColors ? &apos; %c&apos; : &apos; &apos;)
    + args[0]
    + (useColors ? &apos;%c &apos; : &apos; &apos;)
    + &apos;+&apos; + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = &apos;color: &apos; + this.color;
  args = [args[0], c, &apos;color: inherit&apos;].concat(Array.prototype.slice.call(args, 1));

  // the final &quot;%c&quot; is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if (&apos;%&apos; === match) return;
    index++;
    if (&apos;%c&apos; === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a &quot;function&quot;.
 *
 * @api public
 */

function log() {
  // This hackery is required for IE8,
  // where the `console.log` function doesn&apos;t have &apos;apply&apos;
  return &apos;object&apos; == typeof console
    &amp;&amp; &apos;function&apos; == typeof console.log
    &amp;&amp; Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      localStorage.removeItem(&apos;debug&apos;);
    } else {
      localStorage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = localStorage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

},{&quot;./debug&quot;:23}],23:[function(_dereq_,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = _dereq_(&apos;ms&apos;);

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special &quot;%n&quot; handling functions, for the debug &quot;format&quot; argument.
 *
 * Valid key names are a single, lowercased letter, i.e. &quot;n&quot;.
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color &amp;&amp; self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if (&apos;string&apos; !== typeof args[0]) {
      // anything else let&apos;s inspect with %o
      args = [&apos;%o&apos;].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don&apos;t increase the array index
      if (match === &apos;%&apos;) return match;
      index++;
      var formatter = exports.formatters[format];
      if (&apos;function&apos; === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it&apos;s inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if (&apos;function&apos; === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || &apos;&apos;).split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i &lt; len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, &apos;.*?&apos;);
    if (namespaces[0] === &apos;-&apos;) {
      exports.skips.push(new RegExp(&apos;^&apos; + namespaces.substr(1) + &apos;$&apos;));
    } else {
      exports.names.push(new RegExp(&apos;^&apos; + namespaces + &apos;$&apos;));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable(&apos;&apos;);
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i &lt; len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i &lt; len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{&quot;ms&quot;:24}],24:[function(_dereq_,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if (&apos;string&apos; == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || &apos;ms&apos;).toLowerCase();
  switch (type) {
    case &apos;years&apos;:
    case &apos;year&apos;:
    case &apos;y&apos;:
      return n * y;
    case &apos;days&apos;:
    case &apos;day&apos;:
    case &apos;d&apos;:
      return n * d;
    case &apos;hours&apos;:
    case &apos;hour&apos;:
    case &apos;h&apos;:
      return n * h;
    case &apos;minutes&apos;:
    case &apos;minute&apos;:
    case &apos;m&apos;:
      return n * m;
    case &apos;seconds&apos;:
    case &apos;second&apos;:
    case &apos;s&apos;:
      return n * s;
    case &apos;ms&apos;:
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms &gt;= d) return Math.round(ms / d) + &apos;d&apos;;
  if (ms &gt;= h) return Math.round(ms / h) + &apos;h&apos;;
  if (ms &gt;= m) return Math.round(ms / m) + &apos;m&apos;;
  if (ms &gt;= s) return Math.round(ms / s) + &apos;s&apos;;
  return ms + &apos;ms&apos;;
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, &apos;day&apos;)
    || plural(ms, h, &apos;hour&apos;)
    || plural(ms, m, &apos;minute&apos;)
    || plural(ms, s, &apos;second&apos;)
    || ms + &apos; ms&apos;;
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms &lt; n) return;
  if (ms &lt; n * 1.5) return Math.floor(ms / n) + &apos; &apos; + name;
  return Math.ceil(ms / n) + &apos; &apos; + name + &apos;s&apos;;
}

},{}],25:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var keys = _dereq_(&apos;./keys&apos;);
var hasBinary = _dereq_(&apos;has-binary&apos;);
var sliceBuffer = _dereq_(&apos;arraybuffer.slice&apos;);
var base64encoder = _dereq_(&apos;base64-arraybuffer&apos;);
var after = _dereq_(&apos;after&apos;);
var utf8 = _dereq_(&apos;utf8&apos;);

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

//var isAndroid = navigator.userAgent.match(/Android/i);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
//var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = false;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: &apos;error&apos;, data: &apos;parser error&apos; };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = _dereq_(&apos;blob&apos;);

/**
 * Encodes a packet.
 *
 *     &lt;packet type id&gt; [ &lt;data&gt; ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if (&apos;function&apos; == typeof supportsBinary) {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if (&apos;function&apos; == typeof utf8encode) {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer &amp;&amp; data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob &amp;&amp; data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data &amp;&amp; data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
  }

  return callback(&apos;&apos; + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = &apos;b&apos; + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i &lt; contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = &apos;b&apos; + exports.packets[packet.type];
  if (Blob &amp;&amp; packet.data instanceof Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(&apos;,&apos;)[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn&apos;t let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i &lt; typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  // String data
  if (typeof data == &apos;string&apos; || data === undefined) {
    if (data.charAt(0) == &apos;b&apos;) {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      try {
        data = utf8.decode(data);
      } catch (e) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length &gt; 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob &amp;&amp; binaryType === &apos;blob&apos;) {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!global.ArrayBuffer) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === &apos;blob&apos; &amp;&amp; Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     &lt;length&gt;:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary == &apos;function&apos;) {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary &amp;&amp; isBinary) {
    if (Blob &amp;&amp; !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback(&apos;0:&apos;);
  }

  function setLengthHeader(message) {
    return message.length + &apos;:&apos; + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(&apos;&apos;));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i &lt; ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data != &apos;string&apos;) {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === &apos;function&apos;) {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data == &apos;&apos;) {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = &apos;&apos;
    , n, msg;

  for (var i = 0, l = data.length; i &lt; l; i++) {
    var chr = data.charAt(i);

    if (&apos;:&apos; != chr) {
      length += chr;
    } else {
      if (&apos;&apos; == length || (length != (n = Number(length)))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType, true);

        if (err.type == packet.type &amp;&amp; err.data == packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      }

      // advance cursor
      i += n;
      length = &apos;&apos;;
    }
  }

  if (length != &apos;&apos;) {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * &lt;1 = binary, 0 = string&gt;&lt;number from 0-9&gt;&lt;number from 0-9&gt;[...]&lt;number
 * 255&gt;&lt;data&gt;
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === &apos;string&apos;){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === &apos;string&apos;;
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i &lt; p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i &lt; lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i &lt; view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === &apos;string&apos;) {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i &lt; encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i &lt; lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === &apos;function&apos;) {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  var numberTooLong = false;
  while (bufferTail.byteLength &gt; 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = &apos;&apos;;

    for (var i = 1; ; i++) {
      if (tailArray[i] == 255) break;

      if (msgLength.length &gt; 310) {
        numberTooLong = true;
        break;
      }

      msgLength += tailArray[i];
    }

    if(numberTooLong) return callback(err, 0, 1);

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn&apos;t let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = &apos;&apos;;
        for (var i = 0; i &lt; typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;./keys&quot;:26,&quot;after&quot;:27,&quot;arraybuffer.slice&quot;:28,&quot;base64-arraybuffer&quot;:29,&quot;blob&quot;:30,&quot;has-binary&quot;:31,&quot;utf8&quot;:33}],26:[function(_dereq_,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],27:[function(_dereq_,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count &lt;= 0) {
            throw new Error(&apos;after called too many times&apos;)
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 &amp;&amp; !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],28:[function(_dereq_,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start &lt; 0) { start += bytes; }
  if (end &lt; 0) { end += bytes; }
  if (end &gt; bytes) { end = bytes; }

  if (start &gt;= bytes || start &gt;= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i &lt; end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],29:[function(_dereq_,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(chars){
  &quot;use strict&quot;;

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = &quot;&quot;;

    for (i = 0; i &lt; len; i+=3) {
      base64 += chars[bytes[i] &gt;&gt; 2];
      base64 += chars[((bytes[i] &amp; 3) &lt;&lt; 4) | (bytes[i + 1] &gt;&gt; 4)];
      base64 += chars[((bytes[i + 1] &amp; 15) &lt;&lt; 2) | (bytes[i + 2] &gt;&gt; 6)];
      base64 += chars[bytes[i + 2] &amp; 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + &quot;=&quot;;
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + &quot;==&quot;;
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === &quot;=&quot;) {
      bufferLength--;
      if (base64[base64.length - 2] === &quot;=&quot;) {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i &lt; len; i+=4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i+1]);
      encoded3 = chars.indexOf(base64[i+2]);
      encoded4 = chars.indexOf(base64[i+3]);

      bytes[p++] = (encoded1 &lt;&lt; 2) | (encoded2 &gt;&gt; 4);
      bytes[p++] = ((encoded2 &amp; 15) &lt;&lt; 4) | (encoded3 &gt;&gt; 2);
      bytes[p++] = ((encoded3 &amp; 3) &lt;&lt; 6) | (encoded4 &amp; 63);
    }

    return arraybuffer;
  };
})(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;);

},{}],30:[function(_dereq_,module,exports){
(function (global){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var b = new Blob([&apos;hi&apos;]);
    return b.size == 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  &amp;&amp; BlobBuilder.prototype.append
  &amp;&amp; BlobBuilder.prototype.getBlob;

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  for (var i = 0; i &lt; ary.length; i++) {
    bb.append(ary[i]);
  }
  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

module.exports = (function() {
  if (blobSupported) {
    return global.Blob;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{}],31:[function(_dereq_,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = _dereq_(&apos;isarray&apos;);

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer &amp;&amp; global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer &amp;&amp; obj instanceof ArrayBuffer) ||
         (global.Blob &amp;&amp; obj instanceof Blob) ||
         (global.File &amp;&amp; obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i &lt; obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj &amp;&amp; &apos;object&apos; == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (obj.hasOwnProperty(key) &amp;&amp; _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;isarray&quot;:32}],32:[function(_dereq_,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == &apos;[object Array]&apos;;
};

},{}],33:[function(_dereq_,module,exports){
(function (global){
/*! http://mths.be/utf8js v2.0.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == &apos;object&apos; &amp;&amp; exports;

	// Detect free variable `module`
	var freeModule = typeof module == &apos;object&apos; &amp;&amp; module &amp;&amp;
		module.exports == freeExports &amp;&amp; module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == &apos;object&apos; &amp;&amp; global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from http://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter &lt; length) {
			value = string.charCodeAt(counter++);
			if (value &gt;= 0xD800 &amp;&amp; value &lt;= 0xDBFF &amp;&amp; counter &lt; length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra &amp; 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value &amp; 0x3FF) &lt;&lt; 10) + (extra &amp; 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from http://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = &apos;&apos;;
		while (++index &lt; length) {
			value = array[index];
			if (value &gt; 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value &gt;&gt;&gt; 10 &amp; 0x3FF | 0xD800);
				value = 0xDC00 | value &amp; 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint &gt;&gt; shift) &amp; 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint &amp; 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = &apos;&apos;;
		if ((codePoint &amp; 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint &gt;&gt; 6) &amp; 0x1F) | 0xC0);
		}
		else if ((codePoint &amp; 0xFFFF0000) == 0) { // 3-byte sequence
			symbol = stringFromCharCode(((codePoint &gt;&gt; 12) &amp; 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint &amp; 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint &gt;&gt; 18) &amp; 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint &amp; 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);

		// console.log(JSON.stringify(codePoints.map(function(x) {
		// 	return &apos;U+&apos; + x.toString(16).toUpperCase();
		// })));

		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = &apos;&apos;;
		while (++index &lt; length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex &gt;= byteCount) {
			throw Error(&apos;Invalid byte index&apos;);
		}

		var continuationByte = byteArray[byteIndex] &amp; 0xFF;
		byteIndex++;

		if ((continuationByte &amp; 0xC0) == 0x80) {
			return continuationByte &amp; 0x3F;
		}

		// If we end up here, its not a continuation byte
		throw Error(&apos;Invalid continuation byte&apos;);
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex &gt; byteCount) {
			throw Error(&apos;Invalid byte index&apos;);
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] &amp; 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 &amp; 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 &amp; 0xE0) == 0xC0) {
			var byte2 = readContinuationByte();
			codePoint = ((byte1 &amp; 0x1F) &lt;&lt; 6) | byte2;
			if (codePoint &gt;= 0x80) {
				return codePoint;
			} else {
				throw Error(&apos;Invalid continuation byte&apos;);
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 &amp; 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 &amp; 0x0F) &lt;&lt; 12) | (byte2 &lt;&lt; 6) | byte3;
			if (codePoint &gt;= 0x0800) {
				return codePoint;
			} else {
				throw Error(&apos;Invalid continuation byte&apos;);
			}
		}

		// 4-byte sequence
		if ((byte1 &amp; 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 &amp; 0x0F) &lt;&lt; 0x12) | (byte2 &lt;&lt; 0x0C) |
				(byte3 &lt;&lt; 0x06) | byte4;
			if (codePoint &gt;= 0x010000 &amp;&amp; codePoint &lt;= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error(&apos;Invalid UTF-8 detected&apos;);
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		&apos;version&apos;: &apos;2.0.0&apos;,
		&apos;encode&apos;: utf8encode,
		&apos;decode&apos;: utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == &apos;function&apos; &amp;&amp;
		typeof define.amd == &apos;object&apos; &amp;&amp;
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports &amp;&amp; !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) &amp;&amp; (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{}],34:[function(_dereq_,module,exports){
(function (global){
/**
 * JSON parse.
 *
 * @see Based on jQuery#parseJSON (MIT) and JSON2
 * @api private
 */

var rvalidchars = /^[\],:{}\s]*$/;
var rvalidescape = /\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rvalidtokens = /&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
var rtrimLeft = /^\s+/;
var rtrimRight = /\s+$/;

module.exports = function parsejson(data) {
  if (&apos;string&apos; != typeof data || !data) {
    return null;
  }

  data = data.replace(rtrimLeft, &apos;&apos;).replace(rtrimRight, &apos;&apos;);

  // Attempt to parse using the native JSON parser first
  if (global.JSON &amp;&amp; JSON.parse) {
    return JSON.parse(data);
  }

  if (rvalidchars.test(data.replace(rvalidescape, &apos;@&apos;)
      .replace(rvalidtokens, &apos;]&apos;)
      .replace(rvalidbraces, &apos;&apos;))) {
    return (new Function(&apos;return &apos; + data))();
  }
};
}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{}],35:[function(_dereq_,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = &apos;&apos;;

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += &apos;&amp;&apos;;
      str += encodeURIComponent(i) + &apos;=&apos; + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split(&apos;&amp;&apos;);
  for (var i = 0, l = pairs.length; i &lt; l; i++) {
    var pair = pairs[i].split(&apos;=&apos;);
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],36:[function(_dereq_,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan &lt;stevenlevithan.com&gt; (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    &apos;source&apos;, &apos;protocol&apos;, &apos;authority&apos;, &apos;userInfo&apos;, &apos;user&apos;, &apos;password&apos;, &apos;host&apos;, &apos;port&apos;, &apos;relative&apos;, &apos;path&apos;, &apos;directory&apos;, &apos;file&apos;, &apos;query&apos;, &apos;anchor&apos;
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf(&apos;[&apos;),
        e = str.indexOf(&apos;]&apos;);

    if (b != -1 &amp;&amp; e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, &apos;;&apos;) + str.substring(e, str.length);
    }

    var m = re.exec(str || &apos;&apos;),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || &apos;&apos;;
    }

    if (b != -1 &amp;&amp; e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, &apos;:&apos;);
        uri.authority = uri.authority.replace(&apos;[&apos;, &apos;&apos;).replace(&apos;]&apos;, &apos;&apos;).replace(/;/g, &apos;:&apos;);
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],37:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var global = (function() { return this; })();

/**
 * WebSocket constructor.
 */

var WebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Module exports.
 */

module.exports = WebSocket ? ws : null;

/**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it&apos;s
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object) opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
  var instance;
  if (protocols) {
    instance = new WebSocket(uri, protocols);
  } else {
    instance = new WebSocket(uri);
  }
  return instance;
}

if (WebSocket) ws.prototype = WebSocket.prototype;

},{}],38:[function(_dereq_,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = _dereq_(&apos;isarray&apos;);

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer &amp;&amp; global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer &amp;&amp; obj instanceof ArrayBuffer) ||
         (global.Blob &amp;&amp; obj instanceof Blob) ||
         (global.File &amp;&amp; obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i &lt; obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj &amp;&amp; &apos;object&apos; == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) &amp;&amp; _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;isarray&quot;:39}],39:[function(_dereq_,module,exports){
module.exports=_dereq_(32)
},{}],40:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var global = _dereq_(&apos;global&apos;);

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = &apos;XMLHttpRequest&apos; in global &amp;&amp;
    &apos;withCredentials&apos; in new global.XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{&quot;global&quot;:41}],41:[function(_dereq_,module,exports){

/**
 * Returns `this`. Execute this without a &quot;context&quot; (i.e. without it being
 * attached to an object of the left-hand side), and `this` points to the
 * &quot;global&quot; scope of the current JS execution.
 */

module.exports = (function () { return this; })();

},{}],42:[function(_dereq_,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i &lt; arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],43:[function(_dereq_,module,exports){

/**
 * HOP ref.
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Return own keys in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.keys = Object.keys || function(obj){
  var keys = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
};

/**
 * Return own values in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.values = function(obj){
  var vals = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      vals.push(obj[key]);
    }
  }
  return vals;
};

/**
 * Merge `b` into `a`.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api public
 */

exports.merge = function(a, b){
  for (var key in b) {
    if (has.call(b, key)) {
      a[key] = b[key];
    }
  }
  return a;
};

/**
 * Return length of `obj`.
 *
 * @param {Object} obj
 * @return {Number}
 * @api public
 */

exports.length = function(obj){
  return exports.keys(obj).length;
};

/**
 * Check if `obj` is empty.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api public
 */

exports.isEmpty = function(obj){
  return 0 == exports.length(obj);
};
},{}],44:[function(_dereq_,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan &lt;stevenlevithan.com&gt; (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    &apos;source&apos;, &apos;protocol&apos;, &apos;authority&apos;, &apos;userInfo&apos;, &apos;user&apos;, &apos;password&apos;, &apos;host&apos;
  , &apos;port&apos;, &apos;relative&apos;, &apos;path&apos;, &apos;directory&apos;, &apos;file&apos;, &apos;query&apos;, &apos;anchor&apos;
];

module.exports = function parseuri(str) {
  var m = re.exec(str || &apos;&apos;)
    , uri = {}
    , i = 14;

  while (i--) {
    uri[parts[i]] = m[i] || &apos;&apos;;
  }

  return uri;
};

},{}],45:[function(_dereq_,module,exports){
(function (global){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = _dereq_(&apos;isarray&apos;);
var isBuf = _dereq_(&apos;./is-buffer&apos;);

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet){
  var buffers = [];
  var packetData = packet.data;

  function _deconstructPacket(data) {
    if (!data) return data;

    if (isBuf(data)) {
      var placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (isArray(data)) {
      var newData = new Array(data.length);
      for (var i = 0; i &lt; data.length; i++) {
        newData[i] = _deconstructPacket(data[i]);
      }
      return newData;
    } else if (&apos;object&apos; == typeof data &amp;&amp; !(data instanceof Date)) {
      var newData = {};
      for (var key in data) {
        newData[key] = _deconstructPacket(data[key]);
      }
      return newData;
    }
    return data;
  }

  var pack = packet;
  pack.data = _deconstructPacket(packetData);
  pack.attachments = buffers.length; // number of binary &apos;attachments&apos;
  return {packet: pack, buffers: buffers};
};

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  var curPlaceHolder = 0;

  function _reconstructPacket(data) {
    if (data &amp;&amp; data._placeholder) {
      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
      return buf;
    } else if (isArray(data)) {
      for (var i = 0; i &lt; data.length; i++) {
        data[i] = _reconstructPacket(data[i]);
      }
      return data;
    } else if (data &amp;&amp; &apos;object&apos; == typeof data) {
      for (var key in data) {
        data[key] = _reconstructPacket(data[key]);
      }
      return data;
    }
    return data;
  }

  packet.data = _reconstructPacket(packet.data);
  packet.attachments = undefined; // no longer useful
  return packet;
};

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader&apos;s readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((global.Blob &amp;&amp; obj instanceof Blob) ||
        (global.File &amp;&amp; obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -&gt; arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i &lt; obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (obj &amp;&amp; &apos;object&apos; == typeof obj &amp;&amp; !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;./is-buffer&quot;:47,&quot;isarray&quot;:48}],46:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var debug = _dereq_(&apos;debug&apos;)(&apos;socket.io-parser&apos;);
var json = _dereq_(&apos;json3&apos;);
var isArray = _dereq_(&apos;isarray&apos;);
var Emitter = _dereq_(&apos;component-emitter&apos;);
var binary = _dereq_(&apos;./binary&apos;);
var isBuf = _dereq_(&apos;./is-buffer&apos;);

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  &apos;CONNECT&apos;,
  &apos;DISCONNECT&apos;,
  &apos;EVENT&apos;,
  &apos;BINARY_EVENT&apos;,
  &apos;ACK&apos;,
  &apos;BINARY_ACK&apos;,
  &apos;ERROR&apos;
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type &apos;binary event&apos;
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug(&apos;encoding packet %j&apos;, obj);

  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {
  var str = &apos;&apos;;
  var nsp = false;

  // first is type
  str += obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    str += obj.attachments;
    str += &apos;-&apos;;
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp &amp;&amp; &apos;/&apos; != obj.nsp) {
    nsp = true;
    str += obj.nsp;
  }

  // immediately followed by the id
  if (null != obj.id) {
    if (nsp) {
      str += &apos;,&apos;;
      nsp = false;
    }
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    if (nsp) str += &apos;,&apos;;
    str += json.stringify(obj.data);
  }

  debug(&apos;encoded %j as %s&apos;, obj, str);
  return str;
}

/**
 * Encode packet as &apos;buffer sequence&apos; by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if (&apos;string&apos; == typeof obj) {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet&apos;s json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit(&apos;decoded&apos;, packet);
      }
    } else { // non-binary full packet
      this.emit(&apos;decoded&apos;, packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error(&apos;got binary data when not reconstructing a packet&apos;);
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit(&apos;decoded&apos;, packet);
      }
    }
  }
  else {
    throw new Error(&apos;Unknown type: &apos; + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var p = {};
  var i = 0;

  // look up type
  p.type = Number(str.charAt(0));
  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
    var buf = &apos;&apos;;
    while (str.charAt(++i) != &apos;-&apos;) {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) != &apos;-&apos;) {
      throw new Error(&apos;Illegal attachments&apos;);
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if (&apos;/&apos; == str.charAt(i + 1)) {
    p.nsp = &apos;&apos;;
    while (++i) {
      var c = str.charAt(i);
      if (&apos;,&apos; == c) break;
      p.nsp += c;
      if (i == str.length) break;
    }
  } else {
    p.nsp = &apos;/&apos;;
  }

  // look up id
  var next = str.charAt(i + 1);
  if (&apos;&apos; !== next &amp;&amp; Number(next) == next) {
    p.id = &apos;&apos;;
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i == str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    try {
      p.data = json.parse(str.substr(i));
    } catch(e){
      return error();
    }
  }

  debug(&apos;decoded %s as %j&apos;, str, p);
  return p;
}

/**
 * Deallocates a parser&apos;s resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event&apos;s &apos;buffer sequence&apos;. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(data){
  return {
    type: exports.ERROR,
    data: &apos;parser error&apos;
  };
}

},{&quot;./binary&quot;:45,&quot;./is-buffer&quot;:47,&quot;component-emitter&quot;:9,&quot;debug&quot;:10,&quot;isarray&quot;:48,&quot;json3&quot;:49}],47:[function(_dereq_,module,exports){
(function (global){

module.exports = isBuf;

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (global.Buffer &amp;&amp; global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer &amp;&amp; obj instanceof ArrayBuffer);
}

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{}],48:[function(_dereq_,module,exports){
module.exports=_dereq_(32)
},{}],49:[function(_dereq_,module,exports){
/*! JSON v3.2.6 | http://bestiejs.github.io/json3 | Copyright 2012-2013, Kit Cambridge | http://kit.mit-license.org */
;(function (window) {
  // Convenience aliases.
  var getClass = {}.toString, isProperty, forEach, undef;

  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === &quot;function&quot; &amp;&amp; define.amd;

  // Detect native implementations.
  var nativeJSON = typeof JSON == &quot;object&quot; &amp;&amp; JSON;

  // Set up the JSON 3 namespace, preferring the CommonJS `exports` object if
  // available.
  var JSON3 = typeof exports == &quot;object&quot; &amp;&amp; exports &amp;&amp; !exports.nodeType &amp;&amp; exports;

  if (JSON3 &amp;&amp; nativeJSON) {
    // Explicitly delegate to the native `stringify` and `parse`
    // implementations in CommonJS environments.
    JSON3.stringify = nativeJSON.stringify;
    JSON3.parse = nativeJSON.parse;
  } else {
    // Export for web browsers, JavaScript engines, and asynchronous module
    // loaders, using the global `JSON` object if available.
    JSON3 = window.JSON = nativeJSON || {};
  }

  // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
  var isExtended = new Date(-3509827334573292);
  try {
    // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
    // results for certain dates in Opera &gt;= 10.53.
    isExtended = isExtended.getUTCFullYear() == -109252 &amp;&amp; isExtended.getUTCMonth() === 0 &amp;&amp; isExtended.getUTCDate() === 1 &amp;&amp;
      // Safari &lt; 2.0.2 stores the internal millisecond time value correctly,
      // but clips the values returned by the date methods to the range of
      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
      isExtended.getUTCHours() == 10 &amp;&amp; isExtended.getUTCMinutes() == 37 &amp;&amp; isExtended.getUTCSeconds() == 6 &amp;&amp; isExtended.getUTCMilliseconds() == 708;
  } catch (exception) {}

  // Internal: Determines whether the native `JSON.stringify` and `parse`
  // implementations are spec-compliant. Based on work by Ken Snyder.
  function has(name) {
    if (has[name] !== undef) {
      // Return cached feature test result.
      return has[name];
    }

    var isSupported;
    if (name == &quot;bug-string-char-index&quot;) {
      // IE &lt;= 7 doesn&apos;t support accessing string characters using square
      // bracket notation. IE 8 only supports this for primitives.
      isSupported = &quot;a&quot;[0] != &quot;a&quot;;
    } else if (name == &quot;json&quot;) {
      // Indicates whether both `JSON.stringify` and `JSON.parse` are
      // supported.
      isSupported = has(&quot;json-stringify&quot;) &amp;&amp; has(&quot;json-parse&quot;);
    } else {
      var value, serialized = &apos;{&quot;a&quot;:[1,true,false,null,&quot;\\u0000\\b\\n\\f\\r\\t&quot;]}&apos;;
      // Test `JSON.stringify`.
      if (name == &quot;json-stringify&quot;) {
        var stringify = JSON3.stringify, stringifySupported = typeof stringify == &quot;function&quot; &amp;&amp; isExtended;
        if (stringifySupported) {
          // A test function object with a custom `toJSON` method.
          (value = function () {
            return 1;
          }).toJSON = value;
          try {
            stringifySupported =
              // Firefox 3.1b1 and b2 serialize string, number, and boolean
              // primitives as object literals.
              stringify(0) === &quot;0&quot; &amp;&amp;
              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
              // literals.
              stringify(new Number()) === &quot;0&quot; &amp;&amp;
              stringify(new String()) == &apos;&quot;&quot;&apos; &amp;&amp;
              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
              // does not define a canonical JSON representation (this applies to
              // objects with `toJSON` properties as well, *unless* they are nested
              // within an object or array).
              stringify(getClass) === undef &amp;&amp;
              // IE 8 serializes `undefined` as `&quot;undefined&quot;`. Safari &lt;= 5.1.7 and
              // FF 3.1b3 pass this test.
              stringify(undef) === undef &amp;&amp;
              // Safari &lt;= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
              // respectively, if the value is omitted entirely.
              stringify() === undef &amp;&amp;
              // FF 3.1b1, 2 throw an error if the given value is not a number,
              // string, array, object, Boolean, or `null` literal. This applies to
              // objects with custom `toJSON` methods as well, unless they are nested
              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
              // methods entirely.
              stringify(value) === &quot;1&quot; &amp;&amp;
              stringify([value]) == &quot;[1]&quot; &amp;&amp;
              // Prototype &lt;= 1.6.1 serializes `[undefined]` as `&quot;[]&quot;` instead of
              // `&quot;[null]&quot;`.
              stringify([undef]) == &quot;[null]&quot; &amp;&amp;
              // YUI 3.0.0b1 fails to serialize `null` literals.
              stringify(null) == &quot;null&quot; &amp;&amp;
              // FF 3.1b1, 2 halts serialization if an array contains a function:
              // `[1, true, getClass, 1]` serializes as &quot;[1,true,],&quot;. FF 3.1b3
              // elides non-JSON values from objects and arrays, unless they
              // define custom `toJSON` methods.
              stringify([undef, getClass, null]) == &quot;[null,null,null]&quot; &amp;&amp;
              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
              // where character escape codes are expected (e.g., `\b` =&gt; `\u0008`).
              stringify({ &quot;a&quot;: [value, true, false, null, &quot;\x00\b\n\f\r\t&quot;] }) == serialized &amp;&amp;
              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
              stringify(null, value) === &quot;1&quot; &amp;&amp;
              stringify([1, 2], null, 1) == &quot;[\n 1,\n 2\n]&quot; &amp;&amp;
              // JSON 2, Prototype &lt;= 1.7, and older WebKit builds incorrectly
              // serialize extended years.
              stringify(new Date(-8.64e15)) == &apos;&quot;-271821-04-20T00:00:00.000Z&quot;&apos; &amp;&amp;
              // The milliseconds are optional in ES 5, but required in 5.1.
              stringify(new Date(8.64e15)) == &apos;&quot;+275760-09-13T00:00:00.000Z&quot;&apos; &amp;&amp;
              // Firefox &lt;= 11.0 incorrectly serializes years prior to 0 as negative
              // four-digit years instead of six-digit years. Credits: @Yaffle.
              stringify(new Date(-621987552e5)) == &apos;&quot;-000001-01-01T00:00:00.000Z&quot;&apos; &amp;&amp;
              // Safari &lt;= 5.1.5 and Opera &gt;= 10.53 incorrectly serialize millisecond
              // values less than 1000. Credits: @Yaffle.
              stringify(new Date(-1)) == &apos;&quot;1969-12-31T23:59:59.999Z&quot;&apos;;
          } catch (exception) {
            stringifySupported = false;
          }
        }
        isSupported = stringifySupported;
      }
      // Test `JSON.parse`.
      if (name == &quot;json-parse&quot;) {
        var parse = JSON3.parse;
        if (typeof parse == &quot;function&quot;) {
          try {
            // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
            // Conforming implementations should also coerce the initial argument to
            // a string prior to parsing.
            if (parse(&quot;0&quot;) === 0 &amp;&amp; !parse(false)) {
              // Simple parsing test.
              value = parse(serialized);
              var parseSupported = value[&quot;a&quot;].length == 5 &amp;&amp; value[&quot;a&quot;][0] === 1;
              if (parseSupported) {
                try {
                  // Safari &lt;= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                  parseSupported = !parse(&apos;&quot;\t&quot;&apos;);
                } catch (exception) {}
                if (parseSupported) {
                  try {
                    // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                    // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                    // certain octal literals.
                    parseSupported = parse(&quot;01&quot;) !== 1;
                  } catch (exception) {}
                }
                if (parseSupported) {
                  try {
                    // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                    // points. These environments, along with FF 3.1b1 and 2,
                    // also allow trailing commas in JSON objects and arrays.
                    parseSupported = parse(&quot;1.&quot;) !== 1;
                  } catch (exception) {}
                }
              }
            }
          } catch (exception) {
            parseSupported = false;
          }
        }
        isSupported = parseSupported;
      }
    }
    return has[name] = !!isSupported;
  }

  if (!has(&quot;json&quot;)) {
    // Common `[[Class]]` name aliases.
    var functionClass = &quot;[object Function]&quot;;
    var dateClass = &quot;[object Date]&quot;;
    var numberClass = &quot;[object Number]&quot;;
    var stringClass = &quot;[object String]&quot;;
    var arrayClass = &quot;[object Array]&quot;;
    var booleanClass = &quot;[object Boolean]&quot;;

    // Detect incomplete support for accessing string characters by index.
    var charIndexBuggy = has(&quot;bug-string-char-index&quot;);

    // Define additional utility methods if the `Date` methods are buggy.
    if (!isExtended) {
      var floor = Math.floor;
      // A mapping between the months of the year and the number of days between
      // January 1st and the first of the respective month.
      var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      // Internal: Calculates the number of days between the Unix epoch and the
      // first day of the given month.
      var getDay = function (year, month) {
        return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month &gt; 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
      };
    }

    // Internal: Determines if a property is a direct property of the given
    // object. Delegates to the native `Object#hasOwnProperty` method.
    if (!(isProperty = {}.hasOwnProperty)) {
      isProperty = function (property) {
        var members = {}, constructor;
        if ((members.__proto__ = null, members.__proto__ = {
          // The *proto* property cannot be set multiple times in recent
          // versions of Firefox and SeaMonkey.
          &quot;toString&quot;: 1
        }, members).toString != getClass) {
          // Safari &lt;= 2.0.3 doesn&apos;t implement `Object#hasOwnProperty`, but
          // supports the mutable *proto* property.
          isProperty = function (property) {
            // Capture and break the object&apos;s prototype chain (see section 8.6.2
            // of the ES 5.1 spec). The parenthesized expression prevents an
            // unsafe transformation by the Closure Compiler.
            var original = this.__proto__, result = property in (this.__proto__ = null, this);
            // Restore the original prototype chain.
            this.__proto__ = original;
            return result;
          };
        } else {
          // Capture a reference to the top-level `Object` constructor.
          constructor = members.constructor;
          // Use the `constructor` property to simulate `Object#hasOwnProperty` in
          // other environments.
          isProperty = function (property) {
            var parent = (this.constructor || constructor).prototype;
            return property in this &amp;&amp; !(property in parent &amp;&amp; this[property] === parent[property]);
          };
        }
        members = null;
        return isProperty.call(this, property);
      };
    }

    // Internal: A set of primitive types used by `isHostType`.
    var PrimitiveTypes = {
      &apos;boolean&apos;: 1,
      &apos;number&apos;: 1,
      &apos;string&apos;: 1,
      &apos;undefined&apos;: 1
    };

    // Internal: Determines if the given object `property` value is a
    // non-primitive.
    var isHostType = function (object, property) {
      var type = typeof object[property];
      return type == &apos;object&apos; ? !!object[property] : !PrimitiveTypes[type];
    };

    // Internal: Normalizes the `for...in` iteration algorithm across
    // environments. Each enumerated key is yielded to a `callback` function.
    forEach = function (object, callback) {
      var size = 0, Properties, members, property;

      // Tests for bugs in the current environment&apos;s `for...in` algorithm. The
      // `valueOf` property inherits the non-enumerable flag from
      // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
      (Properties = function () {
        this.valueOf = 0;
      }).prototype.valueOf = 0;

      // Iterate over a new instance of the `Properties` class.
      members = new Properties();
      for (property in members) {
        // Ignore all properties inherited from `Object.prototype`.
        if (isProperty.call(members, property)) {
          size++;
        }
      }
      Properties = members = null;

      // Normalize the iteration algorithm.
      if (!size) {
        // A list of non-enumerable properties inherited from `Object.prototype`.
        members = [&quot;valueOf&quot;, &quot;toString&quot;, &quot;toLocaleString&quot;, &quot;propertyIsEnumerable&quot;, &quot;isPrototypeOf&quot;, &quot;hasOwnProperty&quot;, &quot;constructor&quot;];
        // IE &lt;= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
        // properties.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, length;
          var hasProperty = !isFunction &amp;&amp; typeof object.constructor != &apos;function&apos; &amp;&amp; isHostType(object, &apos;hasOwnProperty&apos;) ? object.hasOwnProperty : isProperty;
          for (property in object) {
            // Gecko &lt;= 1.0 enumerates the `prototype` property of functions under
            // certain conditions; IE does not.
            if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; hasProperty.call(object, property)) {
              callback(property);
            }
          }
          // Manually invoke the callback for each non-enumerable property.
          for (length = members.length; property = members[--length]; hasProperty.call(object, property) &amp;&amp; callback(property));
        };
      } else if (size == 2) {
        // Safari &lt;= 2.0.4 enumerates shadowed properties twice.
        forEach = function (object, callback) {
          // Create a set of iterated properties.
          var members = {}, isFunction = getClass.call(object) == functionClass, property;
          for (property in object) {
            // Store each property name to prevent double enumeration. The
            // `prototype` property of functions is not enumerated due to cross-
            // environment inconsistencies.
            if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; !isProperty.call(members, property) &amp;&amp; (members[property] = 1) &amp;&amp; isProperty.call(object, property)) {
              callback(property);
            }
          }
        };
      } else {
        // No bugs detected; use the standard `for...in` algorithm.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, isConstructor;
          for (property in object) {
            if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; isProperty.call(object, property) &amp;&amp; !(isConstructor = property === &quot;constructor&quot;)) {
              callback(property);
            }
          }
          // Manually invoke the callback for the `constructor` property due to
          // cross-environment inconsistencies.
          if (isConstructor || isProperty.call(object, (property = &quot;constructor&quot;))) {
            callback(property);
          }
        };
      }
      return forEach(object, callback);
    };

    // Public: Serializes a JavaScript `value` as a JSON string. The optional
    // `filter` argument may specify either a function that alters how object and
    // array members are serialized, or an array of strings and numbers that
    // indicates which properties should be serialized. The optional `width`
    // argument may be either a string or number that specifies the indentation
    // level of the output.
    if (!has(&quot;json-stringify&quot;)) {
      // Internal: A map of control characters and their escaped equivalents.
      var Escapes = {
        92: &quot;\\\\&quot;,
        34: &apos;\\&quot;&apos;,
        8: &quot;\\b&quot;,
        12: &quot;\\f&quot;,
        10: &quot;\\n&quot;,
        13: &quot;\\r&quot;,
        9: &quot;\\t&quot;
      };

      // Internal: Converts `value` into a zero-padded string such that its
      // length is at least equal to `width`. The `width` must be &lt;= 6.
      var leadingZeroes = &quot;000000&quot;;
      var toPaddedString = function (width, value) {
        // The `|| 0` expression is necessary to work around a bug in
        // Opera &lt;= 7.54u2 where `0 == -0`, but `String(-0) !== &quot;0&quot;`.
        return (leadingZeroes + (value || 0)).slice(-width);
      };

      // Internal: Double-quotes a string `value`, replacing all ASCII control
      // characters (characters with code unit values between 0 and 31) with
      // their escaped equivalents. This is an implementation of the
      // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
      var unicodePrefix = &quot;\\u00&quot;;
      var quote = function (value) {
        var result = &apos;&quot;&apos;, index = 0, length = value.length, isLarge = length &gt; 10 &amp;&amp; charIndexBuggy, symbols;
        if (isLarge) {
          symbols = value.split(&quot;&quot;);
        }
        for (; index &lt; length; index++) {
          var charCode = value.charCodeAt(index);
          // If the character is a control character, append its Unicode or
          // shorthand escape sequence; otherwise, append the character as-is.
          switch (charCode) {
            case 8: case 9: case 10: case 12: case 13: case 34: case 92:
              result += Escapes[charCode];
              break;
            default:
              if (charCode &lt; 32) {
                result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                break;
              }
              result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];
          }
        }
        return result + &apos;&quot;&apos;;
      };

      // Internal: Recursively serializes an object. Implements the
      // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
      var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
        var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
        try {
          // Necessary for host object support.
          value = object[property];
        } catch (exception) {}
        if (typeof value == &quot;object&quot; &amp;&amp; value) {
          className = getClass.call(value);
          if (className == dateClass &amp;&amp; !isProperty.call(value, &quot;toJSON&quot;)) {
            if (value &gt; -1 / 0 &amp;&amp; value &lt; 1 / 0) {
              // Dates are serialized according to the `Date#toJSON` method
              // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
              // for the ISO 8601 date time string format.
              if (getDay) {
                // Manually compute the year, month, date, hours, minutes,
                // seconds, and milliseconds if the `getUTC*` methods are
                // buggy. Adapted from @Yaffle&apos;s `date-shim` project.
                date = floor(value / 864e5);
                for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) &lt;= date; year++);
                for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) &lt;= date; month++);
                date = 1 + date - getDay(year, month);
                // The `time` value specifies the time within the day (see ES
                // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                // to compute `A modulo B`, as the `%` operator does not
                // correspond to the `modulo` operation for negative numbers.
                time = (value % 864e5 + 864e5) % 864e5;
                // The hours, minutes, seconds, and milliseconds are obtained by
                // decomposing the time within the day. See section 15.9.1.10.
                hours = floor(time / 36e5) % 24;
                minutes = floor(time / 6e4) % 60;
                seconds = floor(time / 1e3) % 60;
                milliseconds = time % 1e3;
              } else {
                year = value.getUTCFullYear();
                month = value.getUTCMonth();
                date = value.getUTCDate();
                hours = value.getUTCHours();
                minutes = value.getUTCMinutes();
                seconds = value.getUTCSeconds();
                milliseconds = value.getUTCMilliseconds();
              }
              // Serialize extended years correctly.
              value = (year &lt;= 0 || year &gt;= 1e4 ? (year &lt; 0 ? &quot;-&quot; : &quot;+&quot;) + toPaddedString(6, year &lt; 0 ? -year : year) : toPaddedString(4, year)) +
                &quot;-&quot; + toPaddedString(2, month + 1) + &quot;-&quot; + toPaddedString(2, date) +
                // Months, dates, hours, minutes, and seconds should have two
                // digits; milliseconds should have three.
                &quot;T&quot; + toPaddedString(2, hours) + &quot;:&quot; + toPaddedString(2, minutes) + &quot;:&quot; + toPaddedString(2, seconds) +
                // Milliseconds are optional in ES 5.0, but required in 5.1.
                &quot;.&quot; + toPaddedString(3, milliseconds) + &quot;Z&quot;;
            } else {
              value = null;
            }
          } else if (typeof value.toJSON == &quot;function&quot; &amp;&amp; ((className != numberClass &amp;&amp; className != stringClass &amp;&amp; className != arrayClass) || isProperty.call(value, &quot;toJSON&quot;))) {
            // Prototype &lt;= 1.6.1 adds non-standard `toJSON` methods to the
            // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
            // ignores all `toJSON` methods on these objects unless they are
            // defined directly on an instance.
            value = value.toJSON(property);
          }
        }
        if (callback) {
          // If a replacement function was provided, call it to obtain the value
          // for serialization.
          value = callback.call(object, property, value);
        }
        if (value === null) {
          return &quot;null&quot;;
        }
        className = getClass.call(value);
        if (className == booleanClass) {
          // Booleans are represented literally.
          return &quot;&quot; + value;
        } else if (className == numberClass) {
          // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
          // `&quot;null&quot;`.
          return value &gt; -1 / 0 &amp;&amp; value &lt; 1 / 0 ? &quot;&quot; + value : &quot;null&quot;;
        } else if (className == stringClass) {
          // Strings are double-quoted and escaped.
          return quote(&quot;&quot; + value);
        }
        // Recursively serialize objects and arrays.
        if (typeof value == &quot;object&quot;) {
          // Check for cyclic structures. This is a linear search; performance
          // is inversely proportional to the number of unique nested objects.
          for (length = stack.length; length--;) {
            if (stack[length] === value) {
              // Cyclic structures cannot be serialized by `JSON.stringify`.
              throw TypeError();
            }
          }
          // Add the object to the stack of traversed objects.
          stack.push(value);
          results = [];
          // Save the current indentation level and indent one additional level.
          prefix = indentation;
          indentation += whitespace;
          if (className == arrayClass) {
            // Recursively serialize array elements.
            for (index = 0, length = value.length; index &lt; length; index++) {
              element = serialize(index, value, callback, properties, whitespace, indentation, stack);
              results.push(element === undef ? &quot;null&quot; : element);
            }
            result = results.length ? (whitespace ? &quot;[\n&quot; + indentation + results.join(&quot;,\n&quot; + indentation) + &quot;\n&quot; + prefix + &quot;]&quot; : (&quot;[&quot; + results.join(&quot;,&quot;) + &quot;]&quot;)) : &quot;[]&quot;;
          } else {
            // Recursively serialize object members. Members are selected from
            // either a user-specified list of property names, or the object
            // itself.
            forEach(properties || value, function (property) {
              var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
              if (element !== undef) {
                // According to ES 5.1 section 15.12.3: &quot;If `gap` {whitespace}
                // is not the empty string, let `member` {quote(property) + &quot;:&quot;}
                // be the concatenation of `member` and the `space` character.&quot;
                // The &quot;`space` character&quot; refers to the literal space
                // character, not the `space` {width} argument provided to
                // `JSON.stringify`.
                results.push(quote(property) + &quot;:&quot; + (whitespace ? &quot; &quot; : &quot;&quot;) + element);
              }
            });
            result = results.length ? (whitespace ? &quot;{\n&quot; + indentation + results.join(&quot;,\n&quot; + indentation) + &quot;\n&quot; + prefix + &quot;}&quot; : (&quot;{&quot; + results.join(&quot;,&quot;) + &quot;}&quot;)) : &quot;{}&quot;;
          }
          // Remove the object from the traversed object stack.
          stack.pop();
          return result;
        }
      };

      // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
      JSON3.stringify = function (source, filter, width) {
        var whitespace, callback, properties, className;
        if (typeof filter == &quot;function&quot; || typeof filter == &quot;object&quot; &amp;&amp; filter) {
          if ((className = getClass.call(filter)) == functionClass) {
            callback = filter;
          } else if (className == arrayClass) {
            // Convert the property names array into a makeshift set.
            properties = {};
            for (var index = 0, length = filter.length, value; index &lt; length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) &amp;&amp; (properties[value] = 1));
          }
        }
        if (width) {
          if ((className = getClass.call(width)) == numberClass) {
            // Convert the `width` to an integer and create a string containing
            // `width` number of space characters.
            if ((width -= width % 1) &gt; 0) {
              for (whitespace = &quot;&quot;, width &gt; 10 &amp;&amp; (width = 10); whitespace.length &lt; width; whitespace += &quot; &quot;);
            }
          } else if (className == stringClass) {
            whitespace = width.length &lt;= 10 ? width : width.slice(0, 10);
          }
        }
        // Opera &lt;= 7.54u2 discards the values associated with empty string keys
        // (`&quot;&quot;`) only if they are used directly within an object member list
        // (e.g., `!(&quot;&quot; in { &quot;&quot;: 1})`).
        return serialize(&quot;&quot;, (value = {}, value[&quot;&quot;] = source, value), callback, properties, whitespace, &quot;&quot;, []);
      };
    }

    // Public: Parses a JSON source string.
    if (!has(&quot;json-parse&quot;)) {
      var fromCharCode = String.fromCharCode;

      // Internal: A map of escaped control characters and their unescaped
      // equivalents.
      var Unescapes = {
        92: &quot;\\&quot;,
        34: &apos;&quot;&apos;,
        47: &quot;/&quot;,
        98: &quot;\b&quot;,
        116: &quot;\t&quot;,
        110: &quot;\n&quot;,
        102: &quot;\f&quot;,
        114: &quot;\r&quot;
      };

      // Internal: Stores the parser state.
      var Index, Source;

      // Internal: Resets the parser state and throws a `SyntaxError`.
      var abort = function() {
        Index = Source = null;
        throw SyntaxError();
      };

      // Internal: Returns the next token, or `&quot;$&quot;` if the parser has reached
      // the end of the source string. A token may be a string, number, `null`
      // literal, or Boolean literal.
      var lex = function () {
        var source = Source, length = source.length, value, begin, position, isSigned, charCode;
        while (Index &lt; length) {
          charCode = source.charCodeAt(Index);
          switch (charCode) {
            case 9: case 10: case 13: case 32:
              // Skip whitespace tokens, including tabs, carriage returns, line
              // feeds, and space characters.
              Index++;
              break;
            case 123: case 125: case 91: case 93: case 58: case 44:
              // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
              // the current position.
              value = charIndexBuggy ? source.charAt(Index) : source[Index];
              Index++;
              return value;
            case 34:
              // `&quot;` delimits a JSON string; advance to the next character and
              // begin parsing the string. String tokens are prefixed with the
              // sentinel `@` character to distinguish them from punctuators and
              // end-of-string tokens.
              for (value = &quot;@&quot;, Index++; Index &lt; length;) {
                charCode = source.charCodeAt(Index);
                if (charCode &lt; 32) {
                  // Unescaped ASCII control characters (those with a code unit
                  // less than the space character) are not permitted.
                  abort();
                } else if (charCode == 92) {
                  // A reverse solidus (`\`) marks the beginning of an escaped
                  // control character (including `&quot;`, `\`, and `/`) or Unicode
                  // escape sequence.
                  charCode = source.charCodeAt(++Index);
                  switch (charCode) {
                    case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                      // Revive escaped control characters.
                      value += Unescapes[charCode];
                      Index++;
                      break;
                    case 117:
                      // `\u` marks the beginning of a Unicode escape sequence.
                      // Advance to the first character and validate the
                      // four-digit code point.
                      begin = ++Index;
                      for (position = Index + 4; Index &lt; position; Index++) {
                        charCode = source.charCodeAt(Index);
                        // A valid sequence comprises four hexdigits (case-
                        // insensitive) that form a single hexadecimal value.
                        if (!(charCode &gt;= 48 &amp;&amp; charCode &lt;= 57 || charCode &gt;= 97 &amp;&amp; charCode &lt;= 102 || charCode &gt;= 65 &amp;&amp; charCode &lt;= 70)) {
                          // Invalid Unicode escape sequence.
                          abort();
                        }
                      }
                      // Revive the escaped character.
                      value += fromCharCode(&quot;0x&quot; + source.slice(begin, Index));
                      break;
                    default:
                      // Invalid escape sequence.
                      abort();
                  }
                } else {
                  if (charCode == 34) {
                    // An unescaped double-quote character marks the end of the
                    // string.
                    break;
                  }
                  charCode = source.charCodeAt(Index);
                  begin = Index;
                  // Optimize for the common case where a string is valid.
                  while (charCode &gt;= 32 &amp;&amp; charCode != 92 &amp;&amp; charCode != 34) {
                    charCode = source.charCodeAt(++Index);
                  }
                  // Append the string as-is.
                  value += source.slice(begin, Index);
                }
              }
              if (source.charCodeAt(Index) == 34) {
                // Advance to the next character and return the revived string.
                Index++;
                return value;
              }
              // Unterminated string.
              abort();
            default:
              // Parse numbers and literals.
              begin = Index;
              // Advance past the negative sign, if one is specified.
              if (charCode == 45) {
                isSigned = true;
                charCode = source.charCodeAt(++Index);
              }
              // Parse an integer or floating-point value.
              if (charCode &gt;= 48 &amp;&amp; charCode &lt;= 57) {
                // Leading zeroes are interpreted as octal literals.
                if (charCode == 48 &amp;&amp; ((charCode = source.charCodeAt(Index + 1)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57)) {
                  // Illegal octal literal.
                  abort();
                }
                isSigned = false;
                // Parse the integer component.
                for (; Index &lt; length &amp;&amp; ((charCode = source.charCodeAt(Index)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57); Index++);
                // Floats cannot contain a leading decimal point; however, this
                // case is already accounted for by the parser.
                if (source.charCodeAt(Index) == 46) {
                  position = ++Index;
                  // Parse the decimal component.
                  for (; position &lt; length &amp;&amp; ((charCode = source.charCodeAt(position)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57); position++);
                  if (position == Index) {
                    // Illegal trailing decimal.
                    abort();
                  }
                  Index = position;
                }
                // Parse exponents. The `e` denoting the exponent is
                // case-insensitive.
                charCode = source.charCodeAt(Index);
                if (charCode == 101 || charCode == 69) {
                  charCode = source.charCodeAt(++Index);
                  // Skip past the sign following the exponent, if one is
                  // specified.
                  if (charCode == 43 || charCode == 45) {
                    Index++;
                  }
                  // Parse the exponential component.
                  for (position = Index; position &lt; length &amp;&amp; ((charCode = source.charCodeAt(position)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57); position++);
                  if (position == Index) {
                    // Illegal empty exponent.
                    abort();
                  }
                  Index = position;
                }
                // Coerce the parsed value to a JavaScript number.
                return +source.slice(begin, Index);
              }
              // A negative sign may only precede numbers.
              if (isSigned) {
                abort();
              }
              // `true`, `false`, and `null` literals.
              if (source.slice(Index, Index + 4) == &quot;true&quot;) {
                Index += 4;
                return true;
              } else if (source.slice(Index, Index + 5) == &quot;false&quot;) {
                Index += 5;
                return false;
              } else if (source.slice(Index, Index + 4) == &quot;null&quot;) {
                Index += 4;
                return null;
              }
              // Unrecognized token.
              abort();
          }
        }
        // Return the sentinel `$` character if the parser has reached the end
        // of the source string.
        return &quot;$&quot;;
      };

      // Internal: Parses a JSON `value` token.
      var get = function (value) {
        var results, hasMembers;
        if (value == &quot;$&quot;) {
          // Unexpected end of input.
          abort();
        }
        if (typeof value == &quot;string&quot;) {
          if ((charIndexBuggy ? value.charAt(0) : value[0]) == &quot;@&quot;) {
            // Remove the sentinel `@` character.
            return value.slice(1);
          }
          // Parse object and array literals.
          if (value == &quot;[&quot;) {
            // Parses a JSON array, returning a new JavaScript array.
            results = [];
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing square bracket marks the end of the array literal.
              if (value == &quot;]&quot;) {
                break;
              }
              // If the array literal contains elements, the current token
              // should be a comma separating the previous element from the
              // next.
              if (hasMembers) {
                if (value == &quot;,&quot;) {
                  value = lex();
                  if (value == &quot;]&quot;) {
                    // Unexpected trailing `,` in array literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each array element.
                  abort();
                }
              }
              // Elisions and leading commas are not permitted.
              if (value == &quot;,&quot;) {
                abort();
              }
              results.push(get(value));
            }
            return results;
          } else if (value == &quot;{&quot;) {
            // Parses a JSON object, returning a new JavaScript object.
            results = {};
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing curly brace marks the end of the object literal.
              if (value == &quot;}&quot;) {
                break;
              }
              // If the object literal contains members, the current token
              // should be a comma separator.
              if (hasMembers) {
                if (value == &quot;,&quot;) {
                  value = lex();
                  if (value == &quot;}&quot;) {
                    // Unexpected trailing `,` in object literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each object member.
                  abort();
                }
              }
              // Leading commas are not permitted, object property names must be
              // double-quoted strings, and a `:` must separate each property
              // name and value.
              if (value == &quot;,&quot; || typeof value != &quot;string&quot; || (charIndexBuggy ? value.charAt(0) : value[0]) != &quot;@&quot; || lex() != &quot;:&quot;) {
                abort();
              }
              results[value.slice(1)] = get(lex());
            }
            return results;
          }
          // Unexpected token encountered.
          abort();
        }
        return value;
      };

      // Internal: Updates a traversed object member.
      var update = function(source, property, callback) {
        var element = walk(source, property, callback);
        if (element === undef) {
          delete source[property];
        } else {
          source[property] = element;
        }
      };

      // Internal: Recursively traverses a parsed JSON object, invoking the
      // `callback` function for each value. This is an implementation of the
      // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
      var walk = function (source, property, callback) {
        var value = source[property], length;
        if (typeof value == &quot;object&quot; &amp;&amp; value) {
          // `forEach` can&apos;t be used to traverse an array in Opera &lt;= 8.54
          // because its `Object#hasOwnProperty` implementation returns `false`
          // for array indices (e.g., `![1, 2, 3].hasOwnProperty(&quot;0&quot;)`).
          if (getClass.call(value) == arrayClass) {
            for (length = value.length; length--;) {
              update(value, length, callback);
            }
          } else {
            forEach(value, function (property) {
              update(value, property, callback);
            });
          }
        }
        return callback.call(source, property, value);
      };

      // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
      JSON3.parse = function (source, callback) {
        var result, value;
        Index = 0;
        Source = &quot;&quot; + source;
        result = get(lex());
        // If a JSON string contains multiple tokens, it is invalid.
        if (lex() != &quot;$&quot;) {
          abort();
        }
        // Reset the parser state.
        Index = Source = null;
        return callback &amp;&amp; getClass.call(callback) == functionClass ? walk((value = {}, value[&quot;&quot;] = result, value), &quot;&quot;, callback) : result;
      };
    }
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}(this));

},{}],50:[function(_dereq_,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i &lt; list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}]},{},[1])
(1)
});</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler" enabled="false">
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="script">
//{scripttype=&quot;text/javascript&quot; src=&quot;https://adarshtest1.messageboxapp.com/socket.io/socket.io.js&quot;}
/*!
 * Socket.IO v2.1.1
 * (c) 2014-2018 Guillermo Rauch
 * Released under the MIT License.
 */
!function(t,e){&quot;object&quot;==typeof exports&amp;&amp;&quot;object&quot;==typeof module?module.exports=e():&quot;function&quot;==typeof define&amp;&amp;define.amd?define([],e):&quot;object&quot;==typeof exports?exports.io=e():t.io=e()}(this,function(){return function(t){function e(r){if(n[r])return n[r].exports;var o=n[r]={exports:{},id:r,loaded:!1};return t[r].call(o.exports,o,o.exports,e),o.loaded=!0,o.exports}var n={};return e.m=t,e.c=n,e.p=&quot;&quot;,e(0)}([function(t,e,n){&quot;use strict&quot;;function r(t,e){&quot;object&quot;===(&quot;undefined&quot;==typeof t?&quot;undefined&quot;:o(t))&amp;&amp;(e=t,t=void 0),e=e||{};var n,r=i(t),s=r.source,p=r.id,h=r.path,f=u[p]&amp;&amp;h in u[p].nsps,l=e.forceNew||e[&quot;force new connection&quot;]||!1===e.multiplex||f;return l?(c(&quot;ignoring socket cache for %s&quot;,s),n=a(s,e)):(u[p]||(c(&quot;new io instance for %s&quot;,s),u[p]=a(s,e)),n=u[p]),r.query&amp;&amp;!e.query&amp;&amp;(e.query=r.query),n.socket(r.path,e)}var o=&quot;function&quot;==typeof Symbol&amp;&amp;&quot;symbol&quot;==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&amp;&amp;&quot;function&quot;==typeof Symbol&amp;&amp;t.constructor===Symbol&amp;&amp;t!==Symbol.prototype?&quot;symbol&quot;:typeof t},i=n(1),s=n(7),a=n(12),c=n(3)(&quot;socket.io-client&quot;);t.exports=e=r;var u=e.managers={};e.protocol=s.protocol,e.connect=r,e.Manager=n(12),e.Socket=n(37)},function(t,e,n){(function(e){&quot;use strict&quot;;function r(t,n){var r=t;n=n||e.location,null==t&amp;&amp;(t=n.protocol+&quot;//&quot;+n.host),&quot;string&quot;==typeof t&amp;&amp;(&quot;/&quot;===t.charAt(0)&amp;&amp;(t=&quot;/&quot;===t.charAt(1)?n.protocol+t:n.host+t),/^(https?|wss?):\/\//.test(t)||(i(&quot;protocol-less url %s&quot;,t),t=&quot;undefined&quot;!=typeof n?n.protocol+&quot;//&quot;+t:&quot;https://&quot;+t),i(&quot;parse %s&quot;,t),r=o(t)),r.port||(/^(http|ws)$/.test(r.protocol)?r.port=&quot;80&quot;:/^(http|ws)s$/.test(r.protocol)&amp;&amp;(r.port=&quot;443&quot;)),r.path=r.path||&quot;/&quot;;var s=r.host.indexOf(&quot;:&quot;)!==-1,a=s?&quot;[&quot;+r.host+&quot;]&quot;:r.host;return r.id=r.protocol+&quot;://&quot;+a+&quot;:&quot;+r.port,r.href=r.protocol+&quot;://&quot;+a+(n&amp;&amp;n.port===r.port?&quot;&quot;:&quot;:&quot;+r.port),r}var o=n(2),i=n(3)(&quot;socket.io-client:url&quot;);t.exports=r}).call(e,function(){return this}())},function(t,e){var n=/^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,r=[&quot;source&quot;,&quot;protocol&quot;,&quot;authority&quot;,&quot;userInfo&quot;,&quot;user&quot;,&quot;password&quot;,&quot;host&quot;,&quot;port&quot;,&quot;relative&quot;,&quot;path&quot;,&quot;directory&quot;,&quot;file&quot;,&quot;query&quot;,&quot;anchor&quot;];t.exports=function(t){var e=t,o=t.indexOf(&quot;[&quot;),i=t.indexOf(&quot;]&quot;);o!=-1&amp;&amp;i!=-1&amp;&amp;(t=t.substring(0,o)+t.substring(o,i).replace(/:/g,&quot;;&quot;)+t.substring(i,t.length));for(var s=n.exec(t||&quot;&quot;),a={},c=14;c--;)a[r[c]]=s[c]||&quot;&quot;;return o!=-1&amp;&amp;i!=-1&amp;&amp;(a.source=e,a.host=a.host.substring(1,a.host.length-1).replace(/;/g,&quot;:&quot;),a.authority=a.authority.replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).replace(/;/g,&quot;:&quot;),a.ipv6uri=!0),a}},function(t,e,n){(function(r){function o(){return!(&quot;undefined&quot;==typeof window||!window.process||&quot;renderer&quot;!==window.process.type)||(&quot;undefined&quot;==typeof navigator||!navigator.userAgent||!navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))&amp;&amp;(&quot;undefined&quot;!=typeof document&amp;&amp;document.documentElement&amp;&amp;document.documentElement.style&amp;&amp;document.documentElement.style.WebkitAppearance||&quot;undefined&quot;!=typeof window&amp;&amp;window.console&amp;&amp;(window.console.firebug||window.console.exception&amp;&amp;window.console.table)||&quot;undefined&quot;!=typeof navigator&amp;&amp;navigator.userAgent&amp;&amp;navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&amp;&amp;parseInt(RegExp.$1,10)&gt;=31||&quot;undefined&quot;!=typeof navigator&amp;&amp;navigator.userAgent&amp;&amp;navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))}function i(t){var n=this.useColors;if(t[0]=(n?&quot;%c&quot;:&quot;&quot;)+this.namespace+(n?&quot; %c&quot;:&quot; &quot;)+t[0]+(n?&quot;%c &quot;:&quot; &quot;)+&quot;+&quot;+e.humanize(this.diff),n){var r=&quot;color: &quot;+this.color;t.splice(1,0,r,&quot;color: inherit&quot;);var o=0,i=0;t[0].replace(/%[a-zA-Z%]/g,function(t){&quot;%%&quot;!==t&amp;&amp;(o++,&quot;%c&quot;===t&amp;&amp;(i=o))}),t.splice(i,0,r)}}function s(){return&quot;object&quot;==typeof console&amp;&amp;console.log&amp;&amp;Function.prototype.apply.call(console.log,console,arguments)}function a(t){try{null==t?e.storage.removeItem(&quot;debug&quot;):e.storage.debug=t}catch(n){}}function c(){var t;try{t=e.storage.debug}catch(n){}return!t&amp;&amp;&quot;undefined&quot;!=typeof r&amp;&amp;&quot;env&quot;in r&amp;&amp;(t=r.env.DEBUG),t}function u(){try{return window.localStorage}catch(t){}}e=t.exports=n(5),e.log=s,e.formatArgs=i,e.save=a,e.load=c,e.useColors=o,e.storage=&quot;undefined&quot;!=typeof chrome&amp;&amp;&quot;undefined&quot;!=typeof chrome.storage?chrome.storage.local:u(),e.colors=[&quot;#0000CC&quot;,&quot;#0000FF&quot;,&quot;#0033CC&quot;,&quot;#0033FF&quot;,&quot;#0066CC&quot;,&quot;#0066FF&quot;,&quot;#0099CC&quot;,&quot;#0099FF&quot;,&quot;#00CC00&quot;,&quot;#00CC33&quot;,&quot;#00CC66&quot;,&quot;#00CC99&quot;,&quot;#00CCCC&quot;,&quot;#00CCFF&quot;,&quot;#3300CC&quot;,&quot;#3300FF&quot;,&quot;#3333CC&quot;,&quot;#3333FF&quot;,&quot;#3366CC&quot;,&quot;#3366FF&quot;,&quot;#3399CC&quot;,&quot;#3399FF&quot;,&quot;#33CC00&quot;,&quot;#33CC33&quot;,&quot;#33CC66&quot;,&quot;#33CC99&quot;,&quot;#33CCCC&quot;,&quot;#33CCFF&quot;,&quot;#6600CC&quot;,&quot;#6600FF&quot;,&quot;#6633CC&quot;,&quot;#6633FF&quot;,&quot;#66CC00&quot;,&quot;#66CC33&quot;,&quot;#9900CC&quot;,&quot;#9900FF&quot;,&quot;#9933CC&quot;,&quot;#9933FF&quot;,&quot;#99CC00&quot;,&quot;#99CC33&quot;,&quot;#CC0000&quot;,&quot;#CC0033&quot;,&quot;#CC0066&quot;,&quot;#CC0099&quot;,&quot;#CC00CC&quot;,&quot;#CC00FF&quot;,&quot;#CC3300&quot;,&quot;#CC3333&quot;,&quot;#CC3366&quot;,&quot;#CC3399&quot;,&quot;#CC33CC&quot;,&quot;#CC33FF&quot;,&quot;#CC6600&quot;,&quot;#CC6633&quot;,&quot;#CC9900&quot;,&quot;#CC9933&quot;,&quot;#CCCC00&quot;,&quot;#CCCC33&quot;,&quot;#FF0000&quot;,&quot;#FF0033&quot;,&quot;#FF0066&quot;,&quot;#FF0099&quot;,&quot;#FF00CC&quot;,&quot;#FF00FF&quot;,&quot;#FF3300&quot;,&quot;#FF3333&quot;,&quot;#FF3366&quot;,&quot;#FF3399&quot;,&quot;#FF33CC&quot;,&quot;#FF33FF&quot;,&quot;#FF6600&quot;,&quot;#FF6633&quot;,&quot;#FF9900&quot;,&quot;#FF9933&quot;,&quot;#FFCC00&quot;,&quot;#FFCC33&quot;],e.formatters.j=function(t){try{return JSON.stringify(t)}catch(e){return&quot;[UnexpectedJSONParseError]: &quot;+e.message}},e.enable(c())}).call(e,n(4))},function(t,e){function n(){throw new Error(&quot;setTimeout has not been defined&quot;)}function r(){throw new Error(&quot;clearTimeout has not been defined&quot;)}function o(t){if(p===setTimeout)return setTimeout(t,0);if((p===n||!p)&amp;&amp;setTimeout)return p=setTimeout,setTimeout(t,0);try{return p(t,0)}catch(e){try{return p.call(null,t,0)}catch(e){return p.call(this,t,0)}}}function i(t){if(h===clearTimeout)return clearTimeout(t);if((h===r||!h)&amp;&amp;clearTimeout)return h=clearTimeout,clearTimeout(t);try{return h(t)}catch(e){try{return h.call(null,t)}catch(e){return h.call(this,t)}}}function s(){y&amp;&amp;l&amp;&amp;(y=!1,l.length?d=l.concat(d):m=-1,d.length&amp;&amp;a())}function a(){if(!y){var t=o(s);y=!0;for(var e=d.length;e;){for(l=d,d=[];++m&lt;e;)l&amp;&amp;l[m].run();m=-1,e=d.length}l=null,y=!1,i(t)}}function c(t,e){this.fun=t,this.array=e}function u(){}var p,h,f=t.exports={};!function(){try{p=&quot;function&quot;==typeof setTimeout?setTimeout:n}catch(t){p=n}try{h=&quot;function&quot;==typeof clearTimeout?clearTimeout:r}catch(t){h=r}}();var l,d=[],y=!1,m=-1;f.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length&gt;1)for(var n=1;n&lt;arguments.length;n++)e[n-1]=arguments[n];d.push(new c(t,e)),1!==d.length||y||o(a)},c.prototype.run=function(){this.fun.apply(null,this.array)},f.title=&quot;browser&quot;,f.browser=!0,f.env={},f.argv=[],f.version=&quot;&quot;,f.versions={},f.on=u,f.addListener=u,f.once=u,f.off=u,f.removeListener=u,f.removeAllListeners=u,f.emit=u,f.prependListener=u,f.prependOnceListener=u,f.listeners=function(t){return[]},f.binding=function(t){throw new Error(&quot;process.binding is not supported&quot;)},f.cwd=function(){return&quot;/&quot;},f.chdir=function(t){throw new Error(&quot;process.chdir is not supported&quot;)},f.umask=function(){return 0}},function(t,e,n){function r(t){var n,r=0;for(n in t)r=(r&lt;&lt;5)-r+t.charCodeAt(n),r|=0;return e.colors[Math.abs(r)%e.colors.length]}function o(t){function n(){if(n.enabled){var t=n,r=+new Date,i=r-(o||r);t.diff=i,t.prev=o,t.curr=r,o=r;for(var s=new Array(arguments.length),a=0;a&lt;s.length;a++)s[a]=arguments[a];s[0]=e.coerce(s[0]),&quot;string&quot;!=typeof s[0]&amp;&amp;s.unshift(&quot;%O&quot;);var c=0;s[0]=s[0].replace(/%([a-zA-Z%])/g,function(n,r){if(&quot;%%&quot;===n)return n;c++;var o=e.formatters[r];if(&quot;function&quot;==typeof o){var i=s[c];n=o.call(t,i),s.splice(c,1),c--}return n}),e.formatArgs.call(t,s);var u=n.log||e.log||console.log.bind(console);u.apply(t,s)}}var o;return n.namespace=t,n.enabled=e.enabled(t),n.useColors=e.useColors(),n.color=r(t),n.destroy=i,&quot;function&quot;==typeof e.init&amp;&amp;e.init(n),e.instances.push(n),n}function i(){var t=e.instances.indexOf(this);return t!==-1&amp;&amp;(e.instances.splice(t,1),!0)}function s(t){e.save(t),e.names=[],e.skips=[];var n,r=(&quot;string&quot;==typeof t?t:&quot;&quot;).split(/[\s,]+/),o=r.length;for(n=0;n&lt;o;n++)r[n]&amp;&amp;(t=r[n].replace(/\*/g,&quot;.*?&quot;),&quot;-&quot;===t[0]?e.skips.push(new RegExp(&quot;^&quot;+t.substr(1)+&quot;$&quot;)):e.names.push(new RegExp(&quot;^&quot;+t+&quot;$&quot;)));for(n=0;n&lt;e.instances.length;n++){var i=e.instances[n];i.enabled=e.enabled(i.namespace)}}function a(){e.enable(&quot;&quot;)}function c(t){if(&quot;*&quot;===t[t.length-1])return!0;var n,r;for(n=0,r=e.skips.length;n&lt;r;n++)if(e.skips[n].test(t))return!1;for(n=0,r=e.names.length;n&lt;r;n++)if(e.names[n].test(t))return!0;return!1}function u(t){return t instanceof Error?t.stack||t.message:t}e=t.exports=o.debug=o[&quot;default&quot;]=o,e.coerce=u,e.disable=a,e.enable=s,e.enabled=c,e.humanize=n(6),e.instances=[],e.names=[],e.skips=[],e.formatters={}},function(t,e){function n(t){if(t=String(t),!(t.length&gt;100)){var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(t);if(e){var n=parseFloat(e[1]),r=(e[2]||&quot;ms&quot;).toLowerCase();switch(r){case&quot;years&quot;:case&quot;year&quot;:case&quot;yrs&quot;:case&quot;yr&quot;:case&quot;y&quot;:return n*p;case&quot;days&quot;:case&quot;day&quot;:case&quot;d&quot;:return n*u;case&quot;hours&quot;:case&quot;hour&quot;:case&quot;hrs&quot;:case&quot;hr&quot;:case&quot;h&quot;:return n*c;case&quot;minutes&quot;:case&quot;minute&quot;:case&quot;mins&quot;:case&quot;min&quot;:case&quot;m&quot;:return n*a;case&quot;seconds&quot;:case&quot;second&quot;:case&quot;secs&quot;:case&quot;sec&quot;:case&quot;s&quot;:return n*s;case&quot;milliseconds&quot;:case&quot;millisecond&quot;:case&quot;msecs&quot;:case&quot;msec&quot;:case&quot;ms&quot;:return n;default:return}}}}function r(t){return t&gt;=u?Math.round(t/u)+&quot;d&quot;:t&gt;=c?Math.round(t/c)+&quot;h&quot;:t&gt;=a?Math.round(t/a)+&quot;m&quot;:t&gt;=s?Math.round(t/s)+&quot;s&quot;:t+&quot;ms&quot;}function o(t){return i(t,u,&quot;day&quot;)||i(t,c,&quot;hour&quot;)||i(t,a,&quot;minute&quot;)||i(t,s,&quot;second&quot;)||t+&quot; ms&quot;}function i(t,e,n){if(!(t&lt;e))return t&lt;1.5*e?Math.floor(t/e)+&quot; &quot;+n:Math.ceil(t/e)+&quot; &quot;+n+&quot;s&quot;}var s=1e3,a=60*s,c=60*a,u=24*c,p=365.25*u;t.exports=function(t,e){e=e||{};var i=typeof t;if(&quot;string&quot;===i&amp;&amp;t.length&gt;0)return n(t);if(&quot;number&quot;===i&amp;&amp;isNaN(t)===!1)return e[&quot;long&quot;]?o(t):r(t);throw new Error(&quot;val is not a non-empty string or a valid number. val=&quot;+JSON.stringify(t))}},function(t,e,n){function r(){}function o(t){var n=&quot;&quot;+t.type;if(e.BINARY_EVENT!==t.type&amp;&amp;e.BINARY_ACK!==t.type||(n+=t.attachments+&quot;-&quot;),t.nsp&amp;&amp;&quot;/&quot;!==t.nsp&amp;&amp;(n+=t.nsp+&quot;,&quot;),null!=t.id&amp;&amp;(n+=t.id),null!=t.data){var r=i(t.data);if(r===!1)return g;n+=r}return f(&quot;encoded %j as %s&quot;,t,n),n}function i(t){try{return JSON.stringify(t)}catch(e){return!1}}function s(t,e){function n(t){var n=d.deconstructPacket(t),r=o(n.packet),i=n.buffers;i.unshift(r),e(i)}d.removeBlobs(t,n)}function a(){this.reconstructor=null}function c(t){var n=0,r={type:Number(t.charAt(0))};if(null==e.types[r.type])return h(&quot;unknown packet type &quot;+r.type);if(e.BINARY_EVENT===r.type||e.BINARY_ACK===r.type){for(var o=&quot;&quot;;&quot;-&quot;!==t.charAt(++n)&amp;&amp;(o+=t.charAt(n),n!=t.length););if(o!=Number(o)||&quot;-&quot;!==t.charAt(n))throw new Error(&quot;Illegal attachments&quot;);r.attachments=Number(o)}if(&quot;/&quot;===t.charAt(n+1))for(r.nsp=&quot;&quot;;++n;){var i=t.charAt(n);if(&quot;,&quot;===i)break;if(r.nsp+=i,n===t.length)break}else r.nsp=&quot;/&quot;;var s=t.charAt(n+1);if(&quot;&quot;!==s&amp;&amp;Number(s)==s){for(r.id=&quot;&quot;;++n;){var i=t.charAt(n);if(null==i||Number(i)!=i){--n;break}if(r.id+=t.charAt(n),n===t.length)break}r.id=Number(r.id)}if(t.charAt(++n)){var a=u(t.substr(n)),c=a!==!1&amp;&amp;(r.type===e.ERROR||y(a));if(!c)return h(&quot;invalid payload&quot;);r.data=a}return f(&quot;decoded %s as %j&quot;,t,r),r}function u(t){try{return JSON.parse(t)}catch(e){return!1}}function p(t){this.reconPack=t,this.buffers=[]}function h(t){return{type:e.ERROR,data:&quot;parser error: &quot;+t}}var f=n(3)(&quot;socket.io-parser&quot;),l=n(8),d=n(9),y=n(10),m=n(11);e.protocol=4,e.types=[&quot;CONNECT&quot;,&quot;DISCONNECT&quot;,&quot;EVENT&quot;,&quot;ACK&quot;,&quot;ERROR&quot;,&quot;BINARY_EVENT&quot;,&quot;BINARY_ACK&quot;],e.CONNECT=0,e.DISCONNECT=1,e.EVENT=2,e.ACK=3,e.ERROR=4,e.BINARY_EVENT=5,e.BINARY_ACK=6,e.Encoder=r,e.Decoder=a;var g=e.ERROR+&apos;&quot;encode error&quot;&apos;;r.prototype.encode=function(t,n){if(f(&quot;encoding packet %j&quot;,t),e.BINARY_EVENT===t.type||e.BINARY_ACK===t.type)s(t,n);else{var r=o(t);n([r])}},l(a.prototype),a.prototype.add=function(t){var n;if(&quot;string&quot;==typeof t)n=c(t),e.BINARY_EVENT===n.type||e.BINARY_ACK===n.type?(this.reconstructor=new p(n),0===this.reconstructor.reconPack.attachments&amp;&amp;this.emit(&quot;decoded&quot;,n)):this.emit(&quot;decoded&quot;,n);else{if(!m(t)&amp;&amp;!t.base64)throw new Error(&quot;Unknown type: &quot;+t);if(!this.reconstructor)throw new Error(&quot;got binary data when not reconstructing a packet&quot;);n=this.reconstructor.takeBinaryData(t),n&amp;&amp;(this.reconstructor=null,this.emit(&quot;decoded&quot;,n))}},a.prototype.destroy=function(){this.reconstructor&amp;&amp;this.reconstructor.finishedReconstruction()},p.prototype.takeBinaryData=function(t){if(this.buffers.push(t),this.buffers.length===this.reconPack.attachments){var e=d.reconstructPacket(this.reconPack,this.buffers);return this.finishedReconstruction(),e}return null},p.prototype.finishedReconstruction=function(){this.reconPack=null,this.buffers=[]}},function(t,e,n){function r(t){if(t)return o(t)}function o(t){for(var e in r.prototype)t[e]=r.prototype[e];return t}t.exports=r,r.prototype.on=r.prototype.addEventListener=function(t,e){return this._callbacks=this._callbacks||{},(this._callbacks[&quot;$&quot;+t]=this._callbacks[&quot;$&quot;+t]||[]).push(e),this},r.prototype.once=function(t,e){function n(){this.off(t,n),e.apply(this,arguments)}return n.fn=e,this.on(t,n),this},r.prototype.off=r.prototype.removeListener=r.prototype.removeAllListeners=r.prototype.removeEventListener=function(t,e){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var n=this._callbacks[&quot;$&quot;+t];if(!n)return this;if(1==arguments.length)return delete this._callbacks[&quot;$&quot;+t],this;for(var r,o=0;o&lt;n.length;o++)if(r=n[o],r===e||r.fn===e){n.splice(o,1);break}return this},r.prototype.emit=function(t){this._callbacks=this._callbacks||{};var e=[].slice.call(arguments,1),n=this._callbacks[&quot;$&quot;+t];if(n){n=n.slice(0);for(var r=0,o=n.length;r&lt;o;++r)n[r].apply(this,e)}return this},r.prototype.listeners=function(t){return this._callbacks=this._callbacks||{},this._callbacks[&quot;$&quot;+t]||[]},r.prototype.hasListeners=function(t){return!!this.listeners(t).length}},function(t,e,n){(function(t){function r(t,e){if(!t)return t;if(s(t)){var n={_placeholder:!0,num:e.length};return e.push(t),n}if(i(t)){for(var o=new Array(t.length),a=0;a&lt;t.length;a++)o[a]=r(t[a],e);return o}if(&quot;object&quot;==typeof t&amp;&amp;!(t instanceof Date)){var o={};for(var c in t)o[c]=r(t[c],e);return o}return t}function o(t,e){if(!t)return t;if(t&amp;&amp;t._placeholder)return e[t.num];if(i(t))for(var n=0;n&lt;t.length;n++)t[n]=o(t[n],e);else if(&quot;object&quot;==typeof t)for(var r in t)t[r]=o(t[r],e);return t}var i=n(10),s=n(11),a=Object.prototype.toString,c=&quot;function&quot;==typeof t.Blob||&quot;[object BlobConstructor]&quot;===a.call(t.Blob),u=&quot;function&quot;==typeof t.File||&quot;[object FileConstructor]&quot;===a.call(t.File);e.deconstructPacket=function(t){var e=[],n=t.data,o=t;return o.data=r(n,e),o.attachments=e.length,{packet:o,buffers:e}},e.reconstructPacket=function(t,e){return t.data=o(t.data,e),t.attachments=void 0,t},e.removeBlobs=function(t,e){function n(t,a,p){if(!t)return t;if(c&amp;&amp;t instanceof Blob||u&amp;&amp;t instanceof File){r++;var h=new FileReader;h.onload=function(){p?p[a]=this.result:o=this.result,--r||e(o)},h.readAsArrayBuffer(t)}else if(i(t))for(var f=0;f&lt;t.length;f++)n(t[f],f,t);else if(&quot;object&quot;==typeof t&amp;&amp;!s(t))for(var l in t)n(t[l],l,t)}var r=0,o=t;n(o),r||e(o)}}).call(e,function(){return this}())},function(t,e){var n={}.toString;t.exports=Array.isArray||function(t){return&quot;[object Array]&quot;==n.call(t)}},function(t,e){(function(e){function n(t){return r&amp;&amp;e.Buffer.isBuffer(t)||o&amp;&amp;(t instanceof e.ArrayBuffer||i(t))}t.exports=n;var r=&quot;function&quot;==typeof e.Buffer&amp;&amp;&quot;function&quot;==typeof e.Buffer.isBuffer,o=&quot;function&quot;==typeof e.ArrayBuffer,i=function(){return o&amp;&amp;&quot;function&quot;==typeof e.ArrayBuffer.isView?e.ArrayBuffer.isView:function(t){return t.buffer instanceof e.ArrayBuffer}}()}).call(e,function(){return this}())},function(t,e,n){&quot;use strict&quot;;function r(t,e){if(!(this instanceof r))return new r(t,e);t&amp;&amp;&quot;object&quot;===(&quot;undefined&quot;==typeof t?&quot;undefined&quot;:o(t))&amp;&amp;(e=t,t=void 0),e=e||{},e.path=e.path||&quot;/socket.io&quot;,this.nsps={},this.subs=[],this.opts=e,this.reconnection(e.reconnection!==!1),this.reconnectionAttempts(e.reconnectionAttempts||1/0),this.reconnectionDelay(e.reconnectionDelay||1e3),this.reconnectionDelayMax(e.reconnectionDelayMax||5e3),this.randomizationFactor(e.randomizationFactor||.5),this.backoff=new l({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()}),this.timeout(null==e.timeout?2e4:e.timeout),this.readyState=&quot;closed&quot;,this.uri=t,this.connecting=[],this.lastPing=null,this.encoding=!1,this.packetBuffer=[];var n=e.parser||c;this.encoder=new n.Encoder,this.decoder=new n.Decoder,this.autoConnect=e.autoConnect!==!1,this.autoConnect&amp;&amp;this.open()}var o=&quot;function&quot;==typeof Symbol&amp;&amp;&quot;symbol&quot;==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&amp;&amp;&quot;function&quot;==typeof Symbol&amp;&amp;t.constructor===Symbol&amp;&amp;t!==Symbol.prototype?&quot;symbol&quot;:typeof t},i=n(13),s=n(37),a=n(8),c=n(7),u=n(39),p=n(40),h=n(3)(&quot;socket.io-client:manager&quot;),f=n(36),l=n(41),d=Object.prototype.hasOwnProperty;t.exports=r,r.prototype.emitAll=function(){this.emit.apply(this,arguments);for(var t in this.nsps)d.call(this.nsps,t)&amp;&amp;this.nsps[t].emit.apply(this.nsps[t],arguments)},r.prototype.updateSocketIds=function(){for(var t in this.nsps)d.call(this.nsps,t)&amp;&amp;(this.nsps[t].id=this.generateId(t))},r.prototype.generateId=function(t){return(&quot;/&quot;===t?&quot;&quot;:t+&quot;#&quot;)+this.engine.id},a(r.prototype),r.prototype.reconnection=function(t){return arguments.length?(this._reconnection=!!t,this):this._reconnection},r.prototype.reconnectionAttempts=function(t){return arguments.length?(this._reconnectionAttempts=t,this):this._reconnectionAttempts},r.prototype.reconnectionDelay=function(t){return arguments.length?(this._reconnectionDelay=t,this.backoff&amp;&amp;this.backoff.setMin(t),this):this._reconnectionDelay},r.prototype.randomizationFactor=function(t){return arguments.length?(this._randomizationFactor=t,this.backoff&amp;&amp;this.backoff.setJitter(t),this):this._randomizationFactor},r.prototype.reconnectionDelayMax=function(t){return arguments.length?(this._reconnectionDelayMax=t,this.backoff&amp;&amp;this.backoff.setMax(t),this):this._reconnectionDelayMax},r.prototype.timeout=function(t){return arguments.length?(this._timeout=t,this):this._timeout},r.prototype.maybeReconnectOnOpen=function(){!this.reconnecting&amp;&amp;this._reconnection&amp;&amp;0===this.backoff.attempts&amp;&amp;this.reconnect()},r.prototype.open=r.prototype.connect=function(t,e){if(h(&quot;readyState %s&quot;,this.readyState),~this.readyState.indexOf(&quot;open&quot;))return this;h(&quot;opening %s&quot;,this.uri),this.engine=i(this.uri,this.opts);var n=this.engine,r=this;this.readyState=&quot;opening&quot;,this.skipReconnect=!1;var o=u(n,&quot;open&quot;,function(){r.onopen(),t&amp;&amp;t()}),s=u(n,&quot;error&quot;,function(e){if(h(&quot;connect_error&quot;),r.cleanup(),r.readyState=&quot;closed&quot;,r.emitAll(&quot;connect_error&quot;,e),t){var n=new Error(&quot;Connection error&quot;);n.data=e,t(n)}else r.maybeReconnectOnOpen()});if(!1!==this._timeout){var a=this._timeout;h(&quot;connect attempt will timeout after %d&quot;,a);var c=setTimeout(function(){h(&quot;connect attempt timed out after %d&quot;,a),o.destroy(),n.close(),n.emit(&quot;error&quot;,&quot;timeout&quot;),r.emitAll(&quot;connect_timeout&quot;,a)},a);this.subs.push({destroy:function(){clearTimeout(c)}})}return this.subs.push(o),this.subs.push(s),this},r.prototype.onopen=function(){h(&quot;open&quot;),this.cleanup(),this.readyState=&quot;open&quot;,this.emit(&quot;open&quot;);var t=this.engine;this.subs.push(u(t,&quot;data&quot;,p(this,&quot;ondata&quot;))),this.subs.push(u(t,&quot;ping&quot;,p(this,&quot;onping&quot;))),this.subs.push(u(t,&quot;pong&quot;,p(this,&quot;onpong&quot;))),this.subs.push(u(t,&quot;error&quot;,p(this,&quot;onerror&quot;))),this.subs.push(u(t,&quot;close&quot;,p(this,&quot;onclose&quot;))),this.subs.push(u(this.decoder,&quot;decoded&quot;,p(this,&quot;ondecoded&quot;)))},r.prototype.onping=function(){this.lastPing=new Date,this.emitAll(&quot;ping&quot;)},r.prototype.onpong=function(){this.emitAll(&quot;pong&quot;,new Date-this.lastPing)},r.prototype.ondata=function(t){this.decoder.add(t)},r.prototype.ondecoded=function(t){this.emit(&quot;packet&quot;,t)},r.prototype.onerror=function(t){h(&quot;error&quot;,t),this.emitAll(&quot;error&quot;,t)},r.prototype.socket=function(t,e){function n(){~f(o.connecting,r)||o.connecting.push(r)}var r=this.nsps[t];if(!r){r=new s(this,t,e),this.nsps[t]=r;var o=this;r.on(&quot;connecting&quot;,n),r.on(&quot;connect&quot;,function(){r.id=o.generateId(t)}),this.autoConnect&amp;&amp;n()}return r},r.prototype.destroy=function(t){var e=f(this.connecting,t);~e&amp;&amp;this.connecting.splice(e,1),this.connecting.length||this.close()},r.prototype.packet=function(t){h(&quot;writing packet %j&quot;,t);var e=this;t.query&amp;&amp;0===t.type&amp;&amp;(t.nsp+=&quot;?&quot;+t.query),e.encoding?e.packetBuffer.push(t):(e.encoding=!0,this.encoder.encode(t,function(n){for(var r=0;r&lt;n.length;r++)e.engine.write(n[r],t.options);e.encoding=!1,e.processPacketQueue()}))},r.prototype.processPacketQueue=function(){if(this.packetBuffer.length&gt;0&amp;&amp;!this.encoding){var t=this.packetBuffer.shift();this.packet(t)}},r.prototype.cleanup=function(){h(&quot;cleanup&quot;);for(var t=this.subs.length,e=0;e&lt;t;e++){var n=this.subs.shift();n.destroy()}this.packetBuffer=[],this.encoding=!1,this.lastPing=null,this.decoder.destroy()},r.prototype.close=r.prototype.disconnect=function(){h(&quot;disconnect&quot;),this.skipReconnect=!0,this.reconnecting=!1,&quot;opening&quot;===this.readyState&amp;&amp;this.cleanup(),this.backoff.reset(),this.readyState=&quot;closed&quot;,this.engine&amp;&amp;this.engine.close()},r.prototype.onclose=function(t){h(&quot;onclose&quot;),this.cleanup(),this.backoff.reset(),this.readyState=&quot;closed&quot;,this.emit(&quot;close&quot;,t),this._reconnection&amp;&amp;!this.skipReconnect&amp;&amp;this.reconnect()},r.prototype.reconnect=function(){if(this.reconnecting||this.skipReconnect)return this;var t=this;if(this.backoff.attempts&gt;=this._reconnectionAttempts)h(&quot;reconnect failed&quot;),this.backoff.reset(),this.emitAll(&quot;reconnect_failed&quot;),this.reconnecting=!1;else{var e=this.backoff.duration();h(&quot;will wait %dms before reconnect attempt&quot;,e),this.reconnecting=!0;var n=setTimeout(function(){t.skipReconnect||(h(&quot;attempting reconnect&quot;),t.emitAll(&quot;reconnect_attempt&quot;,t.backoff.attempts),t.emitAll(&quot;reconnecting&quot;,t.backoff.attempts),t.skipReconnect||t.open(function(e){e?(h(&quot;reconnect attempt error&quot;),t.reconnecting=!1,t.reconnect(),t.emitAll(&quot;reconnect_error&quot;,e.data)):(h(&quot;reconnect success&quot;),t.onreconnect())}))},e);this.subs.push({destroy:function(){clearTimeout(n)}})}},r.prototype.onreconnect=function(){var t=this.backoff.attempts;this.reconnecting=!1,this.backoff.reset(),this.updateSocketIds(),this.emitAll(&quot;reconnect&quot;,t)}},function(t,e,n){t.exports=n(14),t.exports.parser=n(21)},function(t,e,n){(function(e){function r(t,n){if(!(this instanceof r))return new r(t,n);n=n||{},t&amp;&amp;&quot;object&quot;==typeof t&amp;&amp;(n=t,t=null),t?(t=p(t),n.hostname=t.host,n.secure=&quot;https&quot;===t.protocol||&quot;wss&quot;===t.protocol,n.port=t.port,t.query&amp;&amp;(n.query=t.query)):n.host&amp;&amp;(n.hostname=p(n.host).host),this.secure=null!=n.secure?n.secure:e.location&amp;&amp;&quot;https:&quot;===location.protocol,n.hostname&amp;&amp;!n.port&amp;&amp;(n.port=this.secure?&quot;443&quot;:&quot;80&quot;),this.agent=n.agent||!1,this.hostname=n.hostname||(e.location?location.hostname:&quot;localhost&quot;),this.port=n.port||(e.location&amp;&amp;location.port?location.port:this.secure?443:80),this.query=n.query||{},&quot;string&quot;==typeof this.query&amp;&amp;(this.query=h.decode(this.query)),this.upgrade=!1!==n.upgrade,this.path=(n.path||&quot;/engine.io&quot;).replace(/\/$/,&quot;&quot;)+&quot;/&quot;,this.forceJSONP=!!n.forceJSONP,this.jsonp=!1!==n.jsonp,this.forceBase64=!!n.forceBase64,this.enablesXDR=!!n.enablesXDR,this.timestampParam=n.timestampParam||&quot;t&quot;,this.timestampRequests=n.timestampRequests,this.transports=n.transports||[&quot;polling&quot;,&quot;websocket&quot;],this.transportOptions=n.transportOptions||{},this.readyState=&quot;&quot;,this.writeBuffer=[],this.prevBufferLen=0,this.policyPort=n.policyPort||843,this.rememberUpgrade=n.rememberUpgrade||!1,this.binaryType=null,this.onlyBinaryUpgrades=n.onlyBinaryUpgrades,this.perMessageDeflate=!1!==n.perMessageDeflate&amp;&amp;(n.perMessageDeflate||{}),!0===this.perMessageDeflate&amp;&amp;(this.perMessageDeflate={}),this.perMessageDeflate&amp;&amp;null==this.perMessageDeflate.threshold&amp;&amp;(this.perMessageDeflate.threshold=1024),this.pfx=n.pfx||null,this.key=n.key||null,this.passphrase=n.passphrase||null,this.cert=n.cert||null,this.ca=n.ca||null,this.ciphers=n.ciphers||null,this.rejectUnauthorized=void 0===n.rejectUnauthorized||n.rejectUnauthorized,this.forceNode=!!n.forceNode;var o=&quot;object&quot;==typeof e&amp;&amp;e;o.global===o&amp;&amp;(n.extraHeaders&amp;&amp;Object.keys(n.extraHeaders).length&gt;0&amp;&amp;(this.extraHeaders=n.extraHeaders),n.localAddress&amp;&amp;(this.localAddress=n.localAddress)),this.id=null,this.upgrades=null,this.pingInterval=null,this.pingTimeout=null,this.pingIntervalTimer=null,this.pingTimeoutTimer=null,this.open()}function o(t){var e={};for(var n in t)t.hasOwnProperty(n)&amp;&amp;(e[n]=t[n]);return e}var i=n(15),s=n(8),a=n(3)(&quot;engine.io-client:socket&quot;),c=n(36),u=n(21),p=n(2),h=n(30);t.exports=r,r.priorWebsocketSuccess=!1,s(r.prototype),r.protocol=u.protocol,r.Socket=r,r.Transport=n(20),r.transports=n(15),r.parser=n(21),r.prototype.createTransport=function(t){a(&apos;creating transport &quot;%s&quot;&apos;,t);var e=o(this.query);e.EIO=u.protocol,e.transport=t;var n=this.transportOptions[t]||{};this.id&amp;&amp;(e.sid=this.id);var r=new i[t]({query:e,socket:this,agent:n.agent||this.agent,hostname:n.hostname||this.hostname,port:n.port||this.port,secure:n.secure||this.secure,path:n.path||this.path,forceJSONP:n.forceJSONP||this.forceJSONP,jsonp:n.jsonp||this.jsonp,forceBase64:n.forceBase64||this.forceBase64,enablesXDR:n.enablesXDR||this.enablesXDR,timestampRequests:n.timestampRequests||this.timestampRequests,timestampParam:n.timestampParam||this.timestampParam,policyPort:n.policyPort||this.policyPort,pfx:n.pfx||this.pfx,key:n.key||this.key,passphrase:n.passphrase||this.passphrase,cert:n.cert||this.cert,ca:n.ca||this.ca,ciphers:n.ciphers||this.ciphers,rejectUnauthorized:n.rejectUnauthorized||this.rejectUnauthorized,perMessageDeflate:n.perMessageDeflate||this.perMessageDeflate,extraHeaders:n.extraHeaders||this.extraHeaders,forceNode:n.forceNode||this.forceNode,localAddress:n.localAddress||this.localAddress,requestTimeout:n.requestTimeout||this.requestTimeout,protocols:n.protocols||void 0});return r},r.prototype.open=function(){var t;if(this.rememberUpgrade&amp;&amp;r.priorWebsocketSuccess&amp;&amp;this.transports.indexOf(&quot;websocket&quot;)!==-1)t=&quot;websocket&quot;;else{if(0===this.transports.length){var e=this;return void setTimeout(function(){e.emit(&quot;error&quot;,&quot;No transports available&quot;)},0)}t=this.transports[0]}this.readyState=&quot;opening&quot;;try{t=this.createTransport(t)}catch(n){return this.transports.shift(),void this.open()}t.open(),this.setTransport(t)},r.prototype.setTransport=function(t){a(&quot;setting transport %s&quot;,t.name);var e=this;this.transport&amp;&amp;(a(&quot;clearing existing transport %s&quot;,this.transport.name),this.transport.removeAllListeners()),this.transport=t,t.on(&quot;drain&quot;,function(){e.onDrain()}).on(&quot;packet&quot;,function(t){e.onPacket(t)}).on(&quot;error&quot;,function(t){e.onError(t)}).on(&quot;close&quot;,function(){e.onClose(&quot;transport close&quot;)})},r.prototype.probe=function(t){function e(){if(f.onlyBinaryUpgrades){var e=!this.supportsBinary&amp;&amp;f.transport.supportsBinary;h=h||e}h||(a(&apos;probe transport &quot;%s&quot; opened&apos;,t),p.send([{type:&quot;ping&quot;,data:&quot;probe&quot;}]),p.once(&quot;packet&quot;,function(e){if(!h)if(&quot;pong&quot;===e.type&amp;&amp;&quot;probe&quot;===e.data){if(a(&apos;probe transport &quot;%s&quot; pong&apos;,t),f.upgrading=!0,f.emit(&quot;upgrading&quot;,p),!p)return;r.priorWebsocketSuccess=&quot;websocket&quot;===p.name,a(&apos;pausing current transport &quot;%s&quot;&apos;,f.transport.name),f.transport.pause(function(){h||&quot;closed&quot;!==f.readyState&amp;&amp;(a(&quot;changing transport and sending upgrade packet&quot;),u(),f.setTransport(p),p.send([{type:&quot;upgrade&quot;}]),f.emit(&quot;upgrade&quot;,p),p=null,f.upgrading=!1,f.flush())})}else{a(&apos;probe transport &quot;%s&quot; failed&apos;,t);var n=new Error(&quot;probe error&quot;);n.transport=p.name,f.emit(&quot;upgradeError&quot;,n)}}))}function n(){h||(h=!0,u(),p.close(),p=null)}function o(e){var r=new Error(&quot;probe error: &quot;+e);r.transport=p.name,n(),a(&apos;probe transport &quot;%s&quot; failed because of error: %s&apos;,t,e),f.emit(&quot;upgradeError&quot;,r)}function i(){o(&quot;transport closed&quot;)}function s(){o(&quot;socket closed&quot;)}function c(t){p&amp;&amp;t.name!==p.name&amp;&amp;(a(&apos;&quot;%s&quot; works - aborting &quot;%s&quot;&apos;,t.name,p.name),n())}function u(){p.removeListener(&quot;open&quot;,e),p.removeListener(&quot;error&quot;,o),p.removeListener(&quot;close&quot;,i),f.removeListener(&quot;close&quot;,s),f.removeListener(&quot;upgrading&quot;,c)}a(&apos;probing transport &quot;%s&quot;&apos;,t);var p=this.createTransport(t,{probe:1}),h=!1,f=this;r.priorWebsocketSuccess=!1,p.once(&quot;open&quot;,e),p.once(&quot;error&quot;,o),p.once(&quot;close&quot;,i),this.once(&quot;close&quot;,s),this.once(&quot;upgrading&quot;,c),p.open()},r.prototype.onOpen=function(){if(a(&quot;socket open&quot;),this.readyState=&quot;open&quot;,r.priorWebsocketSuccess=&quot;websocket&quot;===this.transport.name,this.emit(&quot;open&quot;),this.flush(),&quot;open&quot;===this.readyState&amp;&amp;this.upgrade&amp;&amp;this.transport.pause){a(&quot;starting upgrade probes&quot;);for(var t=0,e=this.upgrades.length;t&lt;e;t++)this.probe(this.upgrades[t])}},r.prototype.onPacket=function(t){if(&quot;opening&quot;===this.readyState||&quot;open&quot;===this.readyState||&quot;closing&quot;===this.readyState)switch(a(&apos;socket receive: type &quot;%s&quot;, data &quot;%s&quot;&apos;,t.type,t.data),this.emit(&quot;packet&quot;,t),this.emit(&quot;heartbeat&quot;),t.type){case&quot;open&quot;:this.onHandshake(JSON.parse(t.data));break;case&quot;pong&quot;:this.setPing(),this.emit(&quot;pong&quot;);break;case&quot;error&quot;:var e=new Error(&quot;server error&quot;);e.code=t.data,this.onError(e);break;case&quot;message&quot;:this.emit(&quot;data&quot;,t.data),this.emit(&quot;message&quot;,t.data)}else a(&apos;packet received with socket readyState &quot;%s&quot;&apos;,this.readyState)},r.prototype.onHandshake=function(t){this.emit(&quot;handshake&quot;,t),this.id=t.sid,this.transport.query.sid=t.sid,this.upgrades=this.filterUpgrades(t.upgrades),this.pingInterval=t.pingInterval,this.pingTimeout=t.pingTimeout,this.onOpen(),&quot;closed&quot;!==this.readyState&amp;&amp;(this.setPing(),this.removeListener(&quot;heartbeat&quot;,this.onHeartbeat),this.on(&quot;heartbeat&quot;,this.onHeartbeat))},r.prototype.onHeartbeat=function(t){clearTimeout(this.pingTimeoutTimer);var e=this;e.pingTimeoutTimer=setTimeout(function(){&quot;closed&quot;!==e.readyState&amp;&amp;e.onClose(&quot;ping timeout&quot;)},t||e.pingInterval+e.pingTimeout)},r.prototype.setPing=function(){var t=this;clearTimeout(t.pingIntervalTimer),t.pingIntervalTimer=setTimeout(function(){a(&quot;writing ping packet - expecting pong within %sms&quot;,t.pingTimeout),t.ping(),t.onHeartbeat(t.pingTimeout)},t.pingInterval)},r.prototype.ping=function(){var t=this;this.sendPacket(&quot;ping&quot;,function(){t.emit(&quot;ping&quot;)})},r.prototype.onDrain=function(){this.writeBuffer.splice(0,this.prevBufferLen),this.prevBufferLen=0,0===this.writeBuffer.length?this.emit(&quot;drain&quot;):this.flush()},r.prototype.flush=function(){&quot;closed&quot;!==this.readyState&amp;&amp;this.transport.writable&amp;&amp;!this.upgrading&amp;&amp;this.writeBuffer.length&amp;&amp;(a(&quot;flushing %d packets in socket&quot;,this.writeBuffer.length),this.transport.send(this.writeBuffer),this.prevBufferLen=this.writeBuffer.length,this.emit(&quot;flush&quot;))},r.prototype.write=r.prototype.send=function(t,e,n){return this.sendPacket(&quot;message&quot;,t,e,n),this},r.prototype.sendPacket=function(t,e,n,r){if(&quot;function&quot;==typeof e&amp;&amp;(r=e,e=void 0),&quot;function&quot;==typeof n&amp;&amp;(r=n,n=null),&quot;closing&quot;!==this.readyState&amp;&amp;&quot;closed&quot;!==this.readyState){n=n||{},n.compress=!1!==n.compress;var o={type:t,data:e,options:n};this.emit(&quot;packetCreate&quot;,o),this.writeBuffer.push(o),r&amp;&amp;this.once(&quot;flush&quot;,r),this.flush()}},r.prototype.close=function(){function t(){r.onClose(&quot;forced close&quot;),a(&quot;socket closing - telling transport to close&quot;),r.transport.close()}function e(){r.removeListener(&quot;upgrade&quot;,e),r.removeListener(&quot;upgradeError&quot;,e),t()}function n(){r.once(&quot;upgrade&quot;,e),r.once(&quot;upgradeError&quot;,e)}if(&quot;opening&quot;===this.readyState||&quot;open&quot;===this.readyState){this.readyState=&quot;closing&quot;;var r=this;this.writeBuffer.length?this.once(&quot;drain&quot;,function(){this.upgrading?n():t()}):this.upgrading?n():t()}return this},r.prototype.onError=function(t){a(&quot;socket error %j&quot;,t),r.priorWebsocketSuccess=!1,this.emit(&quot;error&quot;,t),this.onClose(&quot;transport error&quot;,t)},r.prototype.onClose=function(t,e){if(&quot;opening&quot;===this.readyState||&quot;open&quot;===this.readyState||&quot;closing&quot;===this.readyState){a(&apos;socket close with reason: &quot;%s&quot;&apos;,t);var n=this;clearTimeout(this.pingIntervalTimer),clearTimeout(this.pingTimeoutTimer),this.transport.removeAllListeners(&quot;close&quot;),this.transport.close(),this.transport.removeAllListeners(),this.readyState=&quot;closed&quot;,this.id=null,this.emit(&quot;close&quot;,t,e),n.writeBuffer=[],n.prevBufferLen=0}},r.prototype.filterUpgrades=function(t){for(var e=[],n=0,r=t.length;n&lt;r;n++)~c(this.transports,t[n])&amp;&amp;e.push(t[n]);return e}}).call(e,function(){return this}())},function(t,e,n){(function(t){function r(e){var n,r=!1,a=!1,c=!1!==e.jsonp;if(t.location){var u=&quot;https:&quot;===location.protocol,p=location.port;
p||(p=u?443:80),r=e.hostname!==location.hostname||p!==e.port,a=e.secure!==u}if(e.xdomain=r,e.xscheme=a,n=new o(e),&quot;open&quot;in n&amp;&amp;!e.forceJSONP)return new i(e);if(!c)throw new Error(&quot;JSONP disabled&quot;);return new s(e)}var o=n(16),i=n(18),s=n(33),a=n(34);e.polling=r,e.websocket=a}).call(e,function(){return this}())},function(t,e,n){(function(e){var r=n(17);t.exports=function(t){var n=t.xdomain,o=t.xscheme,i=t.enablesXDR;try{if(&quot;undefined&quot;!=typeof XMLHttpRequest&amp;&amp;(!n||r))return new XMLHttpRequest}catch(s){}try{if(&quot;undefined&quot;!=typeof XDomainRequest&amp;&amp;!o&amp;&amp;i)return new XDomainRequest}catch(s){}if(!n)try{return new(e[[&quot;Active&quot;].concat(&quot;Object&quot;).join(&quot;X&quot;)])(&quot;Microsoft.XMLHTTP&quot;)}catch(s){}}}).call(e,function(){return this}())},function(t,e){try{t.exports=&quot;undefined&quot;!=typeof XMLHttpRequest&amp;&amp;&quot;withCredentials&quot;in new XMLHttpRequest}catch(n){t.exports=!1}},function(t,e,n){(function(e){function r(){}function o(t){if(c.call(this,t),this.requestTimeout=t.requestTimeout,this.extraHeaders=t.extraHeaders,e.location){var n=&quot;https:&quot;===location.protocol,r=location.port;r||(r=n?443:80),this.xd=t.hostname!==e.location.hostname||r!==t.port,this.xs=t.secure!==n}}function i(t){this.method=t.method||&quot;GET&quot;,this.uri=t.uri,this.xd=!!t.xd,this.xs=!!t.xs,this.async=!1!==t.async,this.data=void 0!==t.data?t.data:null,this.agent=t.agent,this.isBinary=t.isBinary,this.supportsBinary=t.supportsBinary,this.enablesXDR=t.enablesXDR,this.requestTimeout=t.requestTimeout,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.extraHeaders=t.extraHeaders,this.create()}function s(){for(var t in i.requests)i.requests.hasOwnProperty(t)&amp;&amp;i.requests[t].abort()}var a=n(16),c=n(19),u=n(8),p=n(31),h=n(3)(&quot;engine.io-client:polling-xhr&quot;);t.exports=o,t.exports.Request=i,p(o,c),o.prototype.supportsBinary=!0,o.prototype.request=function(t){return t=t||{},t.uri=this.uri(),t.xd=this.xd,t.xs=this.xs,t.agent=this.agent||!1,t.supportsBinary=this.supportsBinary,t.enablesXDR=this.enablesXDR,t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized,t.requestTimeout=this.requestTimeout,t.extraHeaders=this.extraHeaders,new i(t)},o.prototype.doWrite=function(t,e){var n=&quot;string&quot;!=typeof t&amp;&amp;void 0!==t,r=this.request({method:&quot;POST&quot;,data:t,isBinary:n}),o=this;r.on(&quot;success&quot;,e),r.on(&quot;error&quot;,function(t){o.onError(&quot;xhr post error&quot;,t)}),this.sendXhr=r},o.prototype.doPoll=function(){h(&quot;xhr poll&quot;);var t=this.request(),e=this;t.on(&quot;data&quot;,function(t){e.onData(t)}),t.on(&quot;error&quot;,function(t){e.onError(&quot;xhr poll error&quot;,t)}),this.pollXhr=t},u(i.prototype),i.prototype.create=function(){var t={agent:this.agent,xdomain:this.xd,xscheme:this.xs,enablesXDR:this.enablesXDR};t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized;var n=this.xhr=new a(t),r=this;try{h(&quot;xhr open %s: %s&quot;,this.method,this.uri),n.open(this.method,this.uri,this.async);try{if(this.extraHeaders){n.setDisableHeaderCheck&amp;&amp;n.setDisableHeaderCheck(!0);for(var o in this.extraHeaders)this.extraHeaders.hasOwnProperty(o)&amp;&amp;n.setRequestHeader(o,this.extraHeaders[o])}}catch(s){}if(&quot;POST&quot;===this.method)try{this.isBinary?n.setRequestHeader(&quot;Content-type&quot;,&quot;application/octet-stream&quot;):n.setRequestHeader(&quot;Content-type&quot;,&quot;text/plain;charset=UTF-8&quot;)}catch(s){}try{n.setRequestHeader(&quot;Accept&quot;,&quot;*/*&quot;)}catch(s){}&quot;withCredentials&quot;in n&amp;&amp;(n.withCredentials=!0),this.requestTimeout&amp;&amp;(n.timeout=this.requestTimeout),this.hasXDR()?(n.onload=function(){r.onLoad()},n.onerror=function(){r.onError(n.responseText)}):n.onreadystatechange=function(){if(2===n.readyState)try{var t=n.getResponseHeader(&quot;Content-Type&quot;);r.supportsBinary&amp;&amp;&quot;application/octet-stream&quot;===t&amp;&amp;(n.responseType=&quot;arraybuffer&quot;)}catch(e){}4===n.readyState&amp;&amp;(200===n.status||1223===n.status?r.onLoad():setTimeout(function(){r.onError(n.status)},0))},h(&quot;xhr data %s&quot;,this.data),n.send(this.data)}catch(s){return void setTimeout(function(){r.onError(s)},0)}e.document&amp;&amp;(this.index=i.requestsCount++,i.requests[this.index]=this)},i.prototype.onSuccess=function(){this.emit(&quot;success&quot;),this.cleanup()},i.prototype.onData=function(t){this.emit(&quot;data&quot;,t),this.onSuccess()},i.prototype.onError=function(t){this.emit(&quot;error&quot;,t),this.cleanup(!0)},i.prototype.cleanup=function(t){if(&quot;undefined&quot;!=typeof this.xhr&amp;&amp;null!==this.xhr){if(this.hasXDR()?this.xhr.onload=this.xhr.onerror=r:this.xhr.onreadystatechange=r,t)try{this.xhr.abort()}catch(n){}e.document&amp;&amp;delete i.requests[this.index],this.xhr=null}},i.prototype.onLoad=function(){var t;try{var e;try{e=this.xhr.getResponseHeader(&quot;Content-Type&quot;)}catch(n){}t=&quot;application/octet-stream&quot;===e?this.xhr.response||this.xhr.responseText:this.xhr.responseText}catch(n){this.onError(n)}null!=t&amp;&amp;this.onData(t)},i.prototype.hasXDR=function(){return&quot;undefined&quot;!=typeof e.XDomainRequest&amp;&amp;!this.xs&amp;&amp;this.enablesXDR},i.prototype.abort=function(){this.cleanup()},i.requestsCount=0,i.requests={},e.document&amp;&amp;(e.attachEvent?e.attachEvent(&quot;onunload&quot;,s):e.addEventListener&amp;&amp;e.addEventListener(&quot;beforeunload&quot;,s,!1))}).call(e,function(){return this}())},function(t,e,n){function r(t){var e=t&amp;&amp;t.forceBase64;p&amp;&amp;!e||(this.supportsBinary=!1),o.call(this,t)}var o=n(20),i=n(30),s=n(21),a=n(31),c=n(32),u=n(3)(&quot;engine.io-client:polling&quot;);t.exports=r;var p=function(){var t=n(16),e=new t({xdomain:!1});return null!=e.responseType}();a(r,o),r.prototype.name=&quot;polling&quot;,r.prototype.doOpen=function(){this.poll()},r.prototype.pause=function(t){function e(){u(&quot;paused&quot;),n.readyState=&quot;paused&quot;,t()}var n=this;if(this.readyState=&quot;pausing&quot;,this.polling||!this.writable){var r=0;this.polling&amp;&amp;(u(&quot;we are currently polling - waiting to pause&quot;),r++,this.once(&quot;pollComplete&quot;,function(){u(&quot;pre-pause polling complete&quot;),--r||e()})),this.writable||(u(&quot;we are currently writing - waiting to pause&quot;),r++,this.once(&quot;drain&quot;,function(){u(&quot;pre-pause writing complete&quot;),--r||e()}))}else e()},r.prototype.poll=function(){u(&quot;polling&quot;),this.polling=!0,this.doPoll(),this.emit(&quot;poll&quot;)},r.prototype.onData=function(t){var e=this;u(&quot;polling got data %s&quot;,t);var n=function(t,n,r){return&quot;opening&quot;===e.readyState&amp;&amp;e.onOpen(),&quot;close&quot;===t.type?(e.onClose(),!1):void e.onPacket(t)};s.decodePayload(t,this.socket.binaryType,n),&quot;closed&quot;!==this.readyState&amp;&amp;(this.polling=!1,this.emit(&quot;pollComplete&quot;),&quot;open&quot;===this.readyState?this.poll():u(&apos;ignoring poll - transport state &quot;%s&quot;&apos;,this.readyState))},r.prototype.doClose=function(){function t(){u(&quot;writing close packet&quot;),e.write([{type:&quot;close&quot;}])}var e=this;&quot;open&quot;===this.readyState?(u(&quot;transport open - closing&quot;),t()):(u(&quot;transport not open - deferring close&quot;),this.once(&quot;open&quot;,t))},r.prototype.write=function(t){var e=this;this.writable=!1;var n=function(){e.writable=!0,e.emit(&quot;drain&quot;)};s.encodePayload(t,this.supportsBinary,function(t){e.doWrite(t,n)})},r.prototype.uri=function(){var t=this.query||{},e=this.secure?&quot;https&quot;:&quot;http&quot;,n=&quot;&quot;;!1!==this.timestampRequests&amp;&amp;(t[this.timestampParam]=c()),this.supportsBinary||t.sid||(t.b64=1),t=i.encode(t),this.port&amp;&amp;(&quot;https&quot;===e&amp;&amp;443!==Number(this.port)||&quot;http&quot;===e&amp;&amp;80!==Number(this.port))&amp;&amp;(n=&quot;:&quot;+this.port),t.length&amp;&amp;(t=&quot;?&quot;+t);var r=this.hostname.indexOf(&quot;:&quot;)!==-1;return e+&quot;://&quot;+(r?&quot;[&quot;+this.hostname+&quot;]&quot;:this.hostname)+n+this.path+t}},function(t,e,n){function r(t){this.path=t.path,this.hostname=t.hostname,this.port=t.port,this.secure=t.secure,this.query=t.query,this.timestampParam=t.timestampParam,this.timestampRequests=t.timestampRequests,this.readyState=&quot;&quot;,this.agent=t.agent||!1,this.socket=t.socket,this.enablesXDR=t.enablesXDR,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.forceNode=t.forceNode,this.extraHeaders=t.extraHeaders,this.localAddress=t.localAddress}var o=n(21),i=n(8);t.exports=r,i(r.prototype),r.prototype.onError=function(t,e){var n=new Error(t);return n.type=&quot;TransportError&quot;,n.description=e,this.emit(&quot;error&quot;,n),this},r.prototype.open=function(){return&quot;closed&quot;!==this.readyState&amp;&amp;&quot;&quot;!==this.readyState||(this.readyState=&quot;opening&quot;,this.doOpen()),this},r.prototype.close=function(){return&quot;opening&quot;!==this.readyState&amp;&amp;&quot;open&quot;!==this.readyState||(this.doClose(),this.onClose()),this},r.prototype.send=function(t){if(&quot;open&quot;!==this.readyState)throw new Error(&quot;Transport not open&quot;);this.write(t)},r.prototype.onOpen=function(){this.readyState=&quot;open&quot;,this.writable=!0,this.emit(&quot;open&quot;)},r.prototype.onData=function(t){var e=o.decodePacket(t,this.socket.binaryType);this.onPacket(e)},r.prototype.onPacket=function(t){this.emit(&quot;packet&quot;,t)},r.prototype.onClose=function(){this.readyState=&quot;closed&quot;,this.emit(&quot;close&quot;)}},function(t,e,n){(function(t){function r(t,n){var r=&quot;b&quot;+e.packets[t.type]+t.data.data;return n(r)}function o(t,n,r){if(!n)return e.encodeBase64Packet(t,r);var o=t.data,i=new Uint8Array(o),s=new Uint8Array(1+o.byteLength);s[0]=v[t.type];for(var a=0;a&lt;i.length;a++)s[a+1]=i[a];return r(s.buffer)}function i(t,n,r){if(!n)return e.encodeBase64Packet(t,r);var o=new FileReader;return o.onload=function(){t.data=o.result,e.encodePacket(t,n,!0,r)},o.readAsArrayBuffer(t.data)}function s(t,n,r){if(!n)return e.encodeBase64Packet(t,r);if(g)return i(t,n,r);var o=new Uint8Array(1);o[0]=v[t.type];var s=new k([o.buffer,t.data]);return r(s)}function a(t){try{t=d.decode(t,{strict:!1})}catch(e){return!1}return t}function c(t,e,n){for(var r=new Array(t.length),o=l(t.length,n),i=function(t,n,o){e(n,function(e,n){r[t]=n,o(e,r)})},s=0;s&lt;t.length;s++)i(s,t[s],o)}var u,p=n(22),h=n(23),f=n(24),l=n(25),d=n(26);t&amp;&amp;t.ArrayBuffer&amp;&amp;(u=n(28));var y=&quot;undefined&quot;!=typeof navigator&amp;&amp;/Android/i.test(navigator.userAgent),m=&quot;undefined&quot;!=typeof navigator&amp;&amp;/PhantomJS/i.test(navigator.userAgent),g=y||m;e.protocol=3;var v=e.packets={open:0,close:1,ping:2,pong:3,message:4,upgrade:5,noop:6},b=p(v),w={type:&quot;error&quot;,data:&quot;parser error&quot;},k=n(29);e.encodePacket=function(e,n,i,a){&quot;function&quot;==typeof n&amp;&amp;(a=n,n=!1),&quot;function&quot;==typeof i&amp;&amp;(a=i,i=null);var c=void 0===e.data?void 0:e.data.buffer||e.data;if(t.ArrayBuffer&amp;&amp;c instanceof ArrayBuffer)return o(e,n,a);if(k&amp;&amp;c instanceof t.Blob)return s(e,n,a);if(c&amp;&amp;c.base64)return r(e,a);var u=v[e.type];return void 0!==e.data&amp;&amp;(u+=i?d.encode(String(e.data),{strict:!1}):String(e.data)),a(&quot;&quot;+u)},e.encodeBase64Packet=function(n,r){var o=&quot;b&quot;+e.packets[n.type];if(k&amp;&amp;n.data instanceof t.Blob){var i=new FileReader;return i.onload=function(){var t=i.result.split(&quot;,&quot;)[1];r(o+t)},i.readAsDataURL(n.data)}var s;try{s=String.fromCharCode.apply(null,new Uint8Array(n.data))}catch(a){for(var c=new Uint8Array(n.data),u=new Array(c.length),p=0;p&lt;c.length;p++)u[p]=c[p];s=String.fromCharCode.apply(null,u)}return o+=t.btoa(s),r(o)},e.decodePacket=function(t,n,r){if(void 0===t)return w;if(&quot;string&quot;==typeof t){if(&quot;b&quot;===t.charAt(0))return e.decodeBase64Packet(t.substr(1),n);if(r&amp;&amp;(t=a(t),t===!1))return w;var o=t.charAt(0);return Number(o)==o&amp;&amp;b[o]?t.length&gt;1?{type:b[o],data:t.substring(1)}:{type:b[o]}:w}var i=new Uint8Array(t),o=i[0],s=f(t,1);return k&amp;&amp;&quot;blob&quot;===n&amp;&amp;(s=new k([s])),{type:b[o],data:s}},e.decodeBase64Packet=function(t,e){var n=b[t.charAt(0)];if(!u)return{type:n,data:{base64:!0,data:t.substr(1)}};var r=u.decode(t.substr(1));return&quot;blob&quot;===e&amp;&amp;k&amp;&amp;(r=new k([r])),{type:n,data:r}},e.encodePayload=function(t,n,r){function o(t){return t.length+&quot;:&quot;+t}function i(t,r){e.encodePacket(t,!!s&amp;&amp;n,!1,function(t){r(null,o(t))})}&quot;function&quot;==typeof n&amp;&amp;(r=n,n=null);var s=h(t);return n&amp;&amp;s?k&amp;&amp;!g?e.encodePayloadAsBlob(t,r):e.encodePayloadAsArrayBuffer(t,r):t.length?void c(t,i,function(t,e){return r(e.join(&quot;&quot;))}):r(&quot;0:&quot;)},e.decodePayload=function(t,n,r){if(&quot;string&quot;!=typeof t)return e.decodePayloadAsBinary(t,n,r);&quot;function&quot;==typeof n&amp;&amp;(r=n,n=null);var o;if(&quot;&quot;===t)return r(w,0,1);for(var i,s,a=&quot;&quot;,c=0,u=t.length;c&lt;u;c++){var p=t.charAt(c);if(&quot;:&quot;===p){if(&quot;&quot;===a||a!=(i=Number(a)))return r(w,0,1);if(s=t.substr(c+1,i),a!=s.length)return r(w,0,1);if(s.length){if(o=e.decodePacket(s,n,!1),w.type===o.type&amp;&amp;w.data===o.data)return r(w,0,1);var h=r(o,c+i,u);if(!1===h)return}c+=i,a=&quot;&quot;}else a+=p}return&quot;&quot;!==a?r(w,0,1):void 0},e.encodePayloadAsArrayBuffer=function(t,n){function r(t,n){e.encodePacket(t,!0,!0,function(t){return n(null,t)})}return t.length?void c(t,r,function(t,e){var r=e.reduce(function(t,e){var n;return n=&quot;string&quot;==typeof e?e.length:e.byteLength,t+n.toString().length+n+2},0),o=new Uint8Array(r),i=0;return e.forEach(function(t){var e=&quot;string&quot;==typeof t,n=t;if(e){for(var r=new Uint8Array(t.length),s=0;s&lt;t.length;s++)r[s]=t.charCodeAt(s);n=r.buffer}e?o[i++]=0:o[i++]=1;for(var a=n.byteLength.toString(),s=0;s&lt;a.length;s++)o[i++]=parseInt(a[s]);o[i++]=255;for(var r=new Uint8Array(n),s=0;s&lt;r.length;s++)o[i++]=r[s]}),n(o.buffer)}):n(new ArrayBuffer(0))},e.encodePayloadAsBlob=function(t,n){function r(t,n){e.encodePacket(t,!0,!0,function(t){var e=new Uint8Array(1);if(e[0]=1,&quot;string&quot;==typeof t){for(var r=new Uint8Array(t.length),o=0;o&lt;t.length;o++)r[o]=t.charCodeAt(o);t=r.buffer,e[0]=0}for(var i=t instanceof ArrayBuffer?t.byteLength:t.size,s=i.toString(),a=new Uint8Array(s.length+1),o=0;o&lt;s.length;o++)a[o]=parseInt(s[o]);if(a[s.length]=255,k){var c=new k([e.buffer,a.buffer,t]);n(null,c)}})}c(t,r,function(t,e){return n(new k(e))})},e.decodePayloadAsBinary=function(t,n,r){&quot;function&quot;==typeof n&amp;&amp;(r=n,n=null);for(var o=t,i=[];o.byteLength&gt;0;){for(var s=new Uint8Array(o),a=0===s[0],c=&quot;&quot;,u=1;255!==s[u];u++){if(c.length&gt;310)return r(w,0,1);c+=s[u]}o=f(o,2+c.length),c=parseInt(c);var p=f(o,0,c);if(a)try{p=String.fromCharCode.apply(null,new Uint8Array(p))}catch(h){var l=new Uint8Array(p);p=&quot;&quot;;for(var u=0;u&lt;l.length;u++)p+=String.fromCharCode(l[u])}i.push(p),o=f(o,c)}var d=i.length;i.forEach(function(t,o){r(e.decodePacket(t,n,!0),o,d)})}}).call(e,function(){return this}())},function(t,e){t.exports=Object.keys||function(t){var e=[],n=Object.prototype.hasOwnProperty;for(var r in t)n.call(t,r)&amp;&amp;e.push(r);return e}},function(t,e,n){(function(e){function r(t){if(!t||&quot;object&quot;!=typeof t)return!1;if(o(t)){for(var n=0,i=t.length;n&lt;i;n++)if(r(t[n]))return!0;return!1}if(&quot;function&quot;==typeof e.Buffer&amp;&amp;e.Buffer.isBuffer&amp;&amp;e.Buffer.isBuffer(t)||&quot;function&quot;==typeof e.ArrayBuffer&amp;&amp;t instanceof ArrayBuffer||s&amp;&amp;t instanceof Blob||a&amp;&amp;t instanceof File)return!0;if(t.toJSON&amp;&amp;&quot;function&quot;==typeof t.toJSON&amp;&amp;1===arguments.length)return r(t.toJSON(),!0);for(var c in t)if(Object.prototype.hasOwnProperty.call(t,c)&amp;&amp;r(t[c]))return!0;return!1}var o=n(10),i=Object.prototype.toString,s=&quot;function&quot;==typeof e.Blob||&quot;[object BlobConstructor]&quot;===i.call(e.Blob),a=&quot;function&quot;==typeof e.File||&quot;[object FileConstructor]&quot;===i.call(e.File);t.exports=r}).call(e,function(){return this}())},function(t,e){t.exports=function(t,e,n){var r=t.byteLength;if(e=e||0,n=n||r,t.slice)return t.slice(e,n);if(e&lt;0&amp;&amp;(e+=r),n&lt;0&amp;&amp;(n+=r),n&gt;r&amp;&amp;(n=r),e&gt;=r||e&gt;=n||0===r)return new ArrayBuffer(0);for(var o=new Uint8Array(t),i=new Uint8Array(n-e),s=e,a=0;s&lt;n;s++,a++)i[a]=o[s];return i.buffer}},function(t,e){function n(t,e,n){function o(t,r){if(o.count&lt;=0)throw new Error(&quot;after called too many times&quot;);--o.count,t?(i=!0,e(t),e=n):0!==o.count||i||e(null,r)}var i=!1;return n=n||r,o.count=t,0===t?e():o}function r(){}t.exports=n},function(t,e,n){var r;(function(t,o){!function(i){function s(t){for(var e,n,r=[],o=0,i=t.length;o&lt;i;)e=t.charCodeAt(o++),e&gt;=55296&amp;&amp;e&lt;=56319&amp;&amp;o&lt;i?(n=t.charCodeAt(o++),56320==(64512&amp;n)?r.push(((1023&amp;e)&lt;&lt;10)+(1023&amp;n)+65536):(r.push(e),o--)):r.push(e);return r}function a(t){for(var e,n=t.length,r=-1,o=&quot;&quot;;++r&lt;n;)e=t[r],e&gt;65535&amp;&amp;(e-=65536,o+=w(e&gt;&gt;&gt;10&amp;1023|55296),e=56320|1023&amp;e),o+=w(e);return o}function c(t,e){if(t&gt;=55296&amp;&amp;t&lt;=57343){if(e)throw Error(&quot;Lone surrogate U+&quot;+t.toString(16).toUpperCase()+&quot; is not a scalar value&quot;);return!1}return!0}function u(t,e){return w(t&gt;&gt;e&amp;63|128)}function p(t,e){if(0==(4294967168&amp;t))return w(t);var n=&quot;&quot;;return 0==(4294965248&amp;t)?n=w(t&gt;&gt;6&amp;31|192):0==(4294901760&amp;t)?(c(t,e)||(t=65533),n=w(t&gt;&gt;12&amp;15|224),n+=u(t,6)):0==(4292870144&amp;t)&amp;&amp;(n=w(t&gt;&gt;18&amp;7|240),n+=u(t,12),n+=u(t,6)),n+=w(63&amp;t|128)}function h(t,e){e=e||{};for(var n,r=!1!==e.strict,o=s(t),i=o.length,a=-1,c=&quot;&quot;;++a&lt;i;)n=o[a],c+=p(n,r);return c}function f(){if(b&gt;=v)throw Error(&quot;Invalid byte index&quot;);var t=255&amp;g[b];if(b++,128==(192&amp;t))return 63&amp;t;throw Error(&quot;Invalid continuation byte&quot;)}function l(t){var e,n,r,o,i;if(b&gt;v)throw Error(&quot;Invalid byte index&quot;);if(b==v)return!1;if(e=255&amp;g[b],b++,0==(128&amp;e))return e;if(192==(224&amp;e)){if(n=f(),i=(31&amp;e)&lt;&lt;6|n,i&gt;=128)return i;throw Error(&quot;Invalid continuation byte&quot;)}if(224==(240&amp;e)){if(n=f(),r=f(),i=(15&amp;e)&lt;&lt;12|n&lt;&lt;6|r,i&gt;=2048)return c(i,t)?i:65533;throw Error(&quot;Invalid continuation byte&quot;)}if(240==(248&amp;e)&amp;&amp;(n=f(),r=f(),o=f(),i=(7&amp;e)&lt;&lt;18|n&lt;&lt;12|r&lt;&lt;6|o,i&gt;=65536&amp;&amp;i&lt;=1114111))return i;throw Error(&quot;Invalid UTF-8 detected&quot;)}function d(t,e){e=e||{};var n=!1!==e.strict;g=s(t),v=g.length,b=0;for(var r,o=[];(r=l(n))!==!1;)o.push(r);return a(o)}var y=&quot;object&quot;==typeof e&amp;&amp;e,m=(&quot;object&quot;==typeof t&amp;&amp;t&amp;&amp;t.exports==y&amp;&amp;t,&quot;object&quot;==typeof o&amp;&amp;o);m.global!==m&amp;&amp;m.window!==m||(i=m);var g,v,b,w=String.fromCharCode,k={version:&quot;2.1.2&quot;,encode:h,decode:d};r=function(){return k}.call(e,n,e,t),!(void 0!==r&amp;&amp;(t.exports=r))}(this)}).call(e,n(27)(t),function(){return this}())},function(t,e){t.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children=[],t.webpackPolyfill=1),t}},function(t,e){!function(){&quot;use strict&quot;;for(var t=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;,n=new Uint8Array(256),r=0;r&lt;t.length;r++)n[t.charCodeAt(r)]=r;e.encode=function(e){var n,r=new Uint8Array(e),o=r.length,i=&quot;&quot;;for(n=0;n&lt;o;n+=3)i+=t[r[n]&gt;&gt;2],i+=t[(3&amp;r[n])&lt;&lt;4|r[n+1]&gt;&gt;4],i+=t[(15&amp;r[n+1])&lt;&lt;2|r[n+2]&gt;&gt;6],i+=t[63&amp;r[n+2]];return o%3===2?i=i.substring(0,i.length-1)+&quot;=&quot;:o%3===1&amp;&amp;(i=i.substring(0,i.length-2)+&quot;==&quot;),i},e.decode=function(t){var e,r,o,i,s,a=.75*t.length,c=t.length,u=0;&quot;=&quot;===t[t.length-1]&amp;&amp;(a--,&quot;=&quot;===t[t.length-2]&amp;&amp;a--);var p=new ArrayBuffer(a),h=new Uint8Array(p);for(e=0;e&lt;c;e+=4)r=n[t.charCodeAt(e)],o=n[t.charCodeAt(e+1)],i=n[t.charCodeAt(e+2)],s=n[t.charCodeAt(e+3)],h[u++]=r&lt;&lt;2|o&gt;&gt;4,h[u++]=(15&amp;o)&lt;&lt;4|i&gt;&gt;2,h[u++]=(3&amp;i)&lt;&lt;6|63&amp;s;return p}}()},function(t,e){(function(e){function n(t){for(var e=0;e&lt;t.length;e++){var n=t[e];if(n.buffer instanceof ArrayBuffer){var r=n.buffer;if(n.byteLength!==r.byteLength){var o=new Uint8Array(n.byteLength);o.set(new Uint8Array(r,n.byteOffset,n.byteLength)),r=o.buffer}t[e]=r}}}function r(t,e){e=e||{};var r=new i;n(t);for(var o=0;o&lt;t.length;o++)r.append(t[o]);return e.type?r.getBlob(e.type):r.getBlob()}function o(t,e){return n(t),new Blob(t,e||{})}var i=e.BlobBuilder||e.WebKitBlobBuilder||e.MSBlobBuilder||e.MozBlobBuilder,s=function(){try{var t=new Blob([&quot;hi&quot;]);return 2===t.size}catch(e){return!1}}(),a=s&amp;&amp;function(){try{var t=new Blob([new Uint8Array([1,2])]);return 2===t.size}catch(e){return!1}}(),c=i&amp;&amp;i.prototype.append&amp;&amp;i.prototype.getBlob;t.exports=function(){return s?a?e.Blob:o:c?r:void 0}()}).call(e,function(){return this}())},function(t,e){e.encode=function(t){var e=&quot;&quot;;for(var n in t)t.hasOwnProperty(n)&amp;&amp;(e.length&amp;&amp;(e+=&quot;&amp;&quot;),e+=encodeURIComponent(n)+&quot;=&quot;+encodeURIComponent(t[n]));return e},e.decode=function(t){for(var e={},n=t.split(&quot;&amp;&quot;),r=0,o=n.length;r&lt;o;r++){var i=n[r].split(&quot;=&quot;);e[decodeURIComponent(i[0])]=decodeURIComponent(i[1])}return e}},function(t,e){t.exports=function(t,e){var n=function(){};n.prototype=e.prototype,t.prototype=new n,t.prototype.constructor=t}},function(t,e){&quot;use strict&quot;;function n(t){var e=&quot;&quot;;do e=s[t%a]+e,t=Math.floor(t/a);while(t&gt;0);return e}function r(t){var e=0;for(p=0;p&lt;t.length;p++)e=e*a+c[t.charAt(p)];return e}function o(){var t=n(+new Date);return t!==i?(u=0,i=t):t+&quot;.&quot;+n(u++)}for(var i,s=&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_&quot;.split(&quot;&quot;),a=64,c={},u=0,p=0;p&lt;a;p++)c[s[p]]=p;o.encode=n,o.decode=r,t.exports=o},function(t,e,n){(function(e){function r(){}function o(t){i.call(this,t),this.query=this.query||{},a||(e.___eio||(e.___eio=[]),a=e.___eio),this.index=a.length;var n=this;a.push(function(t){n.onData(t)}),this.query.j=this.index,e.document&amp;&amp;e.addEventListener&amp;&amp;e.addEventListener(&quot;beforeunload&quot;,function(){n.script&amp;&amp;(n.script.onerror=r)},!1)}var i=n(19),s=n(31);t.exports=o;var a,c=/\n/g,u=/\\n/g;s(o,i),o.prototype.supportsBinary=!1,o.prototype.doClose=function(){this.script&amp;&amp;(this.script.parentNode.removeChild(this.script),this.script=null),this.form&amp;&amp;(this.form.parentNode.removeChild(this.form),this.form=null,this.iframe=null),i.prototype.doClose.call(this)},o.prototype.doPoll=function(){var t=this,e=document.createElement(&quot;script&quot;);this.script&amp;&amp;(this.script.parentNode.removeChild(this.script),this.script=null),e.async=!0,e.src=this.uri(),e.onerror=function(e){t.onError(&quot;jsonp poll error&quot;,e)};var n=document.getElementsByTagName(&quot;script&quot;)[0];n?n.parentNode.insertBefore(e,n):(document.head||document.body).appendChild(e),this.script=e;var r=&quot;undefined&quot;!=typeof navigator&amp;&amp;/gecko/i.test(navigator.userAgent);r&amp;&amp;setTimeout(function(){var t=document.createElement(&quot;iframe&quot;);document.body.appendChild(t),document.body.removeChild(t)},100)},o.prototype.doWrite=function(t,e){function n(){r(),e()}function r(){if(o.iframe)try{o.form.removeChild(o.iframe)}catch(t){o.onError(&quot;jsonp polling iframe removal error&quot;,t)}try{var e=&apos;&lt;iframe src=&quot;javascript:0&quot; name=&quot;&apos;+o.iframeId+&apos;&quot;&gt;&apos;;i=document.createElement(e)}catch(t){i=document.createElement(&quot;iframe&quot;),i.name=o.iframeId,i.src=&quot;javascript:0&quot;}i.id=o.iframeId,o.form.appendChild(i),o.iframe=i}var o=this;if(!this.form){var i,s=document.createElement(&quot;form&quot;),a=document.createElement(&quot;textarea&quot;),p=this.iframeId=&quot;eio_iframe_&quot;+this.index;s.className=&quot;socketio&quot;,s.style.position=&quot;absolute&quot;,s.style.top=&quot;-1000px&quot;,s.style.left=&quot;-1000px&quot;,s.target=p,s.method=&quot;POST&quot;,s.setAttribute(&quot;accept-charset&quot;,&quot;utf-8&quot;),a.name=&quot;d&quot;,s.appendChild(a),document.body.appendChild(s),this.form=s,this.area=a}this.form.action=this.uri(),r(),t=t.replace(u,&quot;\\\n&quot;),this.area.value=t.replace(c,&quot;\\n&quot;);try{this.form.submit()}catch(h){}this.iframe.attachEvent?this.iframe.onreadystatechange=function(){&quot;complete&quot;===o.iframe.readyState&amp;&amp;n()}:this.iframe.onload=n}}).call(e,function(){return this}())},function(t,e,n){(function(e){function r(t){var e=t&amp;&amp;t.forceBase64;e&amp;&amp;(this.supportsBinary=!1),this.perMessageDeflate=t.perMessageDeflate,this.usingBrowserWebSocket=h&amp;&amp;!t.forceNode,this.protocols=t.protocols,this.usingBrowserWebSocket||(l=o),i.call(this,t)}var o,i=n(20),s=n(21),a=n(30),c=n(31),u=n(32),p=n(3)(&quot;engine.io-client:websocket&quot;),h=e.WebSocket||e.MozWebSocket;if(&quot;undefined&quot;==typeof window)try{o=n(35)}catch(f){}var l=h;l||&quot;undefined&quot;!=typeof window||(l=o),t.exports=r,c(r,i),r.prototype.name=&quot;websocket&quot;,r.prototype.supportsBinary=!0,r.prototype.doOpen=function(){if(this.check()){var t=this.uri(),e=this.protocols,n={agent:this.agent,perMessageDeflate:this.perMessageDeflate};n.pfx=this.pfx,n.key=this.key,n.passphrase=this.passphrase,n.cert=this.cert,n.ca=this.ca,n.ciphers=this.ciphers,n.rejectUnauthorized=this.rejectUnauthorized,this.extraHeaders&amp;&amp;(n.headers=this.extraHeaders),this.localAddress&amp;&amp;(n.localAddress=this.localAddress);try{this.ws=this.usingBrowserWebSocket?e?new l(t,e):new l(t):new l(t,e,n)}catch(r){return this.emit(&quot;error&quot;,r)}void 0===this.ws.binaryType&amp;&amp;(this.supportsBinary=!1),this.ws.supports&amp;&amp;this.ws.supports.binary?(this.supportsBinary=!0,this.ws.binaryType=&quot;nodebuffer&quot;):this.ws.binaryType=&quot;arraybuffer&quot;,this.addEventListeners()}},r.prototype.addEventListeners=function(){var t=this;this.ws.onopen=function(){t.onOpen()},this.ws.onclose=function(){t.onClose()},this.ws.onmessage=function(e){t.onData(e.data)},this.ws.onerror=function(e){t.onError(&quot;websocket error&quot;,e)}},r.prototype.write=function(t){function n(){r.emit(&quot;flush&quot;),setTimeout(function(){r.writable=!0,r.emit(&quot;drain&quot;)},0)}var r=this;this.writable=!1;for(var o=t.length,i=0,a=o;i&lt;a;i++)!function(t){s.encodePacket(t,r.supportsBinary,function(i){if(!r.usingBrowserWebSocket){var s={};if(t.options&amp;&amp;(s.compress=t.options.compress),r.perMessageDeflate){var a=&quot;string&quot;==typeof i?e.Buffer.byteLength(i):i.length;a&lt;r.perMessageDeflate.threshold&amp;&amp;(s.compress=!1)}}try{r.usingBrowserWebSocket?r.ws.send(i):r.ws.send(i,s)}catch(c){p(&quot;websocket closed before onclose event&quot;)}--o||n()})}(t[i])},r.prototype.onClose=function(){i.prototype.onClose.call(this)},r.prototype.doClose=function(){&quot;undefined&quot;!=typeof this.ws&amp;&amp;this.ws.close()},r.prototype.uri=function(){var t=this.query||{},e=this.secure?&quot;wss&quot;:&quot;ws&quot;,n=&quot;&quot;;this.port&amp;&amp;(&quot;wss&quot;===e&amp;&amp;443!==Number(this.port)||&quot;ws&quot;===e&amp;&amp;80!==Number(this.port))&amp;&amp;(n=&quot;:&quot;+this.port),this.timestampRequests&amp;&amp;(t[this.timestampParam]=u()),this.supportsBinary||(t.b64=1),t=a.encode(t),t.length&amp;&amp;(t=&quot;?&quot;+t);var r=this.hostname.indexOf(&quot;:&quot;)!==-1;return e+&quot;://&quot;+(r?&quot;[&quot;+this.hostname+&quot;]&quot;:this.hostname)+n+this.path+t},r.prototype.check=function(){return!(!l||&quot;__initialize&quot;in l&amp;&amp;this.name===r.prototype.name)}}).call(e,function(){return this}())},function(t,e){},function(t,e){var n=[].indexOf;t.exports=function(t,e){if(n)return t.indexOf(e);for(var r=0;r&lt;t.length;++r)if(t[r]===e)return r;return-1}},function(t,e,n){&quot;use strict&quot;;function r(t,e,n){this.io=t,this.nsp=e,this.json=this,this.ids=0,this.acks={},this.receiveBuffer=[],this.sendBuffer=[],this.connected=!1,this.disconnected=!0,this.flags={},n&amp;&amp;n.query&amp;&amp;(this.query=n.query),this.io.autoConnect&amp;&amp;this.open()}var o=&quot;function&quot;==typeof Symbol&amp;&amp;&quot;symbol&quot;==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&amp;&amp;&quot;function&quot;==typeof Symbol&amp;&amp;t.constructor===Symbol&amp;&amp;t!==Symbol.prototype?&quot;symbol&quot;:typeof t},i=n(7),s=n(8),a=n(38),c=n(39),u=n(40),p=n(3)(&quot;socket.io-client:socket&quot;),h=n(30),f=n(23);t.exports=e=r;var l={connect:1,connect_error:1,connect_timeout:1,connecting:1,disconnect:1,error:1,reconnect:1,reconnect_attempt:1,reconnect_failed:1,reconnect_error:1,reconnecting:1,ping:1,pong:1},d=s.prototype.emit;s(r.prototype),r.prototype.subEvents=function(){if(!this.subs){var t=this.io;this.subs=[c(t,&quot;open&quot;,u(this,&quot;onopen&quot;)),c(t,&quot;packet&quot;,u(this,&quot;onpacket&quot;)),c(t,&quot;close&quot;,u(this,&quot;onclose&quot;))]}},r.prototype.open=r.prototype.connect=function(){return this.connected?this:(this.subEvents(),this.io.open(),&quot;open&quot;===this.io.readyState&amp;&amp;this.onopen(),this.emit(&quot;connecting&quot;),this)},r.prototype.send=function(){var t=a(arguments);return t.unshift(&quot;message&quot;),this.emit.apply(this,t),this},r.prototype.emit=function(t){if(l.hasOwnProperty(t))return d.apply(this,arguments),this;var e=a(arguments),n={type:(void 0!==this.flags.binary?this.flags.binary:f(e))?i.BINARY_EVENT:i.EVENT,data:e};return n.options={},n.options.compress=!this.flags||!1!==this.flags.compress,&quot;function&quot;==typeof e[e.length-1]&amp;&amp;(p(&quot;emitting packet with ack id %d&quot;,this.ids),this.acks[this.ids]=e.pop(),n.id=this.ids++),this.connected?this.packet(n):this.sendBuffer.push(n),this.flags={},this},r.prototype.packet=function(t){t.nsp=this.nsp,this.io.packet(t)},r.prototype.onopen=function(){if(p(&quot;transport is open - connecting&quot;),&quot;/&quot;!==this.nsp)if(this.query){var t=&quot;object&quot;===o(this.query)?h.encode(this.query):this.query;p(&quot;sending connect packet with query %s&quot;,t),this.packet({type:i.CONNECT,query:t})}else this.packet({type:i.CONNECT})},r.prototype.onclose=function(t){p(&quot;close (%s)&quot;,t),this.connected=!1,this.disconnected=!0,delete this.id,this.emit(&quot;disconnect&quot;,t)},r.prototype.onpacket=function(t){var e=t.nsp===this.nsp,n=t.type===i.ERROR&amp;&amp;&quot;/&quot;===t.nsp;if(e||n)switch(t.type){case i.CONNECT:this.onconnect();break;case i.EVENT:this.onevent(t);break;case i.BINARY_EVENT:this.onevent(t);break;case i.ACK:this.onack(t);break;case i.BINARY_ACK:this.onack(t);break;case i.DISCONNECT:this.ondisconnect();break;case i.ERROR:this.emit(&quot;error&quot;,t.data)}},r.prototype.onevent=function(t){var e=t.data||[];p(&quot;emitting event %j&quot;,e),null!=t.id&amp;&amp;(p(&quot;attaching ack callback to event&quot;),e.push(this.ack(t.id))),this.connected?d.apply(this,e):this.receiveBuffer.push(e)},r.prototype.ack=function(t){var e=this,n=!1;return function(){if(!n){n=!0;var r=a(arguments);p(&quot;sending ack %j&quot;,r),e.packet({type:f(r)?i.BINARY_ACK:i.ACK,id:t,data:r})}}},r.prototype.onack=function(t){var e=this.acks[t.id];&quot;function&quot;==typeof e?(p(&quot;calling ack %s with %j&quot;,t.id,t.data),e.apply(this,t.data),delete this.acks[t.id]):p(&quot;bad ack %s&quot;,t.id)},r.prototype.onconnect=function(){this.connected=!0,this.disconnected=!1,this.emit(&quot;connect&quot;),this.emitBuffered()},r.prototype.emitBuffered=function(){var t;for(t=0;t&lt;this.receiveBuffer.length;t++)d.apply(this,this.receiveBuffer[t]);for(this.receiveBuffer=[],t=0;t&lt;this.sendBuffer.length;t++)this.packet(this.sendBuffer[t]);this.sendBuffer=[]},r.prototype.ondisconnect=function(){p(&quot;server disconnect (%s)&quot;,this.nsp),this.destroy(),this.onclose(&quot;io server disconnect&quot;)},r.prototype.destroy=function(){if(this.subs){for(var t=0;t&lt;this.subs.length;t++)this.subs[t].destroy();this.subs=null}this.io.destroy(this)},r.prototype.close=r.prototype.disconnect=function(){return this.connected&amp;&amp;(p(&quot;performing disconnect (%s)&quot;,this.nsp),this.packet({type:i.DISCONNECT})),this.destroy(),this.connected&amp;&amp;this.onclose(&quot;io client disconnect&quot;),this},r.prototype.compress=function(t){return this.flags.compress=t,this},r.prototype.binary=function(t){return this.flags.binary=t,this}},function(t,e){function n(t,e){var n=[];e=e||0;for(var r=e||0;r&lt;t.length;r++)n[r-e]=t[r];return n}t.exports=n},function(t,e){&quot;use strict&quot;;function n(t,e,n){return t.on(e,n),{destroy:function(){t.removeListener(e,n)}}}t.exports=n},function(t,e){var n=[].slice;t.exports=function(t,e){if(&quot;string&quot;==typeof e&amp;&amp;(e=t[e]),&quot;function&quot;!=typeof e)throw new Error(&quot;bind() requires a function&quot;);var r=n.call(arguments,2);return function(){return e.apply(t,r.concat(n.call(arguments)))}}},function(t,e){function n(t){t=t||{},this.ms=t.min||100,this.max=t.max||1e4,this.factor=t.factor||2,this.jitter=t.jitter&gt;0&amp;&amp;t.jitter&lt;=1?t.jitter:0,this.attempts=0}t.exports=n,n.prototype.duration=function(){var t=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var e=Math.random(),n=Math.floor(e*this.jitter*t);t=0==(1&amp;Math.floor(10*e))?t-n:t+n}return 0|Math.min(t,this.max)},n.prototype.reset=function(){this.attempts=0},n.prototype.setMin=function(t){this.ms=t},n.prototype.setMax=function(t){this.max=t},n.prototype.setJitter=function(t){this.jitter=t}}])});
//# sourceMappingURL=socket.io.js.map


var ioOptions ={
	host:&quot;adarshtest1&quot;,
hostname:&quot;adarshtest1&quot;,
path:&quot;/socket.io&quot;,
port:&quot;4910&quot;,
query:{userid: &quot;704&quot;, email: &quot;rosepv123+1@gmail.com&quot;, namespace: &quot;gmm-adarshtest1&quot;},
//reconnection limit:1000,
secure:false
}
portjs = &quot;https://adarshtest1.messageboxapp.com/socket.io/socket.io.js&quot;;
socket = io.connect(portjs, ioOptions);
//refreshOpenRequests();
socket.on(&apos;connect&apos;, function(message) {
    ////
    console.info(&quot;__connected__&quot;);
    

    

});</stringProp>
          <stringProp name="scriptLanguage">javascript</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler" enabled="false">
          <stringProp name="scriptLanguage">javascript</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">
                            {
                               &quot;messageid&quot;=&quot;&quot;,
&quot;requestid&quot;=&quot;&quot;,
&quot;companyid&quot;=&quot;339&quot;,
&quot;companylocationid&quot;=
&quot;chatmediatype&quot;:&quot;Text&quot;
&quot;message&quot;                      //Math.floor(Math.random()*9000000) + 1000000+&apos;&apos;+Date.now()
&quot;targetuserid&quot;  // customer userid give 653 now
&quot;targetuniqueid&quot;
&quot;chatcategoryid&quot;
&quot;chatcategory&quot;
&quot;username&quot;
&quot;usertype&quot;
&quot;usergroupid&quot;
&quot;chatid&quot;
&quot;userid&quot;
&quot;usergroup&quot;
&quot;firstname&quot;
&quot;lastname&quot;
&quot;uniqueid&quot;
&quot;propertycode&quot;:&quot;&quot;
&quot;assigneddate&quot; : null
&quot;subject&quot;
&quot;request&quot;
&quot;status&quot;
&quot;priority&quot;
&quot;servicearea&quot;
&quot;serviceareaid&quot;
&quot;assignedtime&quot; : null,
&quot;accepttime&quot; : null,
&quot;completetime&quot; : null,
&quot;servicestndid&quot;
&quot;createddate&quot; //created time of request use the same here
&quot;accepteduserfirstname&quot; : null,
&quot;accepteduserlastname&quot; : null,
&quot;acceptedUserUserName&quot;: null,
&quot;accepteduserid&quot; : null,
&quot;servicedescription&quot; 
&quot;servicestandard&quot;
&quot;servicestandardunit&quot;
&quot;categoryid&quot;
&quot;categoryname&quot;
&quot;assigneduserid&quot;
&quot;assignedlastname&quot;
&quot;assignedfirstname&quot;
                           }</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler" enabled="true">
          <stringProp name="scriptLanguage">javascript</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">var ioOptions ={
	host:&quot;adarshtest1&quot;,
hostname:&quot;adarshtest1&quot;,
path:&quot;/socket.io&quot;,
port:&quot;4910&quot;,
query:{userid: &quot;704&quot;, email: &quot;rosepv123+1@gmail.com&quot;, namespace: &quot;gmm-adarshtest1&quot;},
//reconnection limit:1000,
secure:false
}
function hoi() {
	io = &quot;https://adarshtest1.messageboxapp.com/socket.io/socket.io.js&quot;;
	}
hoi();
portjs = &quot;https://adarshtest1.messageboxapp.com/socket.io/socket.io.js&quot;;
socket = io.connect(portjs, ioOptions);
//refreshOpenRequests();
socket.on(&apos;connect&apos;, function(message) {
    ////
    console.info(&quot;__connected__&quot;);
    swal({
        title: gmmValAlerts[&quot;GMM_VAL_NW_CONNECTED_MSG&quot;],
        text: &quot;&quot;,
        type:&quot;success&quot;,
        showConfirmButton: false,
        allowEscapeKey: false
    });
    setTimeout(function() {
        swal.close();
        if(localStorage.getItem(&apos;browserAlertStatus&apos;) != &apos;true&apos;){
            showBrowserAlerts();
        }
    }, 1000);

    function showBrowserAlerts(){
        if(!categories){
            setTimeout(function(){
                swal(gmmValAlerts[&apos;GMM_WARNING&apos;], &quot;There are no active Service Categories in your account. Please create at least one category in Settings to start creating requests.&quot;)
            }, 3000);
        }
        if(!isChrome){
            setTimeout(function(){
                swal(gmmValAlerts[&apos;GMM_WARNING&apos;], gmmValAlerts[&quot;GMM_GOOGLE_CHROME_WARNING&quot;]);
                localStorage.setItem(&apos;browserAlertStatus&apos;, &apos;true&apos;);
            }, 4000);
        }
        var screenWidth = screen.width;
        if(screenWidth&lt;=1440){
            setTimeout(function(){
                swal(gmmValAlerts[&apos;GMM_WARNING&apos;], gmmValAlerts[&quot;GMM_SMALL_SCREEN_WARNING&quot;]);
                localStorage.setItem(&apos;browserAlertStatus&apos;, &apos;true&apos;);
            }, 6000);
        }
    }

    $(&apos;#network-status&apos;).html(&apos;&lt;div class=&quot;label&quot;&gt;&apos;+gmmValAlerts[&apos;GMM_NW_STATUS_MSG&apos;]+&apos;&amp;nbsp;&amp;nbsp;&apos;+gmmValAlerts[&apos;GMM_VAL_NW_CONNECTED_MSG&apos;]+&apos;&lt;/div&gt;&apos;).fadeOut(&apos;slow&apos;).fadeIn(&apos;slow&apos;);
    $(&apos;.nano1&apos;).removeClass(&apos;ajax-loader-kingsadmin&apos;);
    $(&apos;#load_contacts&apos;).removeClass(&apos;ajax-loader-kingsadmin&apos;);

    try
    {
        //        refreshOpenRequests();
        refreshContacts(0);
        var openedWindow = JSON.parse(localStorage.getItem(&apos;openedMsg&apos;));
        $.each(openedWindow, function(index, obj) {

            var explode = obj.split(&quot;#&quot;);

            if (explode[0] == &quot;CUSTOMER&quot;)
            {
                if( (explode[1])*1 ) {
                    getOldChat(removeChr(index), 1, explode[1]);
                    //console.log(&quot;Appending opened reference to widget table row.&quot;);
                    addOpenedRefToOpenRow(removeChr(index), explode[1]);
                }else{
                    if(!$(index).is(&apos;:visible&apos;) &amp;&amp; ($(&apos;.initialRequestWindow&apos;).length == 0))
                        getOldChat(removeChr(index), 1, explode[1]);
                }
            }
            else
            {
                var newIndex = appendChr(parseInt(removeChr(index)) -1);

                var internalChatId = removeChr(index);




                var reqData = new Object();
                reqData.chatId = internalChatId;
                ajax_loader_disable();
                $.ajax({
                    type: &apos;POST&apos;,
                    dataType: &quot;json&quot;,
                    url: baseUrl + &quot;/home/getrequestdetailsbyinternalchatid&quot;,
                    data: reqData,
                    success: function(data) {
                        if(data[0]){
                            setTimeout(function(){
                                $(&quot;#serviceregisterUpdateCHT&quot;+data[0][&apos;SR_ChatId&apos;]+&quot; .chtwitbut&quot;).click();
                            }, 2000);
                        }
                    }
                });
            }

        });
        if(companySelectedPackageId == 1) {
            if($.isEmptyObject(openedWindow)) {
                if($(&apos;.customerChat&apos;).length == 0) {
                    send_internalV3();
                }
            } else if (typeof(openedWindow.no) != &quot;undefined&quot;) { // Login condition
                if($(&apos;.customerChat&apos;).length == 0) {
                    send_internalV3();
                }
            }
        }
        else {
            if($.isEmptyObject(openedWindow)) {
                if($(&apos;.initialRequestWindow&apos;).length == 0) {
                    send_internalV3();
                }
            } else if (typeof(openedWindow.no) != &quot;undefined&quot;) { // Login condition
                if($(&apos;.initialRequestWindow&apos;).length == 0) {
                    send_internalV3();
                }
            }
        }

    }
    catch (e) {
        //        console.log(e);
    }

});
socket.on(&apos;disconnect&apos;, function(err) {
    errorconnection();
    socket.io.reconnect();
});
socket.on(&apos;reconnect&apos;, function(message) {

});
socket.on(&apos;reconnecting&apos;, function(message) {

});
socket.on(&apos;connecting&apos;, function(message) {

    //$(&apos;#msg&apos;).html(&quot;&lt;p class=&apos;ui-state-error ui-corner-all socket-connecting&apos; &gt;Connecting...&lt;/p&gt;&quot;);
    // $(&apos;#msg&apos;).html(&quot;&lt;div class=&apos;label label-warning&apos; &gt;&quot;+gmmValAlerts[&apos;GMM_VAL_CONNECTING_MSG&apos;]+&quot;...&lt;/div&gt;&quot;).fadeOut(&apos;slow&apos;).fadeIn(&apos;slow&apos;);
    //$(&apos;#network-status&apos;).removeClass(&apos;btn-success&apos;);
    //$(&apos;#network-status&apos;).addClass(&apos;btn-warning&apos;);
    $(&apos;#network-status&apos;).html(gmmValAlerts[&apos;GMM_VAL_CONNECTING_MSG&apos;]+&apos;...&apos;);

});
// sample emit function
socket.emit(&apos;clientLoginInternal&apos;,
        {&quot;userid&quot;: &quot;704&quot;,
            &quot;companyid&quot;: &quot;339&quot;,
            &quot;username&quot;: &quot;rosepv123+1@gmail.com&quot;,
            &quot;password&quot;: &quot;abcd1234&quot;,
            &quot;usertype&quot;: &quot;Internal&quot;,
            &quot;usergroupid&quot;: &quot;3&quot;, //TODO
            &quot;usergroup&quot;: &quot;Agent&quot;,
            &quot;firstname&quot;: &quot;Dual&quot;,
            &quot;lastname&quot;: &quot;Rose&quot;,
            &quot;propertycode&quot;: &quot;&quot;,
            &quot;chatcategoryid&quot;: &quot;&quot;,
            &quot;chatcategory&quot;: &apos;&apos;, //TODO
            &quot;uniqueid&quot;: &quot;haqrqdrkkt7ab515876afbl157&quot;,
            &quot;targetuniqueid&quot;: &quot;&quot;}); </stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler" enabled="false">
          <stringProp name="scriptLanguage">javascript</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script"> var ioOptions={host:&quot;adarshtest1.messageboxapp.com&quot;, hostname:&quot;adarshtest1.messageboxapp.com&quot;, path:&quot;/socket.io&quot;, port:&quot;443&quot;, query:{userid: &quot;704&quot;, email: &quot;rosepv123+1@gmail.com&quot;, namespace: &quot;gmm-adarshtest1&quot;}, &quot;reconnection limit&quot;:1000, secure:true};
 
 socket = io.connect(adarshtest1.messageboxapp.com, ioOptions);
           var customerToAgentAutomatedMessageId = Math.floor(Math.random()*9000000) + 1000000+&apos;&apos;+Date.now();
            var chatIdAutomatedId = Date.now();
            var chatId = &apos;704&apos;+chatIdAutomatedId;
            var p = {
                &quot;chatid&quot;: Date.now(),
                &quot;userid&quot;: &quot;704&quot;,
                &quot;messageid&quot;: customerToAgentAutomatedMessageId,
                &quot;salutation&quot;: &quot;&quot;,
                &quot;username&quot;: &quot;rosepv123+1@gmail.com&quot;,
                &quot;password&quot;: &quot;abcd1234&quot;,
                &quot;usertype&quot;: &quot;Internal&quot;,
                &quot;usergroupid&quot;: 5,
                &quot;usergroup&quot;: &quot;Guest&quot;,
                &quot;firstname&quot;: &quot;Duel&quot;,
                &quot;lastname&quot;: &quot;Rose&quot;,
                &quot;propertycode&quot;: &quot;cPropertyCode&quot;,
                &quot;roomnumber&quot;: 112,
                &quot;confirmationnumber&quot;: &quot;cConfirm&quot;,
                &quot;reservationid&quot;: &quot;cReservationId&quot;,
                &quot;currentuserstatus&quot;: &quot;cStatus&quot;,
                &quot;chatcategoryid&quot;: &quot;1&quot;,
                &quot;chatcategory&quot;: &quot;Conceirge&quot;,
                &quot;preconfmessage&quot;: &quot;&quot;,
                &quot;shortcutid&quot;: &quot;&quot;,
                &quot;shortcut&quot;: &quot;&quot;,
                &quot;shortpreconfmessage&quot;: &quot;&quot;,
                &quot;targetuserid&quot;: &quot;&quot;, 
                &quot;targetusername&quot;:&quot;&quot;,
                &quot;message&quot;: &quot;Customer request created by Agent : &quot;,
                &quot;timeoutMessage&quot;: &quot; The request is outside Location&apos;s working hours, Will be processed on next working day.&quot;,
                &quot;uniqueid&quot;: &quot;&quot;,
                &quot;targetuniqueid&quot;: &quot;&quot;,
                &quot;chattype&quot;: &quot;CUSTOMER&quot;,
                &quot;chatmediatype&quot;: &quot;&quot;,
                &quot;chatmedianame&quot;: &quot;&quot;,
                &quot;chatmedia&quot;: &quot;&quot;,
                &quot;chatmediasize&quot;: &quot;&quot;,
                &quot;companyid&quot;: &quot;339&quot;,
                &quot;companylocationid&quot;:  &quot;&quot;,
                &quot;companylocationname&quot;: &quot;&quot;

            };

            socket.emit(&apos;initiateRequest&apos;, p);</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <KeystoreConfig guiclass="TestBeanGUI" testclass="KeystoreConfig" testname="Keystore Configuration" enabled="false">
          <stringProp name="clientCertAliasVarName"></stringProp>
          <stringProp name="endIndex"></stringProp>
          <stringProp name="preload">True</stringProp>
          <stringProp name="startIndex"></stringProp>
        </KeystoreConfig>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Home page" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments"/>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">home</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header manager" enabled="false">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="Upgrade-Insecure-Requests" elementType="Header">
                <stringProp name="Header.name">Upgrade-Insecure-Requests</stringProp>
                <stringProp name="Header.value">1</stringProp>
              </elementProp>
              <elementProp name="Accept" elementType="Header">
                <stringProp name="Header.name">Accept</stringProp>
                <stringProp name="Header.value">text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</stringProp>
              </elementProp>
              <elementProp name="Referer" elementType="Header">
                <stringProp name="Header.name">Referer</stringProp>
                <stringProp name="Header.value">https://adarshtest1.getmymessage.co/index</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <ConstantTimer guiclass="ConstantTimerGui" testclass="ConstantTimer" testname="Constant Timer" enabled="false">
            <stringProp name="ConstantTimer.delay">7428</stringProp>
          </ConstantTimer>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="SocketGet" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="t" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">true</boolProp>
                <stringProp name="Argument.name">t</stringProp>
                <stringProp name="Argument.value">1528987561812-3</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="namespace" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">true</boolProp>
                <stringProp name="Argument.name">namespace</stringProp>
                <stringProp name="Argument.value">gmm-adarshtest1</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="EIO" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">true</boolProp>
                <stringProp name="Argument.name">EIO</stringProp>
                <stringProp name="Argument.value">3</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="transport" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">true</boolProp>
                <stringProp name="Argument.name">transport</stringProp>
                <stringProp name="Argument.value">polling</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="userid" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">true</boolProp>
                <stringProp name="Argument.name">userid</stringProp>
                <stringProp name="Argument.value">704</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="email" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">true</boolProp>
                <stringProp name="Argument.name">email</stringProp>
                <stringProp name="Argument.value">rosepv123+1@gmail.com</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">adarshtest1.messageboxapp.com</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">socket.io/</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="Origin" elementType="Header">
                <stringProp name="Header.name">Origin</stringProp>
                <stringProp name="Header.value">https://adarshtest1.getmymessage.co</stringProp>
              </elementProp>
              <elementProp name="Accept" elementType="Header">
                <stringProp name="Header.name">Accept</stringProp>
                <stringProp name="Header.value">*/*</stringProp>
              </elementProp>
              <elementProp name="Referer" elementType="Header">
                <stringProp name="Header.name">Referer</stringProp>
                <stringProp name="Header.value">https://adarshtest1.getmymessage.co/home</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Content-type</stringProp>
                <stringProp name="Header.value">text/plain;charset=UTF-8</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Host</stringProp>
                <stringProp name="Header.value">adarshtest1.messageboxapp.com</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="Regular Expression Extractor" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">sid</stringProp>
            <stringProp name="RegexExtractor.regex">{&quot;sid&quot;:&quot;(.+?)&quot;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Socket Get" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments"/>
          </elementProp>
          <stringProp name="HTTPSampler.domain">adarshtest1.messageboxapp.com</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">socket.io/?userid=704&amp;email=rosepv123%2B1%40gmail.com&amp;namespace=gmm-adarshtest1&amp;EIO=3&amp;transport=polling&amp;t=1528987561812-3</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="Origin" elementType="Header">
                <stringProp name="Header.name">Origin</stringProp>
                <stringProp name="Header.value">https://adarshtest1.getmymessage.co</stringProp>
              </elementProp>
              <elementProp name="Content-type" elementType="Header">
                <stringProp name="Header.name">Content-type</stringProp>
                <stringProp name="Header.value">text/plain;charset=UTF-8</stringProp>
              </elementProp>
              <elementProp name="Accept" elementType="Header">
                <stringProp name="Header.name">Accept</stringProp>
                <stringProp name="Header.value">*/*</stringProp>
              </elementProp>
              <elementProp name="Referer" elementType="Header">
                <stringProp name="Header.name">Referer</stringProp>
                <stringProp name="Header.value">https://adarshtest1.getmymessage.co/home</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Host</stringProp>
                <stringProp name="Header.value">adarshtest1.messageboxapp.com</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor" enabled="false">
            <stringProp name="JSONPostProcessor.referenceNames">sessionid</stringProp>
            <stringProp name="JSONPostProcessor.jsonPathExprs">$.0.:.sid</stringProp>
            <stringProp name="JSONPostProcessor.match_numbers">1</stringProp>
            <stringProp name="Sample.scope">all</stringProp>
          </JSONPostProcessor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="Regular Expression Extractor" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">sid</stringProp>
            <stringProp name="RegexExtractor.regex">{&quot;sid&quot;:&quot;(.+?)&quot;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Socket Post" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments"/>
          </elementProp>
          <stringProp name="HTTPSampler.domain">adarshtest1.messageboxapp.com</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">socket.io/?userid=704&amp;email=rosepv123%2B1%40gmail.com&amp;namespace=gmm-adarshtest1&amp;EIO=3&amp;transport=polling&amp;t=1528987561812-3&amp;sid=${sid}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="Origin" elementType="Header">
                <stringProp name="Header.name">Origin</stringProp>
                <stringProp name="Header.value">https://adarshtest1.getmymessage.co</stringProp>
              </elementProp>
              <elementProp name="Content-type" elementType="Header">
                <stringProp name="Header.name">Content-type</stringProp>
                <stringProp name="Header.value">text/plain;charset=UTF-8</stringProp>
              </elementProp>
              <elementProp name="Accept" elementType="Header">
                <stringProp name="Header.name">Accept</stringProp>
                <stringProp name="Header.value">*/*</stringProp>
              </elementProp>
              <elementProp name="Referer" elementType="Header">
                <stringProp name="Header.name">Referer</stringProp>
                <stringProp name="Header.value">https://adarshtest1.getmymessage.co/home</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Host</stringProp>
                <stringProp name="Header.value">adarshtest1.messageboxapp.com</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="RegisterRequest" enabled="false">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
	&quot;SR_CategoryId&quot;= &quot;1&quot;,&#xd;
&quot;SR_CategoryName&quot;= &quot;REQCIV&quot;,&#xd;
&quot;SR_CreatedUserId&quot;= &quot;704&quot;,&#xd;
&quot;SR_Subject&quot;=&quot;&quot;,&#xd;
&quot;SR_Request&quot;=&quot;&quot;,&#xd;
&quot;UR_UserGroupId&quot;=&quot;3&quot;,&#xd;
&quot;SR_ChatId&quot;=&quot;70400143&quot;,&#xd;
&quot;SR_InternalChatId&quot;=&quot;&quot;,&#xd;
&quot;SR_ServiceStandardId&quot;=&quot;9089&quot;,&#xd;
&quot;SR_ServiceCategoryId&quot;=&quot;&quot;,&#xd;
&quot;SR_ServiceCategory&quot;=&quot;34&quot;,&#xd;
&quot;SR_CompanyId&quot;=&quot;339&quot;,&#xd;
&quot;SR_CompanyLocationId&quot;=&quot;&quot;,&#xd;
&quot;SR_CompanyLocationName&quot;=&quot;&quot;,&#xd;
&quot;SR_ServiceArea&quot;=&quot;&quot;,&#xd;
&quot;SR_ServiceStandardName&quot;=&quot;&quot;,&#xd;
&quot;SR_ServiceStandardTime&quot;=&quot;&quot;,&#xd;
&quot;SR_ServiceStandardTimeValue&quot;=&quot;&quot;,&#xd;
&quot;SR_ServiceStandardTimeUnit&quot;=&quot;&quot;,&#xd;
&quot;SR_MessageId&quot;=&quot;&quot;,&#xd;
&quot;SR_ServiceAreaId&quot;=&quot;&quot;,&#xd;
&quot;SR_PriorityName&quot;=&quot;&quot;,&#xd;
&quot;SR_PriorityId&quot;=&quot;&quot;,&#xd;
&quot;SR_CreatedUserFirstName&quot;=&quot;&quot;,&#xd;
&quot;SR_CreatedUserLastName&quot;=&quot;&quot;&#xd;
}              </stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">webservice/gmmregisterrequest/</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname="JSR223 PreProcessor" enabled="false">
            <stringProp name="scriptLanguage">javascript</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="cacheKey">true</stringProp>
            <stringProp name="script">!function(e){if(&quot;object&quot;==typeof exports&amp;&amp;&quot;undefined&quot;!=typeof module)module.exports=e();else if(&quot;function&quot;==typeof define&amp;&amp;define.amd)define([],e);else{var f;&quot;undefined&quot;!=typeof window?f=window:&quot;undefined&quot;!=typeof global?f=global:&quot;undefined&quot;!=typeof self&amp;&amp;(f=self),f.io=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==&quot;function&quot;&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);throw new Error(&quot;Cannot find module &apos;&quot;+o+&quot;&apos;&quot;)}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==&quot;function&quot;&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){

module.exports = _dereq_(&apos;./lib/&apos;);

},{&quot;./lib/&quot;:2}],2:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var url = _dereq_(&apos;./url&apos;);
var parser = _dereq_(&apos;socket.io-parser&apos;);
var Manager = _dereq_(&apos;./manager&apos;);
var debug = _dereq_(&apos;debug&apos;)(&apos;socket.io-client&apos;);

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io(&apos;http://localhost/a&apos;);`
 *   `io(&apos;http://localhost/b&apos;);`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup(uri, opts) {
  if (typeof uri == &apos;object&apos;) {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var io;

  if (opts.forceNew || opts[&apos;force new connection&apos;] || false === opts.multiplex) {
    debug(&apos;ignoring socket cache for %s&apos;, source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug(&apos;new io instance for %s&apos;, source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }

  return io.socket(parsed.path);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = _dereq_(&apos;./manager&apos;);
exports.Socket = _dereq_(&apos;./socket&apos;);

},{&quot;./manager&quot;:3,&quot;./socket&quot;:5,&quot;./url&quot;:6,&quot;debug&quot;:10,&quot;socket.io-parser&quot;:46}],3:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var url = _dereq_(&apos;./url&apos;);
var eio = _dereq_(&apos;engine.io-client&apos;);
var Socket = _dereq_(&apos;./socket&apos;);
var Emitter = _dereq_(&apos;component-emitter&apos;);
var parser = _dereq_(&apos;socket.io-parser&apos;);
var on = _dereq_(&apos;./on&apos;);
var bind = _dereq_(&apos;component-bind&apos;);
var object = _dereq_(&apos;object-component&apos;);
var debug = _dereq_(&apos;debug&apos;)(&apos;socket.io-client:manager&apos;);
var indexOf = _dereq_(&apos;indexof&apos;);
var Backoff = _dereq_(&apos;backo2&apos;);

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts){
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri &amp;&amp; (&apos;object&apos; == typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || &apos;/socket.io&apos;;
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = &apos;closed&apos;;
  this.uri = uri;
  this.connected = [];
  this.encoding = false;
  this.packetBuffer = [];
  this.encoder = new parser.Encoder();
  this.decoder = new parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function() {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function(){
  for (var nsp in this.nsps) {
    this.nsps[nsp].id = this.engine.id;
  }
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function(v){
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function(v){
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function(v){
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff &amp;&amp; this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function(v){
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff &amp;&amp; this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function(v){
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff &amp;&amp; this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function(v){
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function() {
  // Only try to reconnect if it&apos;s the first time we&apos;re connecting
  if (!this.reconnecting &amp;&amp; this._reconnection &amp;&amp; this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};


/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function(fn){
  debug(&apos;readyState %s&apos;, this.readyState);
  if (~this.readyState.indexOf(&apos;open&apos;)) return this;

  debug(&apos;opening %s&apos;, this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = &apos;opening&apos;;
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, &apos;open&apos;, function() {
    self.onopen();
    fn &amp;&amp; fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, &apos;error&apos;, function(data){
    debug(&apos;connect_error&apos;);
    self.cleanup();
    self.readyState = &apos;closed&apos;;
    self.emitAll(&apos;connect_error&apos;, data);
    if (fn) {
      var err = new Error(&apos;Connection error&apos;);
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug(&apos;connect attempt will timeout after %d&apos;, timeout);

    // set timer
    var timer = setTimeout(function(){
      debug(&apos;connect attempt timed out after %d&apos;, timeout);
      openSub.destroy();
      socket.close();
      socket.emit(&apos;error&apos;, &apos;timeout&apos;);
      self.emitAll(&apos;connect_timeout&apos;, timeout);
    }, timeout);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function(){
  debug(&apos;open&apos;);

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = &apos;open&apos;;
  this.emit(&apos;open&apos;);

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, &apos;data&apos;, bind(this, &apos;ondata&apos;)));
  this.subs.push(on(this.decoder, &apos;decoded&apos;, bind(this, &apos;ondecoded&apos;)));
  this.subs.push(on(socket, &apos;error&apos;, bind(this, &apos;onerror&apos;)));
  this.subs.push(on(socket, &apos;close&apos;, bind(this, &apos;onclose&apos;)));
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function(data){
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function(packet) {
  this.emit(&apos;packet&apos;, packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function(err){
  debug(&apos;error&apos;, err);
  this.emitAll(&apos;error&apos;, err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function(nsp){
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on(&apos;connect&apos;, function(){
      socket.id = self.engine.id;
      if (!~indexOf(self.connected, socket)) {
        self.connected.push(socket);
      }
    });
  }
  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function(socket){
  var index = indexOf(this.connected, socket);
  if (~index) this.connected.splice(index, 1);
  if (this.connected.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function(packet){
  debug(&apos;writing packet %j&apos;, packet);
  var self = this;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function(encodedPackets) {
      for (var i = 0; i &lt; encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i]);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function() {
  if (this.packetBuffer.length &gt; 0 &amp;&amp; !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function(){
  var sub;
  while (sub = this.subs.shift()) sub.destroy();

  this.packetBuffer = [];
  this.encoding = false;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function(){
  this.skipReconnect = true;
  this.backoff.reset();
  this.readyState = &apos;closed&apos;;
  this.engine &amp;&amp; this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function(reason){
  debug(&apos;close&apos;);
  this.cleanup();
  this.backoff.reset();
  this.readyState = &apos;closed&apos;;
  this.emit(&apos;close&apos;, reason);
  if (this._reconnection &amp;&amp; !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function(){
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts &gt;= this._reconnectionAttempts) {
    debug(&apos;reconnect failed&apos;);
    this.backoff.reset();
    this.emitAll(&apos;reconnect_failed&apos;);
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug(&apos;will wait %dms before reconnect attempt&apos;, delay);

    this.reconnecting = true;
    var timer = setTimeout(function(){
      if (self.skipReconnect) return;

      debug(&apos;attempting reconnect&apos;);
      self.emitAll(&apos;reconnect_attempt&apos;, self.backoff.attempts);
      self.emitAll(&apos;reconnecting&apos;, self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function(err){
        if (err) {
          debug(&apos;reconnect attempt error&apos;);
          self.reconnecting = false;
          self.reconnect();
          self.emitAll(&apos;reconnect_error&apos;, err.data);
        } else {
          debug(&apos;reconnect success&apos;);
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function(){
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll(&apos;reconnect&apos;, attempt);
};

},{&quot;./on&quot;:4,&quot;./socket&quot;:5,&quot;./url&quot;:6,&quot;backo2&quot;:7,&quot;component-bind&quot;:8,&quot;component-emitter&quot;:9,&quot;debug&quot;:10,&quot;engine.io-client&quot;:11,&quot;indexof&quot;:42,&quot;object-component&quot;:43,&quot;socket.io-parser&quot;:46}],4:[function(_dereq_,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function(){
      obj.removeListener(ev, fn);
    }
  };
}

},{}],5:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var parser = _dereq_(&apos;socket.io-parser&apos;);
var Emitter = _dereq_(&apos;component-emitter&apos;);
var toArray = _dereq_(&apos;to-array&apos;);
var on = _dereq_(&apos;./on&apos;);
var bind = _dereq_(&apos;component-bind&apos;);
var debug = _dereq_(&apos;debug&apos;)(&apos;socket.io-client:socket&apos;);
var hasBin = _dereq_(&apos;has-binary&apos;);

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can&apos;t be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket(io, nsp){
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  if (this.io.autoConnect) this.open();
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function() {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, &apos;open&apos;, bind(this, &apos;onopen&apos;)),
    on(io, &apos;packet&apos;, bind(this, &apos;onpacket&apos;)),
    on(io, &apos;close&apos;, bind(this, &apos;onclose&apos;))
  ];
};

/**
 * &quot;Opens&quot; the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function(){
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if (&apos;open&apos; == this.io.readyState) this.onopen();
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function(){
  var args = toArray(arguments);
  args.unshift(&apos;message&apos;);
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it&apos;s emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function(ev){
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var parserType = parser.EVENT; // default
  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
  var packet = { type: parserType, data: args };

  // event ack callback
  if (&apos;function&apos; == typeof args[args.length - 1]) {
    debug(&apos;emitting packet with ack id %d&apos;, this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function(packet){
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function(){
  debug(&apos;transport is open - connecting&apos;);

  // write connect packet if necessary
  if (&apos;/&apos; != this.nsp) {
    this.packet({ type: parser.CONNECT });
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function(reason){
  debug(&apos;close (%s)&apos;, reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit(&apos;disconnect&apos;, reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function(packet){
  if (packet.nsp != this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit(&apos;error&apos;, packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function(packet){
  var args = packet.data || [];
  debug(&apos;emitting event %j&apos;, args);

  if (null != packet.id) {
    debug(&apos;attaching ack callback to event&apos;);
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function(id){
  var self = this;
  var sent = false;
  return function(){
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug(&apos;sending ack %j&apos;, args);

    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
    self.packet({
      type: type,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function(packet){
  debug(&apos;calling ack %s with %j&apos;, packet.id, packet.data);
  var fn = this.acks[packet.id];
  fn.apply(this, packet.data);
  delete this.acks[packet.id];
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function(){
  this.connected = true;
  this.disconnected = false;
  this.emit(&apos;connect&apos;);
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function(){
  var i;
  for (i = 0; i &lt; this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i &lt; this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function(){
  debug(&apos;server disconnect (%s)&apos;, this.nsp);
  this.destroy();
  this.onclose(&apos;io server disconnect&apos;);
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don&apos;t get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function(){
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i &lt; this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function(){
  if (this.connected) {
    debug(&apos;performing disconnect (%s)&apos;, this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose(&apos;io client disconnect&apos;);
  }
  return this;
};

},{&quot;./on&quot;:4,&quot;component-bind&quot;:8,&quot;component-emitter&quot;:9,&quot;debug&quot;:10,&quot;has-binary&quot;:38,&quot;socket.io-parser&quot;:46,&quot;to-array&quot;:50}],6:[function(_dereq_,module,exports){
(function (global){

/**
 * Module dependencies.
 */

var parseuri = _dereq_(&apos;parseuri&apos;);
var debug = _dereq_(&apos;debug&apos;)(&apos;socket.io-client:url&apos;);

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc){
  var obj = uri;

  // default to window.location
  var loc = loc || global.location;
  if (null == uri) uri = loc.protocol + &apos;//&apos; + loc.host;

  // relative path support
  if (&apos;string&apos; == typeof uri) {
    if (&apos;/&apos; == uri.charAt(0)) {
      if (&apos;/&apos; == uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.hostname + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug(&apos;protocol-less url %s&apos;, uri);
      if (&apos;undefined&apos; != typeof loc) {
        uri = loc.protocol + &apos;//&apos; + uri;
      } else {
        uri = &apos;https://&apos; + uri;
      }
    }

    // parse
    debug(&apos;parse %s&apos;, uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = &apos;80&apos;;
    }
    else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = &apos;443&apos;;
    }
  }

  obj.path = obj.path || &apos;/&apos;;

  // define unique id
  obj.id = obj.protocol + &apos;://&apos; + obj.host + &apos;:&apos; + obj.port;
  // define href
  obj.href = obj.protocol + &apos;://&apos; + obj.host + (loc &amp;&amp; loc.port == obj.port ? &apos;&apos; : (&apos;:&apos; + obj.port));

  return obj;
}

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;debug&quot;:10,&quot;parseuri&quot;:44}],7:[function(_dereq_,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter &gt; 0 &amp;&amp; opts.jitter &lt;= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) &amp; 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],8:[function(_dereq_,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if (&apos;string&apos; == typeof fn) fn = obj[fn];
  if (&apos;function&apos; != typeof fn) throw new Error(&apos;bind() requires a function&apos;);
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],9:[function(_dereq_,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i &lt; callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i &lt; len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],10:[function(_dereq_,module,exports){

/**
 * Expose `debug()` as the module.
 */

module.exports = debug;

/**
 * Create a debugger with the given `name`.
 *
 * @param {String} name
 * @return {Type}
 * @api public
 */

function debug(name) {
  if (!debug.enabled(name)) return function(){};

  return function(fmt){
    fmt = coerce(fmt);

    var curr = new Date;
    var ms = curr - (debug[name] || curr);
    debug[name] = curr;

    fmt = name
      + &apos; &apos;
      + fmt
      + &apos; +&apos; + debug.humanize(ms);

    // This hackery is required for IE8
    // where `console.log` doesn&apos;t have &apos;apply&apos;
    window.console
      &amp;&amp; console.log
      &amp;&amp; Function.prototype.apply.call(console.log, console, arguments);
  }
}

/**
 * The currently active debug mode names.
 */

debug.names = [];
debug.skips = [];

/**
 * Enables a debug mode by name. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} name
 * @api public
 */

debug.enable = function(name) {
  try {
    localStorage.debug = name;
  } catch(e){}

  var split = (name || &apos;&apos;).split(/[\s,]+/)
    , len = split.length;

  for (var i = 0; i &lt; len; i++) {
    name = split[i].replace(&apos;*&apos;, &apos;.*?&apos;);
    if (name[0] === &apos;-&apos;) {
      debug.skips.push(new RegExp(&apos;^&apos; + name.substr(1) + &apos;$&apos;));
    }
    else {
      debug.names.push(new RegExp(&apos;^&apos; + name + &apos;$&apos;));
    }
  }
};

/**
 * Disable debug output.
 *
 * @api public
 */

debug.disable = function(){
  debug.enable(&apos;&apos;);
};

/**
 * Humanize the given `ms`.
 *
 * @param {Number} m
 * @return {String}
 * @api private
 */

debug.humanize = function(ms) {
  var sec = 1000
    , min = 60 * 1000
    , hour = 60 * min;

  if (ms &gt;= hour) return (ms / hour).toFixed(1) + &apos;h&apos;;
  if (ms &gt;= min) return (ms / min).toFixed(1) + &apos;m&apos;;
  if (ms &gt;= sec) return (ms / sec | 0) + &apos;s&apos;;
  return ms + &apos;ms&apos;;
};

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

debug.enabled = function(name) {
  for (var i = 0, len = debug.skips.length; i &lt; len; i++) {
    if (debug.skips[i].test(name)) {
      return false;
    }
  }
  for (var i = 0, len = debug.names.length; i &lt; len; i++) {
    if (debug.names[i].test(name)) {
      return true;
    }
  }
  return false;
};

/**
 * Coerce `val`.
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

// persist

try {
  if (window.localStorage) debug.enable(localStorage.debug);
} catch(e){}

},{}],11:[function(_dereq_,module,exports){

module.exports =  _dereq_(&apos;./lib/&apos;);

},{&quot;./lib/&quot;:12}],12:[function(_dereq_,module,exports){

module.exports = _dereq_(&apos;./socket&apos;);

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = _dereq_(&apos;engine.io-parser&apos;);

},{&quot;./socket&quot;:13,&quot;engine.io-parser&quot;:25}],13:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var transports = _dereq_(&apos;./transports&apos;);
var Emitter = _dereq_(&apos;component-emitter&apos;);
var debug = _dereq_(&apos;debug&apos;)(&apos;engine.io-client:socket&apos;);
var index = _dereq_(&apos;indexof&apos;);
var parser = _dereq_(&apos;engine.io-parser&apos;);
var parseuri = _dereq_(&apos;parseuri&apos;);
var parsejson = _dereq_(&apos;parsejson&apos;);
var parseqs = _dereq_(&apos;parseqs&apos;);

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Noop function.
 *
 * @api private
 */

function noop(){}

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts){
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri &amp;&amp; &apos;object&apos; == typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.host = uri.host;
    opts.secure = uri.protocol == &apos;https&apos; || uri.protocol == &apos;wss&apos;;
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  }

  this.secure = null != opts.secure ? opts.secure :
    (global.location &amp;&amp; &apos;https:&apos; == location.protocol);

  if (opts.host) {
    var pieces = opts.host.split(&apos;:&apos;);
    opts.hostname = pieces.shift();
    if (pieces.length) {
      opts.port = pieces.pop();
    } else if (!opts.port) {
      // if no port is specified manually, use the protocol default
      opts.port = this.secure ? &apos;443&apos; : &apos;80&apos;;
    }
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : &apos;localhost&apos;);
  this.port = opts.port || (global.location &amp;&amp; location.port ?
       location.port :
       (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if (&apos;string&apos; == typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || &apos;/engine.io&apos;).replace(/\/$/, &apos;&apos;) + &apos;/&apos;;
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || &apos;t&apos;;
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || [&apos;polling&apos;, &apos;websocket&apos;];
  this.readyState = &apos;&apos;;
  this.writeBuffer = [];
  this.callbackBuffer = [];
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized || null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = _dereq_(&apos;./transport&apos;);
Socket.transports = _dereq_(&apos;./transports&apos;);
Socket.parser = _dereq_(&apos;engine.io-parser&apos;);

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug(&apos;creating transport &quot;%s&quot;&apos;, name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    agent: this.agent,
    hostname: this.hostname,
    port: this.port,
    secure: this.secure,
    path: this.path,
    query: query,
    forceJSONP: this.forceJSONP,
    jsonp: this.jsonp,
    forceBase64: this.forceBase64,
    enablesXDR: this.enablesXDR,
    timestampRequests: this.timestampRequests,
    timestampParam: this.timestampParam,
    policyPort: this.policyPort,
    socket: this,
    pfx: this.pfx,
    key: this.key,
    passphrase: this.passphrase,
    cert: this.cert,
    ca: this.ca,
    ciphers: this.ciphers,
    rejectUnauthorized: this.rejectUnauthorized
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade &amp;&amp; Socket.priorWebsocketSuccess &amp;&amp; this.transports.indexOf(&apos;websocket&apos;) != -1) {
    transport = &apos;websocket&apos;;
  } else if (0 == this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function() {
      self.emit(&apos;error&apos;, &apos;No transports available&apos;);
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = &apos;opening&apos;;

  // Retry with the next transport if the transport is disabled (jsonp: false)
  var transport;
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function(transport){
  debug(&apos;setting transport %s&apos;, transport.name);
  var self = this;

  if (this.transport) {
    debug(&apos;clearing existing transport %s&apos;, this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on(&apos;drain&apos;, function(){
    self.onDrain();
  })
  .on(&apos;packet&apos;, function(packet){
    self.onPacket(packet);
  })
  .on(&apos;error&apos;, function(e){
    self.onError(e);
  })
  .on(&apos;close&apos;, function(){
    self.onClose(&apos;transport close&apos;);
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug(&apos;probing transport &quot;%s&quot;&apos;, name);
  var transport = this.createTransport(name, { probe: 1 })
    , failed = false
    , self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen(){
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary &amp;&amp; self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug(&apos;probe transport &quot;%s&quot; opened&apos;, name);
    transport.send([{ type: &apos;ping&apos;, data: &apos;probe&apos; }]);
    transport.once(&apos;packet&apos;, function (msg) {
      if (failed) return;
      if (&apos;pong&apos; == msg.type &amp;&amp; &apos;probe&apos; == msg.data) {
        debug(&apos;probe transport &quot;%s&quot; pong&apos;, name);
        self.upgrading = true;
        self.emit(&apos;upgrading&apos;, transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = &apos;websocket&apos; == transport.name;

        debug(&apos;pausing current transport &quot;%s&quot;&apos;, self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if (&apos;closed&apos; == self.readyState) return;
          debug(&apos;changing transport and sending upgrade packet&apos;);

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: &apos;upgrade&apos; }]);
          self.emit(&apos;upgrade&apos;, transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug(&apos;probe transport &quot;%s&quot; failed&apos;, name);
        var err = new Error(&apos;probe error&apos;);
        err.transport = transport.name;
        self.emit(&apos;upgradeError&apos;, err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  //Handle any error that happens while probing
  function onerror(err) {
    var error = new Error(&apos;probe error: &apos; + err);
    error.transport = transport.name;

    freezeTransport();

    debug(&apos;probe transport &quot;%s&quot; failed because of error: %s&apos;, name, err);

    self.emit(&apos;upgradeError&apos;, error);
  }

  function onTransportClose(){
    onerror(&quot;transport closed&quot;);
  }

  //When the socket is closed while we&apos;re probing
  function onclose(){
    onerror(&quot;socket closed&quot;);
  }

  //When the socket is upgraded while we&apos;re probing
  function onupgrade(to){
    if (transport &amp;&amp; to.name != transport.name) {
      debug(&apos;&quot;%s&quot; works - aborting &quot;%s&quot;&apos;, to.name, transport.name);
      freezeTransport();
    }
  }

  //Remove all listeners on the transport and on self
  function cleanup(){
    transport.removeListener(&apos;open&apos;, onTransportOpen);
    transport.removeListener(&apos;error&apos;, onerror);
    transport.removeListener(&apos;close&apos;, onTransportClose);
    self.removeListener(&apos;close&apos;, onclose);
    self.removeListener(&apos;upgrading&apos;, onupgrade);
  }

  transport.once(&apos;open&apos;, onTransportOpen);
  transport.once(&apos;error&apos;, onerror);
  transport.once(&apos;close&apos;, onTransportClose);

  this.once(&apos;close&apos;, onclose);
  this.once(&apos;upgrading&apos;, onupgrade);

  transport.open();

};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug(&apos;socket open&apos;);
  this.readyState = &apos;open&apos;;
  Socket.priorWebsocketSuccess = &apos;websocket&apos; == this.transport.name;
  this.emit(&apos;open&apos;);
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if (&apos;open&apos; == this.readyState &amp;&amp; this.upgrade &amp;&amp; this.transport.pause) {
    debug(&apos;starting upgrade probes&apos;);
    for (var i = 0, l = this.upgrades.length; i &lt; l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if (&apos;opening&apos; == this.readyState || &apos;open&apos; == this.readyState) {
    debug(&apos;socket receive: type &quot;%s&quot;, data &quot;%s&quot;&apos;, packet.type, packet.data);

    this.emit(&apos;packet&apos;, packet);

    // Socket is live - any packet counts
    this.emit(&apos;heartbeat&apos;);

    switch (packet.type) {
      case &apos;open&apos;:
        this.onHandshake(parsejson(packet.data));
        break;

      case &apos;pong&apos;:
        this.setPing();
        break;

      case &apos;error&apos;:
        var err = new Error(&apos;server error&apos;);
        err.code = packet.data;
        this.emit(&apos;error&apos;, err);
        break;

      case &apos;message&apos;:
        this.emit(&apos;data&apos;, packet.data);
        this.emit(&apos;message&apos;, packet.data);
        break;
    }
  } else {
    debug(&apos;packet received with socket readyState &quot;%s&quot;&apos;, this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit(&apos;handshake&apos;, data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if  (&apos;closed&apos; == this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener(&apos;heartbeat&apos;, this.onHeartbeat);
  this.on(&apos;heartbeat&apos;, this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if (&apos;closed&apos; == self.readyState) return;
    self.onClose(&apos;ping timeout&apos;);
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug(&apos;writing ping packet - expecting pong within %sms&apos;, self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api public
*/

Socket.prototype.ping = function () {
  this.sendPacket(&apos;ping&apos;);
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function() {
  for (var i = 0; i &lt; this.prevBufferLen; i++) {
    if (this.callbackBuffer[i]) {
      this.callbackBuffer[i]();
    }
  }

  this.writeBuffer.splice(0, this.prevBufferLen);
  this.callbackBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (this.writeBuffer.length == 0) {
    this.emit(&apos;drain&apos;);
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if (&apos;closed&apos; != this.readyState &amp;&amp; this.transport.writable &amp;&amp;
    !this.upgrading &amp;&amp; this.writeBuffer.length) {
    debug(&apos;flushing %d packets in socket&apos;, this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit(&apos;flush&apos;);
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, fn) {
  this.sendPacket(&apos;message&apos;, msg, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, fn) {
  if (&apos;closing&apos; == this.readyState || &apos;closed&apos; == this.readyState) {
    return;
  }

  var packet = { type: type, data: data };
  this.emit(&apos;packetCreate&apos;, packet);
  this.writeBuffer.push(packet);
  this.callbackBuffer.push(fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if (&apos;opening&apos; == this.readyState || &apos;open&apos; == this.readyState) {
    this.readyState = &apos;closing&apos;;

    var self = this;

    function close() {
      self.onClose(&apos;forced close&apos;);
      debug(&apos;socket closing - telling transport to close&apos;);
      self.transport.close();
    }

    function cleanupAndClose() {
      self.removeListener(&apos;upgrade&apos;, cleanupAndClose);
      self.removeListener(&apos;upgradeError&apos;, cleanupAndClose);
      close();
    }

    function waitForUpgrade() {
      // wait for upgrade to finish since we can&apos;t send packets while pausing a transport
      self.once(&apos;upgrade&apos;, cleanupAndClose);
      self.once(&apos;upgradeError&apos;, cleanupAndClose);
    }

    if (this.writeBuffer.length) {
      this.once(&apos;drain&apos;, function() {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug(&apos;socket error %j&apos;, err);
  Socket.priorWebsocketSuccess = false;
  this.emit(&apos;error&apos;, err);
  this.onClose(&apos;transport error&apos;, err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if (&apos;opening&apos; == this.readyState || &apos;open&apos; == this.readyState || &apos;closing&apos; == this.readyState) {
    debug(&apos;socket close with reason: &quot;%s&quot;&apos;, reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // clean buffers in next tick, so developers can still
    // grab the buffers on `close` event
    setTimeout(function() {
      self.writeBuffer = [];
      self.callbackBuffer = [];
      self.prevBufferLen = 0;
    }, 0);

    // stop event from firing again for transport
    this.transport.removeAllListeners(&apos;close&apos;);

    // ensure transport won&apos;t stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = &apos;closed&apos;;

    // clear session id
    this.id = null;

    // emit close event
    this.emit(&apos;close&apos;, reason, desc);
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i&lt;j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;./transport&quot;:14,&quot;./transports&quot;:15,&quot;component-emitter&quot;:9,&quot;debug&quot;:22,&quot;engine.io-parser&quot;:25,&quot;indexof&quot;:42,&quot;parsejson&quot;:34,&quot;parseqs&quot;:35,&quot;parseuri&quot;:36}],14:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var parser = _dereq_(&apos;engine.io-parser&apos;);
var Emitter = _dereq_(&apos;component-emitter&apos;);

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = &apos;&apos;;
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * A counter used to prevent collisions in the timestamps used
 * for cache busting.
 */

Transport.timestamps = 0;

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = &apos;TransportError&apos;;
  err.description = desc;
  this.emit(&apos;error&apos;, err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if (&apos;closed&apos; == this.readyState || &apos;&apos; == this.readyState) {
    this.readyState = &apos;opening&apos;;
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if (&apos;opening&apos; == this.readyState || &apos;open&apos; == this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function(packets){
  if (&apos;open&apos; == this.readyState) {
    this.write(packets);
  } else {
    throw new Error(&apos;Transport not open&apos;);
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = &apos;open&apos;;
  this.writable = true;
  this.emit(&apos;open&apos;);
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function(data){
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit(&apos;packet&apos;, packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = &apos;closed&apos;;
  this.emit(&apos;close&apos;);
};

},{&quot;component-emitter&quot;:9,&quot;engine.io-parser&quot;:25}],15:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies
 */

var XMLHttpRequest = _dereq_(&apos;xmlhttprequest&apos;);
var XHR = _dereq_(&apos;./polling-xhr&apos;);
var JSONP = _dereq_(&apos;./polling-jsonp&apos;);
var websocket = _dereq_(&apos;./websocket&apos;);

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts){
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = &apos;https:&apos; == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname != location.hostname || port != opts.port;
    xs = opts.secure != isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if (&apos;open&apos; in xhr &amp;&amp; !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error(&apos;JSONP disabled&apos;);
    return new JSONP(opts);
  }
}

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;./polling-jsonp&quot;:16,&quot;./polling-xhr&quot;:17,&quot;./websocket&quot;:19,&quot;xmlhttprequest&quot;:20}],16:[function(_dereq_,module,exports){
(function (global){

/**
 * Module requirements.
 */

var Polling = _dereq_(&apos;./polling&apos;);
var inherit = _dereq_(&apos;component-inherit&apos;);

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Callbacks count.
 */

var index = 0;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document &amp;&amp; global.addEventListener) {
    global.addEventListener(&apos;beforeunload&apos;, function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement(&apos;script&apos;);

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function(e){
    self.onError(&apos;jsonp poll error&apos;,e);
  };

  var insertAt = document.getElementsByTagName(&apos;script&apos;)[0];
  insertAt.parentNode.insertBefore(script, insertAt);
  this.script = script;

  var isUAgecko = &apos;undefined&apos; != typeof navigator &amp;&amp; /gecko/i.test(navigator.userAgent);
  
  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement(&apos;iframe&apos;);
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement(&apos;form&apos;);
    var area = document.createElement(&apos;textarea&apos;);
    var id = this.iframeId = &apos;eio_iframe_&apos; + this.index;
    var iframe;

    form.className = &apos;socketio&apos;;
    form.style.position = &apos;absolute&apos;;
    form.style.top = &apos;-1000px&apos;;
    form.style.left = &apos;-1000px&apos;;
    form.target = id;
    form.method = &apos;POST&apos;;
    form.setAttribute(&apos;accept-charset&apos;, &apos;utf-8&apos;);
    area.name = &apos;d&apos;;
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError(&apos;jsonp polling iframe removal error&apos;, e);
      }
    }

    try {
      // ie6 dynamic iframes with target=&quot;&quot; support (thanks Chris Lambacher)
      var html = &apos;&lt;iframe src=&quot;javascript:0&quot; name=&quot;&apos;+ self.iframeId +&apos;&quot;&gt;&apos;;
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement(&apos;iframe&apos;);
      iframe.name = self.iframeId;
      iframe.src = &apos;javascript:0&apos;;
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, &apos;\\\n&apos;);
  this.area.value = data.replace(rNewline, &apos;\\n&apos;);

  try {
    this.form.submit();
  } catch(e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function(){
      if (self.iframe.readyState == &apos;complete&apos;) {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;./polling&quot;:18,&quot;component-inherit&quot;:21}],17:[function(_dereq_,module,exports){
(function (global){
/**
 * Module requirements.
 */

var XMLHttpRequest = _dereq_(&apos;xmlhttprequest&apos;);
var Polling = _dereq_(&apos;./polling&apos;);
var Emitter = _dereq_(&apos;component-emitter&apos;);
var inherit = _dereq_(&apos;component-inherit&apos;);
var debug = _dereq_(&apos;debug&apos;)(&apos;engine.io-client:polling-xhr&apos;);

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty(){}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR(opts){
  Polling.call(this, opts);

  if (global.location) {
    var isSSL = &apos;https:&apos; == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname != global.location.hostname ||
      port != opts.port;
    this.xs = opts.secure != isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function(opts){
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function(data, fn){
  var isBinary = typeof data !== &apos;string&apos; &amp;&amp; data !== undefined;
  var req = this.request({ method: &apos;POST&apos;, data: data, isBinary: isBinary });
  var self = this;
  req.on(&apos;success&apos;, fn);
  req.on(&apos;error&apos;, function(err){
    self.onError(&apos;xhr post error&apos;, err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function(){
  debug(&apos;xhr poll&apos;);
  var req = this.request();
  var self = this;
  req.on(&apos;data&apos;, function(data){
    self.onData(data);
  });
  req.on(&apos;error&apos;, function(err){
    self.onError(&apos;xhr poll error&apos;, err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request(opts){
  this.method = opts.method || &apos;GET&apos;;
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined != opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function(){
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug(&apos;xhr open %s: %s&apos;, this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    if (this.supportsBinary) {
      // This has to be done after open because Firefox is stupid
      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
      xhr.responseType = &apos;arraybuffer&apos;;
    }

    if (&apos;POST&apos; == this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader(&apos;Content-type&apos;, &apos;application/octet-stream&apos;);
        } else {
          xhr.setRequestHeader(&apos;Content-type&apos;, &apos;text/plain;charset=UTF-8&apos;);
        }
      } catch (e) {}
    }

    // ie6 check
    if (&apos;withCredentials&apos; in xhr) {
      xhr.withCredentials = true;
    }

    if (this.hasXDR()) {
      xhr.onload = function(){
        self.onLoad();
      };
      xhr.onerror = function(){
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function(){
        if (4 != xhr.readyState) return;
        if (200 == xhr.status || 1223 == xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that&apos;s user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function(){
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug(&apos;xhr data %s&apos;, this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the &apos;error&apos; event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function() {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function(){
  this.emit(&apos;success&apos;);
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function(data){
  this.emit(&apos;data&apos;, data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function(err){
  this.emit(&apos;error&apos;, err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function(fromError){
  if (&apos;undefined&apos; == typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch(e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function(){
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader(&apos;Content-Type&apos;).split(&apos;;&apos;)[0];
    } catch (e) {}
    if (contentType === &apos;application/octet-stream&apos;) {
      data = this.xhr.response;
    } else {
      if (!this.supportsBinary) {
        data = this.xhr.responseText;
      } else {
        data = &apos;ok&apos;;
      }
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function(){
  return &apos;undefined&apos; !== typeof global.XDomainRequest &amp;&amp; !this.xs &amp;&amp; this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function(){
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

if (global.document) {
  Request.requestsCount = 0;
  Request.requests = {};
  if (global.attachEvent) {
    global.attachEvent(&apos;onunload&apos;, unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener(&apos;beforeunload&apos;, unloadHandler, false);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;./polling&quot;:18,&quot;component-emitter&quot;:9,&quot;component-inherit&quot;:21,&quot;debug&quot;:22,&quot;xmlhttprequest&quot;:20}],18:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var Transport = _dereq_(&apos;../transport&apos;);
var parseqs = _dereq_(&apos;parseqs&apos;);
var parser = _dereq_(&apos;engine.io-parser&apos;);
var inherit = _dereq_(&apos;component-inherit&apos;);
var debug = _dereq_(&apos;debug&apos;)(&apos;engine.io-client:polling&apos;);

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function() {
  var XMLHttpRequest = _dereq_(&apos;xmlhttprequest&apos;);
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling(opts){
  var forceBase64 = (opts &amp;&amp; opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = &apos;polling&apos;;

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function(){
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function(onPause){
  var pending = 0;
  var self = this;

  this.readyState = &apos;pausing&apos;;

  function pause(){
    debug(&apos;paused&apos;);
    self.readyState = &apos;paused&apos;;
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug(&apos;we are currently polling - waiting to pause&apos;);
      total++;
      this.once(&apos;pollComplete&apos;, function(){
        debug(&apos;pre-pause polling complete&apos;);
        --total || pause();
      });
    }

    if (!this.writable) {
      debug(&apos;we are currently writing - waiting to pause&apos;);
      total++;
      this.once(&apos;drain&apos;, function(){
        debug(&apos;pre-pause writing complete&apos;);
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function(){
  debug(&apos;polling&apos;);
  this.polling = true;
  this.doPoll();
  this.emit(&apos;poll&apos;);
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function(data){
  var self = this;
  debug(&apos;polling got data %s&apos;, data);
  var callback = function(packet, index, total) {
    // if its the first message we consider the transport open
    if (&apos;opening&apos; == self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if (&apos;close&apos; == packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if (&apos;closed&apos; != this.readyState) {
    // if we got data we&apos;re not polling
    this.polling = false;
    this.emit(&apos;pollComplete&apos;);

    if (&apos;open&apos; == this.readyState) {
      this.poll();
    } else {
      debug(&apos;ignoring poll - transport state &quot;%s&quot;&apos;, this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function(){
  var self = this;

  function close(){
    debug(&apos;writing close packet&apos;);
    self.write([{ type: &apos;close&apos; }]);
  }

  if (&apos;open&apos; == this.readyState) {
    debug(&apos;transport open - closing&apos;);
    close();
  } else {
    // in case we&apos;re trying to close while
    // handshaking is in progress (GH-164)
    debug(&apos;transport not open - deferring close&apos;);
    this.once(&apos;open&apos;, close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  var callbackfn = function() {
    self.writable = true;
    self.emit(&apos;drain&apos;);
  };

  var self = this;
  parser.encodePayload(packets, this.supportsBinary, function(data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? &apos;https&apos; : &apos;http&apos;;
  var port = &apos;&apos;;

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = +new Date + &apos;-&apos; + Transport.timestamps++;
  }

  if (!this.supportsBinary &amp;&amp; !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port &amp;&amp; ((&apos;https&apos; == schema &amp;&amp; this.port != 443) ||
     (&apos;http&apos; == schema &amp;&amp; this.port != 80))) {
    port = &apos;:&apos; + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = &apos;?&apos; + query;
  }

  return schema + &apos;://&apos; + this.hostname + port + this.path + query;
};

},{&quot;../transport&quot;:14,&quot;component-inherit&quot;:21,&quot;debug&quot;:22,&quot;engine.io-parser&quot;:25,&quot;parseqs&quot;:35,&quot;xmlhttprequest&quot;:20}],19:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var Transport = _dereq_(&apos;../transport&apos;);
var parser = _dereq_(&apos;engine.io-parser&apos;);
var parseqs = _dereq_(&apos;parseqs&apos;);
var inherit = _dereq_(&apos;component-inherit&apos;);
var debug = _dereq_(&apos;debug&apos;)(&apos;engine.io-client:websocket&apos;);

/**
 * `ws` exposes a WebSocket-compatible interface in
 * Node, or the `WebSocket` or `MozWebSocket` globals
 * in the browser.
 */

var WebSocket = _dereq_(&apos;ws&apos;);

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts){
  var forceBase64 = (opts &amp;&amp; opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = &apos;websocket&apos;;

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function(){
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var self = this;
  var uri = this.uri();
  var protocols = void(0);
  var opts = { agent: this.agent };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  this.ws = new WebSocket(uri, protocols, opts);

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  this.ws.binaryType = &apos;arraybuffer&apos;;
  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function(){
  var self = this;

  this.ws.onopen = function(){
    self.onOpen();
  };
  this.ws.onclose = function(){
    self.onClose();
  };
  this.ws.onmessage = function(ev){
    self.onData(ev.data);
  };
  this.ws.onerror = function(e){
    self.onError(&apos;websocket error&apos;, e);
  };
};

/**
 * Override `onData` to use a timer on iOS.
 * See: https://gist.github.com/mloughran/2052006
 *
 * @api private
 */

if (&apos;undefined&apos; != typeof navigator
  &amp;&amp; /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
  WS.prototype.onData = function(data){
    var self = this;
    setTimeout(function(){
      Transport.prototype.onData.call(self, data);
    }, 0);
  };
}

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  for (var i = 0, l = packets.length; i &lt; l; i++) {
    parser.encodePacket(packets[i], this.supportsBinary, function(data) {
      //Sometimes the websocket has already been closed but the browser didn&apos;t
      //have a chance of informing us about it yet, in that case send will
      //throw an error
      try {
        self.ws.send(data);
      } catch (e){
        debug(&apos;websocket closed before onclose event&apos;);
      }
    });
  }

  function ondrain() {
    self.writable = true;
    self.emit(&apos;drain&apos;);
  }
  // fake drain
  // defer to next tick to allow Socket to clear writeBuffer
  setTimeout(ondrain, 0);
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function(){
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function(){
  if (typeof this.ws !== &apos;undefined&apos;) {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? &apos;wss&apos; : &apos;ws&apos;;
  var port = &apos;&apos;;

  // avoid port if default for schema
  if (this.port &amp;&amp; ((&apos;wss&apos; == schema &amp;&amp; this.port != 443)
    || (&apos;ws&apos; == schema &amp;&amp; this.port != 80))) {
    port = &apos;:&apos; + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = +new Date;
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = &apos;?&apos; + query;
  }

  return schema + &apos;://&apos; + this.hostname + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function(){
  return !!WebSocket &amp;&amp; !(&apos;__initialize&apos; in WebSocket &amp;&amp; this.name === WS.prototype.name);
};

},{&quot;../transport&quot;:14,&quot;component-inherit&quot;:21,&quot;debug&quot;:22,&quot;engine.io-parser&quot;:25,&quot;parseqs&quot;:35,&quot;ws&quot;:37}],20:[function(_dereq_,module,exports){
// browser shim for xmlhttprequest module
var hasCORS = _dereq_(&apos;has-cors&apos;);

module.exports = function(opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if (&apos;undefined&apos; != typeof XMLHttpRequest &amp;&amp; (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if (&apos;undefined&apos; != typeof XDomainRequest &amp;&amp; !xscheme &amp;&amp; enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);
    } catch(e) { }
  }
}

},{&quot;has-cors&quot;:40}],21:[function(_dereq_,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],22:[function(_dereq_,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = _dereq_(&apos;./debug&apos;);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [
  &apos;lightseagreen&apos;,
  &apos;forestgreen&apos;,
  &apos;goldenrod&apos;,
  &apos;dodgerblue&apos;,
  &apos;darkorchid&apos;,
  &apos;crimson&apos;
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox &gt;= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support &quot;%c&quot; CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return (&apos;WebkitAppearance&apos; in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console &amp;&amp; (console.firebug || (console.exception &amp;&amp; console.table))) ||
    // is firefox &gt;= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &amp;&amp; parseInt(RegExp.$1, 10) &gt;= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? &apos;%c&apos; : &apos;&apos;)
    + this.namespace
    + (useColors ? &apos; %c&apos; : &apos; &apos;)
    + args[0]
    + (useColors ? &apos;%c &apos; : &apos; &apos;)
    + &apos;+&apos; + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = &apos;color: &apos; + this.color;
  args = [args[0], c, &apos;color: inherit&apos;].concat(Array.prototype.slice.call(args, 1));

  // the final &quot;%c&quot; is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if (&apos;%&apos; === match) return;
    index++;
    if (&apos;%c&apos; === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a &quot;function&quot;.
 *
 * @api public
 */

function log() {
  // This hackery is required for IE8,
  // where the `console.log` function doesn&apos;t have &apos;apply&apos;
  return &apos;object&apos; == typeof console
    &amp;&amp; &apos;function&apos; == typeof console.log
    &amp;&amp; Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      localStorage.removeItem(&apos;debug&apos;);
    } else {
      localStorage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = localStorage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

},{&quot;./debug&quot;:23}],23:[function(_dereq_,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = _dereq_(&apos;ms&apos;);

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special &quot;%n&quot; handling functions, for the debug &quot;format&quot; argument.
 *
 * Valid key names are a single, lowercased letter, i.e. &quot;n&quot;.
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color &amp;&amp; self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if (&apos;string&apos; !== typeof args[0]) {
      // anything else let&apos;s inspect with %o
      args = [&apos;%o&apos;].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don&apos;t increase the array index
      if (match === &apos;%&apos;) return match;
      index++;
      var formatter = exports.formatters[format];
      if (&apos;function&apos; === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it&apos;s inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if (&apos;function&apos; === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || &apos;&apos;).split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i &lt; len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, &apos;.*?&apos;);
    if (namespaces[0] === &apos;-&apos;) {
      exports.skips.push(new RegExp(&apos;^&apos; + namespaces.substr(1) + &apos;$&apos;));
    } else {
      exports.names.push(new RegExp(&apos;^&apos; + namespaces + &apos;$&apos;));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable(&apos;&apos;);
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i &lt; len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i &lt; len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{&quot;ms&quot;:24}],24:[function(_dereq_,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if (&apos;string&apos; == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || &apos;ms&apos;).toLowerCase();
  switch (type) {
    case &apos;years&apos;:
    case &apos;year&apos;:
    case &apos;y&apos;:
      return n * y;
    case &apos;days&apos;:
    case &apos;day&apos;:
    case &apos;d&apos;:
      return n * d;
    case &apos;hours&apos;:
    case &apos;hour&apos;:
    case &apos;h&apos;:
      return n * h;
    case &apos;minutes&apos;:
    case &apos;minute&apos;:
    case &apos;m&apos;:
      return n * m;
    case &apos;seconds&apos;:
    case &apos;second&apos;:
    case &apos;s&apos;:
      return n * s;
    case &apos;ms&apos;:
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms &gt;= d) return Math.round(ms / d) + &apos;d&apos;;
  if (ms &gt;= h) return Math.round(ms / h) + &apos;h&apos;;
  if (ms &gt;= m) return Math.round(ms / m) + &apos;m&apos;;
  if (ms &gt;= s) return Math.round(ms / s) + &apos;s&apos;;
  return ms + &apos;ms&apos;;
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, &apos;day&apos;)
    || plural(ms, h, &apos;hour&apos;)
    || plural(ms, m, &apos;minute&apos;)
    || plural(ms, s, &apos;second&apos;)
    || ms + &apos; ms&apos;;
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms &lt; n) return;
  if (ms &lt; n * 1.5) return Math.floor(ms / n) + &apos; &apos; + name;
  return Math.ceil(ms / n) + &apos; &apos; + name + &apos;s&apos;;
}

},{}],25:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var keys = _dereq_(&apos;./keys&apos;);
var hasBinary = _dereq_(&apos;has-binary&apos;);
var sliceBuffer = _dereq_(&apos;arraybuffer.slice&apos;);
var base64encoder = _dereq_(&apos;base64-arraybuffer&apos;);
var after = _dereq_(&apos;after&apos;);
var utf8 = _dereq_(&apos;utf8&apos;);

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = navigator.userAgent.match(/Android/i);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: &apos;error&apos;, data: &apos;parser error&apos; };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = _dereq_(&apos;blob&apos;);

/**
 * Encodes a packet.
 *
 *     &lt;packet type id&gt; [ &lt;data&gt; ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if (&apos;function&apos; == typeof supportsBinary) {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if (&apos;function&apos; == typeof utf8encode) {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer &amp;&amp; data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob &amp;&amp; data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data &amp;&amp; data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
  }

  return callback(&apos;&apos; + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = &apos;b&apos; + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i &lt; contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = &apos;b&apos; + exports.packets[packet.type];
  if (Blob &amp;&amp; packet.data instanceof Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(&apos;,&apos;)[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn&apos;t let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i &lt; typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  // String data
  if (typeof data == &apos;string&apos; || data === undefined) {
    if (data.charAt(0) == &apos;b&apos;) {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      try {
        data = utf8.decode(data);
      } catch (e) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length &gt; 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob &amp;&amp; binaryType === &apos;blob&apos;) {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!global.ArrayBuffer) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === &apos;blob&apos; &amp;&amp; Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     &lt;length&gt;:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary == &apos;function&apos;) {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary &amp;&amp; isBinary) {
    if (Blob &amp;&amp; !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback(&apos;0:&apos;);
  }

  function setLengthHeader(message) {
    return message.length + &apos;:&apos; + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(&apos;&apos;));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i &lt; ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data != &apos;string&apos;) {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === &apos;function&apos;) {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data == &apos;&apos;) {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = &apos;&apos;
    , n, msg;

  for (var i = 0, l = data.length; i &lt; l; i++) {
    var chr = data.charAt(i);

    if (&apos;:&apos; != chr) {
      length += chr;
    } else {
      if (&apos;&apos; == length || (length != (n = Number(length)))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType, true);

        if (err.type == packet.type &amp;&amp; err.data == packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      }

      // advance cursor
      i += n;
      length = &apos;&apos;;
    }
  }

  if (length != &apos;&apos;) {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * &lt;1 = binary, 0 = string&gt;&lt;number from 0-9&gt;&lt;number from 0-9&gt;[...]&lt;number
 * 255&gt;&lt;data&gt;
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === &apos;string&apos;){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === &apos;string&apos;;
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i &lt; p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i &lt; lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i &lt; view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === &apos;string&apos;) {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i &lt; encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i &lt; lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === &apos;function&apos;) {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  var numberTooLong = false;
  while (bufferTail.byteLength &gt; 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = &apos;&apos;;

    for (var i = 1; ; i++) {
      if (tailArray[i] == 255) break;

      if (msgLength.length &gt; 310) {
        numberTooLong = true;
        break;
      }

      msgLength += tailArray[i];
    }

    if(numberTooLong) return callback(err, 0, 1);

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn&apos;t let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = &apos;&apos;;
        for (var i = 0; i &lt; typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;./keys&quot;:26,&quot;after&quot;:27,&quot;arraybuffer.slice&quot;:28,&quot;base64-arraybuffer&quot;:29,&quot;blob&quot;:30,&quot;has-binary&quot;:31,&quot;utf8&quot;:33}],26:[function(_dereq_,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],27:[function(_dereq_,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count &lt;= 0) {
            throw new Error(&apos;after called too many times&apos;)
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 &amp;&amp; !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],28:[function(_dereq_,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start &lt; 0) { start += bytes; }
  if (end &lt; 0) { end += bytes; }
  if (end &gt; bytes) { end = bytes; }

  if (start &gt;= bytes || start &gt;= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i &lt; end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],29:[function(_dereq_,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(chars){
  &quot;use strict&quot;;

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = &quot;&quot;;

    for (i = 0; i &lt; len; i+=3) {
      base64 += chars[bytes[i] &gt;&gt; 2];
      base64 += chars[((bytes[i] &amp; 3) &lt;&lt; 4) | (bytes[i + 1] &gt;&gt; 4)];
      base64 += chars[((bytes[i + 1] &amp; 15) &lt;&lt; 2) | (bytes[i + 2] &gt;&gt; 6)];
      base64 += chars[bytes[i + 2] &amp; 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + &quot;=&quot;;
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + &quot;==&quot;;
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === &quot;=&quot;) {
      bufferLength--;
      if (base64[base64.length - 2] === &quot;=&quot;) {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i &lt; len; i+=4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i+1]);
      encoded3 = chars.indexOf(base64[i+2]);
      encoded4 = chars.indexOf(base64[i+3]);

      bytes[p++] = (encoded1 &lt;&lt; 2) | (encoded2 &gt;&gt; 4);
      bytes[p++] = ((encoded2 &amp; 15) &lt;&lt; 4) | (encoded3 &gt;&gt; 2);
      bytes[p++] = ((encoded3 &amp; 3) &lt;&lt; 6) | (encoded4 &amp; 63);
    }

    return arraybuffer;
  };
})(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;);

},{}],30:[function(_dereq_,module,exports){
(function (global){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var b = new Blob([&apos;hi&apos;]);
    return b.size == 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  &amp;&amp; BlobBuilder.prototype.append
  &amp;&amp; BlobBuilder.prototype.getBlob;

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  for (var i = 0; i &lt; ary.length; i++) {
    bb.append(ary[i]);
  }
  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

module.exports = (function() {
  if (blobSupported) {
    return global.Blob;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{}],31:[function(_dereq_,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = _dereq_(&apos;isarray&apos;);

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer &amp;&amp; global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer &amp;&amp; obj instanceof ArrayBuffer) ||
         (global.Blob &amp;&amp; obj instanceof Blob) ||
         (global.File &amp;&amp; obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i &lt; obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj &amp;&amp; &apos;object&apos; == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (obj.hasOwnProperty(key) &amp;&amp; _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;isarray&quot;:32}],32:[function(_dereq_,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == &apos;[object Array]&apos;;
};

},{}],33:[function(_dereq_,module,exports){
(function (global){
/*! http://mths.be/utf8js v2.0.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == &apos;object&apos; &amp;&amp; exports;

	// Detect free variable `module`
	var freeModule = typeof module == &apos;object&apos; &amp;&amp; module &amp;&amp;
		module.exports == freeExports &amp;&amp; module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == &apos;object&apos; &amp;&amp; global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from http://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter &lt; length) {
			value = string.charCodeAt(counter++);
			if (value &gt;= 0xD800 &amp;&amp; value &lt;= 0xDBFF &amp;&amp; counter &lt; length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra &amp; 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value &amp; 0x3FF) &lt;&lt; 10) + (extra &amp; 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from http://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = &apos;&apos;;
		while (++index &lt; length) {
			value = array[index];
			if (value &gt; 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value &gt;&gt;&gt; 10 &amp; 0x3FF | 0xD800);
				value = 0xDC00 | value &amp; 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint &gt;&gt; shift) &amp; 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint &amp; 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = &apos;&apos;;
		if ((codePoint &amp; 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint &gt;&gt; 6) &amp; 0x1F) | 0xC0);
		}
		else if ((codePoint &amp; 0xFFFF0000) == 0) { // 3-byte sequence
			symbol = stringFromCharCode(((codePoint &gt;&gt; 12) &amp; 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint &amp; 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint &gt;&gt; 18) &amp; 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint &amp; 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);

		// console.log(JSON.stringify(codePoints.map(function(x) {
		// 	return &apos;U+&apos; + x.toString(16).toUpperCase();
		// })));

		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = &apos;&apos;;
		while (++index &lt; length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex &gt;= byteCount) {
			throw Error(&apos;Invalid byte index&apos;);
		}

		var continuationByte = byteArray[byteIndex] &amp; 0xFF;
		byteIndex++;

		if ((continuationByte &amp; 0xC0) == 0x80) {
			return continuationByte &amp; 0x3F;
		}

		// If we end up here, its not a continuation byte
		throw Error(&apos;Invalid continuation byte&apos;);
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex &gt; byteCount) {
			throw Error(&apos;Invalid byte index&apos;);
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] &amp; 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 &amp; 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 &amp; 0xE0) == 0xC0) {
			var byte2 = readContinuationByte();
			codePoint = ((byte1 &amp; 0x1F) &lt;&lt; 6) | byte2;
			if (codePoint &gt;= 0x80) {
				return codePoint;
			} else {
				throw Error(&apos;Invalid continuation byte&apos;);
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 &amp; 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 &amp; 0x0F) &lt;&lt; 12) | (byte2 &lt;&lt; 6) | byte3;
			if (codePoint &gt;= 0x0800) {
				return codePoint;
			} else {
				throw Error(&apos;Invalid continuation byte&apos;);
			}
		}

		// 4-byte sequence
		if ((byte1 &amp; 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 &amp; 0x0F) &lt;&lt; 0x12) | (byte2 &lt;&lt; 0x0C) |
				(byte3 &lt;&lt; 0x06) | byte4;
			if (codePoint &gt;= 0x010000 &amp;&amp; codePoint &lt;= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error(&apos;Invalid UTF-8 detected&apos;);
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		&apos;version&apos;: &apos;2.0.0&apos;,
		&apos;encode&apos;: utf8encode,
		&apos;decode&apos;: utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == &apos;function&apos; &amp;&amp;
		typeof define.amd == &apos;object&apos; &amp;&amp;
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports &amp;&amp; !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) &amp;&amp; (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{}],34:[function(_dereq_,module,exports){
(function (global){
/**
 * JSON parse.
 *
 * @see Based on jQuery#parseJSON (MIT) and JSON2
 * @api private
 */

var rvalidchars = /^[\],:{}\s]*$/;
var rvalidescape = /\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rvalidtokens = /&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
var rtrimLeft = /^\s+/;
var rtrimRight = /\s+$/;

module.exports = function parsejson(data) {
  if (&apos;string&apos; != typeof data || !data) {
    return null;
  }

  data = data.replace(rtrimLeft, &apos;&apos;).replace(rtrimRight, &apos;&apos;);

  // Attempt to parse using the native JSON parser first
  if (global.JSON &amp;&amp; JSON.parse) {
    return JSON.parse(data);
  }

  if (rvalidchars.test(data.replace(rvalidescape, &apos;@&apos;)
      .replace(rvalidtokens, &apos;]&apos;)
      .replace(rvalidbraces, &apos;&apos;))) {
    return (new Function(&apos;return &apos; + data))();
  }
};
}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{}],35:[function(_dereq_,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = &apos;&apos;;

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += &apos;&amp;&apos;;
      str += encodeURIComponent(i) + &apos;=&apos; + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split(&apos;&amp;&apos;);
  for (var i = 0, l = pairs.length; i &lt; l; i++) {
    var pair = pairs[i].split(&apos;=&apos;);
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],36:[function(_dereq_,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan &lt;stevenlevithan.com&gt; (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    &apos;source&apos;, &apos;protocol&apos;, &apos;authority&apos;, &apos;userInfo&apos;, &apos;user&apos;, &apos;password&apos;, &apos;host&apos;, &apos;port&apos;, &apos;relative&apos;, &apos;path&apos;, &apos;directory&apos;, &apos;file&apos;, &apos;query&apos;, &apos;anchor&apos;
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf(&apos;[&apos;),
        e = str.indexOf(&apos;]&apos;);

    if (b != -1 &amp;&amp; e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, &apos;;&apos;) + str.substring(e, str.length);
    }

    var m = re.exec(str || &apos;&apos;),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || &apos;&apos;;
    }

    if (b != -1 &amp;&amp; e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, &apos;:&apos;);
        uri.authority = uri.authority.replace(&apos;[&apos;, &apos;&apos;).replace(&apos;]&apos;, &apos;&apos;).replace(/;/g, &apos;:&apos;);
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],37:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var global = (function() { return this; })();

/**
 * WebSocket constructor.
 */

var WebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Module exports.
 */

module.exports = WebSocket ? ws : null;

/**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it&apos;s
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object) opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
  var instance;
  if (protocols) {
    instance = new WebSocket(uri, protocols);
  } else {
    instance = new WebSocket(uri);
  }
  return instance;
}

if (WebSocket) ws.prototype = WebSocket.prototype;

},{}],38:[function(_dereq_,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = _dereq_(&apos;isarray&apos;);

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer &amp;&amp; global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer &amp;&amp; obj instanceof ArrayBuffer) ||
         (global.Blob &amp;&amp; obj instanceof Blob) ||
         (global.File &amp;&amp; obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i &lt; obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj &amp;&amp; &apos;object&apos; == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) &amp;&amp; _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;isarray&quot;:39}],39:[function(_dereq_,module,exports){
module.exports=_dereq_(32)
},{}],40:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var global = _dereq_(&apos;global&apos;);

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = &apos;XMLHttpRequest&apos; in global &amp;&amp;
    &apos;withCredentials&apos; in new global.XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{&quot;global&quot;:41}],41:[function(_dereq_,module,exports){

/**
 * Returns `this`. Execute this without a &quot;context&quot; (i.e. without it being
 * attached to an object of the left-hand side), and `this` points to the
 * &quot;global&quot; scope of the current JS execution.
 */

module.exports = (function () { return this; })();

},{}],42:[function(_dereq_,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i &lt; arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],43:[function(_dereq_,module,exports){

/**
 * HOP ref.
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Return own keys in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.keys = Object.keys || function(obj){
  var keys = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
};

/**
 * Return own values in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.values = function(obj){
  var vals = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      vals.push(obj[key]);
    }
  }
  return vals;
};

/**
 * Merge `b` into `a`.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api public
 */

exports.merge = function(a, b){
  for (var key in b) {
    if (has.call(b, key)) {
      a[key] = b[key];
    }
  }
  return a;
};

/**
 * Return length of `obj`.
 *
 * @param {Object} obj
 * @return {Number}
 * @api public
 */

exports.length = function(obj){
  return exports.keys(obj).length;
};

/**
 * Check if `obj` is empty.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api public
 */

exports.isEmpty = function(obj){
  return 0 == exports.length(obj);
};
},{}],44:[function(_dereq_,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan &lt;stevenlevithan.com&gt; (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    &apos;source&apos;, &apos;protocol&apos;, &apos;authority&apos;, &apos;userInfo&apos;, &apos;user&apos;, &apos;password&apos;, &apos;host&apos;
  , &apos;port&apos;, &apos;relative&apos;, &apos;path&apos;, &apos;directory&apos;, &apos;file&apos;, &apos;query&apos;, &apos;anchor&apos;
];

module.exports = function parseuri(str) {
  var m = re.exec(str || &apos;&apos;)
    , uri = {}
    , i = 14;

  while (i--) {
    uri[parts[i]] = m[i] || &apos;&apos;;
  }

  return uri;
};

},{}],45:[function(_dereq_,module,exports){
(function (global){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = _dereq_(&apos;isarray&apos;);
var isBuf = _dereq_(&apos;./is-buffer&apos;);

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet){
  var buffers = [];
  var packetData = packet.data;

  function _deconstructPacket(data) {
    if (!data) return data;

    if (isBuf(data)) {
      var placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (isArray(data)) {
      var newData = new Array(data.length);
      for (var i = 0; i &lt; data.length; i++) {
        newData[i] = _deconstructPacket(data[i]);
      }
      return newData;
    } else if (&apos;object&apos; == typeof data &amp;&amp; !(data instanceof Date)) {
      var newData = {};
      for (var key in data) {
        newData[key] = _deconstructPacket(data[key]);
      }
      return newData;
    }
    return data;
  }

  var pack = packet;
  pack.data = _deconstructPacket(packetData);
  pack.attachments = buffers.length; // number of binary &apos;attachments&apos;
  return {packet: pack, buffers: buffers};
};

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  var curPlaceHolder = 0;

  function _reconstructPacket(data) {
    if (data &amp;&amp; data._placeholder) {
      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
      return buf;
    } else if (isArray(data)) {
      for (var i = 0; i &lt; data.length; i++) {
        data[i] = _reconstructPacket(data[i]);
      }
      return data;
    } else if (data &amp;&amp; &apos;object&apos; == typeof data) {
      for (var key in data) {
        data[key] = _reconstructPacket(data[key]);
      }
      return data;
    }
    return data;
  }

  packet.data = _reconstructPacket(packet.data);
  packet.attachments = undefined; // no longer useful
  return packet;
};

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader&apos;s readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((global.Blob &amp;&amp; obj instanceof Blob) ||
        (global.File &amp;&amp; obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -&gt; arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i &lt; obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (obj &amp;&amp; &apos;object&apos; == typeof obj &amp;&amp; !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;./is-buffer&quot;:47,&quot;isarray&quot;:48}],46:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var debug = _dereq_(&apos;debug&apos;)(&apos;socket.io-parser&apos;);
var json = _dereq_(&apos;json3&apos;);
var isArray = _dereq_(&apos;isarray&apos;);
var Emitter = _dereq_(&apos;component-emitter&apos;);
var binary = _dereq_(&apos;./binary&apos;);
var isBuf = _dereq_(&apos;./is-buffer&apos;);

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  &apos;CONNECT&apos;,
  &apos;DISCONNECT&apos;,
  &apos;EVENT&apos;,
  &apos;BINARY_EVENT&apos;,
  &apos;ACK&apos;,
  &apos;BINARY_ACK&apos;,
  &apos;ERROR&apos;
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type &apos;binary event&apos;
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug(&apos;encoding packet %j&apos;, obj);

  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {
  var str = &apos;&apos;;
  var nsp = false;

  // first is type
  str += obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    str += obj.attachments;
    str += &apos;-&apos;;
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp &amp;&amp; &apos;/&apos; != obj.nsp) {
    nsp = true;
    str += obj.nsp;
  }

  // immediately followed by the id
  if (null != obj.id) {
    if (nsp) {
      str += &apos;,&apos;;
      nsp = false;
    }
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    if (nsp) str += &apos;,&apos;;
    str += json.stringify(obj.data);
  }

  debug(&apos;encoded %j as %s&apos;, obj, str);
  return str;
}

/**
 * Encode packet as &apos;buffer sequence&apos; by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if (&apos;string&apos; == typeof obj) {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet&apos;s json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit(&apos;decoded&apos;, packet);
      }
    } else { // non-binary full packet
      this.emit(&apos;decoded&apos;, packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error(&apos;got binary data when not reconstructing a packet&apos;);
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit(&apos;decoded&apos;, packet);
      }
    }
  }
  else {
    throw new Error(&apos;Unknown type: &apos; + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var p = {};
  var i = 0;

  // look up type
  p.type = Number(str.charAt(0));
  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
    var buf = &apos;&apos;;
    while (str.charAt(++i) != &apos;-&apos;) {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) != &apos;-&apos;) {
      throw new Error(&apos;Illegal attachments&apos;);
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if (&apos;/&apos; == str.charAt(i + 1)) {
    p.nsp = &apos;&apos;;
    while (++i) {
      var c = str.charAt(i);
      if (&apos;,&apos; == c) break;
      p.nsp += c;
      if (i == str.length) break;
    }
  } else {
    p.nsp = &apos;/&apos;;
  }

  // look up id
  var next = str.charAt(i + 1);
  if (&apos;&apos; !== next &amp;&amp; Number(next) == next) {
    p.id = &apos;&apos;;
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i == str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    try {
      p.data = json.parse(str.substr(i));
    } catch(e){
      return error();
    }
  }

  debug(&apos;decoded %s as %j&apos;, str, p);
  return p;
}

/**
 * Deallocates a parser&apos;s resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event&apos;s &apos;buffer sequence&apos;. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(data){
  return {
    type: exports.ERROR,
    data: &apos;parser error&apos;
  };
}

},{&quot;./binary&quot;:45,&quot;./is-buffer&quot;:47,&quot;component-emitter&quot;:9,&quot;debug&quot;:10,&quot;isarray&quot;:48,&quot;json3&quot;:49}],47:[function(_dereq_,module,exports){
(function (global){

module.exports = isBuf;

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (global.Buffer &amp;&amp; global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer &amp;&amp; obj instanceof ArrayBuffer);
}

}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{}],48:[function(_dereq_,module,exports){
module.exports=_dereq_(32)
},{}],49:[function(_dereq_,module,exports){
/*! JSON v3.2.6 | http://bestiejs.github.io/json3 | Copyright 2012-2013, Kit Cambridge | http://kit.mit-license.org */
;(function (window) {
  // Convenience aliases.
  var getClass = {}.toString, isProperty, forEach, undef;

  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === &quot;function&quot; &amp;&amp; define.amd;

  // Detect native implementations.
  var nativeJSON = typeof JSON == &quot;object&quot; &amp;&amp; JSON;

  // Set up the JSON 3 namespace, preferring the CommonJS `exports` object if
  // available.
  var JSON3 = typeof exports == &quot;object&quot; &amp;&amp; exports &amp;&amp; !exports.nodeType &amp;&amp; exports;

  if (JSON3 &amp;&amp; nativeJSON) {
    // Explicitly delegate to the native `stringify` and `parse`
    // implementations in CommonJS environments.
    JSON3.stringify = nativeJSON.stringify;
    JSON3.parse = nativeJSON.parse;
  } else {
    // Export for web browsers, JavaScript engines, and asynchronous module
    // loaders, using the global `JSON` object if available.
    JSON3 = window.JSON = nativeJSON || {};
  }

  // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
  var isExtended = new Date(-3509827334573292);
  try {
    // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
    // results for certain dates in Opera &gt;= 10.53.
    isExtended = isExtended.getUTCFullYear() == -109252 &amp;&amp; isExtended.getUTCMonth() === 0 &amp;&amp; isExtended.getUTCDate() === 1 &amp;&amp;
      // Safari &lt; 2.0.2 stores the internal millisecond time value correctly,
      // but clips the values returned by the date methods to the range of
      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
      isExtended.getUTCHours() == 10 &amp;&amp; isExtended.getUTCMinutes() == 37 &amp;&amp; isExtended.getUTCSeconds() == 6 &amp;&amp; isExtended.getUTCMilliseconds() == 708;
  } catch (exception) {}

  // Internal: Determines whether the native `JSON.stringify` and `parse`
  // implementations are spec-compliant. Based on work by Ken Snyder.
  function has(name) {
    if (has[name] !== undef) {
      // Return cached feature test result.
      return has[name];
    }

    var isSupported;
    if (name == &quot;bug-string-char-index&quot;) {
      // IE &lt;= 7 doesn&apos;t support accessing string characters using square
      // bracket notation. IE 8 only supports this for primitives.
      isSupported = &quot;a&quot;[0] != &quot;a&quot;;
    } else if (name == &quot;json&quot;) {
      // Indicates whether both `JSON.stringify` and `JSON.parse` are
      // supported.
      isSupported = has(&quot;json-stringify&quot;) &amp;&amp; has(&quot;json-parse&quot;);
    } else {
      var value, serialized = &apos;{&quot;a&quot;:[1,true,false,null,&quot;\\u0000\\b\\n\\f\\r\\t&quot;]}&apos;;
      // Test `JSON.stringify`.
      if (name == &quot;json-stringify&quot;) {
        var stringify = JSON3.stringify, stringifySupported = typeof stringify == &quot;function&quot; &amp;&amp; isExtended;
        if (stringifySupported) {
          // A test function object with a custom `toJSON` method.
          (value = function () {
            return 1;
          }).toJSON = value;
          try {
            stringifySupported =
              // Firefox 3.1b1 and b2 serialize string, number, and boolean
              // primitives as object literals.
              stringify(0) === &quot;0&quot; &amp;&amp;
              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
              // literals.
              stringify(new Number()) === &quot;0&quot; &amp;&amp;
              stringify(new String()) == &apos;&quot;&quot;&apos; &amp;&amp;
              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
              // does not define a canonical JSON representation (this applies to
              // objects with `toJSON` properties as well, *unless* they are nested
              // within an object or array).
              stringify(getClass) === undef &amp;&amp;
              // IE 8 serializes `undefined` as `&quot;undefined&quot;`. Safari &lt;= 5.1.7 and
              // FF 3.1b3 pass this test.
              stringify(undef) === undef &amp;&amp;
              // Safari &lt;= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
              // respectively, if the value is omitted entirely.
              stringify() === undef &amp;&amp;
              // FF 3.1b1, 2 throw an error if the given value is not a number,
              // string, array, object, Boolean, or `null` literal. This applies to
              // objects with custom `toJSON` methods as well, unless they are nested
              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
              // methods entirely.
              stringify(value) === &quot;1&quot; &amp;&amp;
              stringify([value]) == &quot;[1]&quot; &amp;&amp;
              // Prototype &lt;= 1.6.1 serializes `[undefined]` as `&quot;[]&quot;` instead of
              // `&quot;[null]&quot;`.
              stringify([undef]) == &quot;[null]&quot; &amp;&amp;
              // YUI 3.0.0b1 fails to serialize `null` literals.
              stringify(null) == &quot;null&quot; &amp;&amp;
              // FF 3.1b1, 2 halts serialization if an array contains a function:
              // `[1, true, getClass, 1]` serializes as &quot;[1,true,],&quot;. FF 3.1b3
              // elides non-JSON values from objects and arrays, unless they
              // define custom `toJSON` methods.
              stringify([undef, getClass, null]) == &quot;[null,null,null]&quot; &amp;&amp;
              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
              // where character escape codes are expected (e.g., `\b` =&gt; `\u0008`).
              stringify({ &quot;a&quot;: [value, true, false, null, &quot;\x00\b\n\f\r\t&quot;] }) == serialized &amp;&amp;
              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
              stringify(null, value) === &quot;1&quot; &amp;&amp;
              stringify([1, 2], null, 1) == &quot;[\n 1,\n 2\n]&quot; &amp;&amp;
              // JSON 2, Prototype &lt;= 1.7, and older WebKit builds incorrectly
              // serialize extended years.
              stringify(new Date(-8.64e15)) == &apos;&quot;-271821-04-20T00:00:00.000Z&quot;&apos; &amp;&amp;
              // The milliseconds are optional in ES 5, but required in 5.1.
              stringify(new Date(8.64e15)) == &apos;&quot;+275760-09-13T00:00:00.000Z&quot;&apos; &amp;&amp;
              // Firefox &lt;= 11.0 incorrectly serializes years prior to 0 as negative
              // four-digit years instead of six-digit years. Credits: @Yaffle.
              stringify(new Date(-621987552e5)) == &apos;&quot;-000001-01-01T00:00:00.000Z&quot;&apos; &amp;&amp;
              // Safari &lt;= 5.1.5 and Opera &gt;= 10.53 incorrectly serialize millisecond
              // values less than 1000. Credits: @Yaffle.
              stringify(new Date(-1)) == &apos;&quot;1969-12-31T23:59:59.999Z&quot;&apos;;
          } catch (exception) {
            stringifySupported = false;
          }
        }
        isSupported = stringifySupported;
      }
      // Test `JSON.parse`.
      if (name == &quot;json-parse&quot;) {
        var parse = JSON3.parse;
        if (typeof parse == &quot;function&quot;) {
          try {
            // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
            // Conforming implementations should also coerce the initial argument to
            // a string prior to parsing.
            if (parse(&quot;0&quot;) === 0 &amp;&amp; !parse(false)) {
              // Simple parsing test.
              value = parse(serialized);
              var parseSupported = value[&quot;a&quot;].length == 5 &amp;&amp; value[&quot;a&quot;][0] === 1;
              if (parseSupported) {
                try {
                  // Safari &lt;= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                  parseSupported = !parse(&apos;&quot;\t&quot;&apos;);
                } catch (exception) {}
                if (parseSupported) {
                  try {
                    // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                    // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                    // certain octal literals.
                    parseSupported = parse(&quot;01&quot;) !== 1;
                  } catch (exception) {}
                }
                if (parseSupported) {
                  try {
                    // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                    // points. These environments, along with FF 3.1b1 and 2,
                    // also allow trailing commas in JSON objects and arrays.
                    parseSupported = parse(&quot;1.&quot;) !== 1;
                  } catch (exception) {}
                }
              }
            }
          } catch (exception) {
            parseSupported = false;
          }
        }
        isSupported = parseSupported;
      }
    }
    return has[name] = !!isSupported;
  }

  if (!has(&quot;json&quot;)) {
    // Common `[[Class]]` name aliases.
    var functionClass = &quot;[object Function]&quot;;
    var dateClass = &quot;[object Date]&quot;;
    var numberClass = &quot;[object Number]&quot;;
    var stringClass = &quot;[object String]&quot;;
    var arrayClass = &quot;[object Array]&quot;;
    var booleanClass = &quot;[object Boolean]&quot;;

    // Detect incomplete support for accessing string characters by index.
    var charIndexBuggy = has(&quot;bug-string-char-index&quot;);

    // Define additional utility methods if the `Date` methods are buggy.
    if (!isExtended) {
      var floor = Math.floor;
      // A mapping between the months of the year and the number of days between
      // January 1st and the first of the respective month.
      var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      // Internal: Calculates the number of days between the Unix epoch and the
      // first day of the given month.
      var getDay = function (year, month) {
        return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month &gt; 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
      };
    }

    // Internal: Determines if a property is a direct property of the given
    // object. Delegates to the native `Object#hasOwnProperty` method.
    if (!(isProperty = {}.hasOwnProperty)) {
      isProperty = function (property) {
        var members = {}, constructor;
        if ((members.__proto__ = null, members.__proto__ = {
          // The *proto* property cannot be set multiple times in recent
          // versions of Firefox and SeaMonkey.
          &quot;toString&quot;: 1
        }, members).toString != getClass) {
          // Safari &lt;= 2.0.3 doesn&apos;t implement `Object#hasOwnProperty`, but
          // supports the mutable *proto* property.
          isProperty = function (property) {
            // Capture and break the object&apos;s prototype chain (see section 8.6.2
            // of the ES 5.1 spec). The parenthesized expression prevents an
            // unsafe transformation by the Closure Compiler.
            var original = this.__proto__, result = property in (this.__proto__ = null, this);
            // Restore the original prototype chain.
            this.__proto__ = original;
            return result;
          };
        } else {
          // Capture a reference to the top-level `Object` constructor.
          constructor = members.constructor;
          // Use the `constructor` property to simulate `Object#hasOwnProperty` in
          // other environments.
          isProperty = function (property) {
            var parent = (this.constructor || constructor).prototype;
            return property in this &amp;&amp; !(property in parent &amp;&amp; this[property] === parent[property]);
          };
        }
        members = null;
        return isProperty.call(this, property);
      };
    }

    // Internal: A set of primitive types used by `isHostType`.
    var PrimitiveTypes = {
      &apos;boolean&apos;: 1,
      &apos;number&apos;: 1,
      &apos;string&apos;: 1,
      &apos;undefined&apos;: 1
    };

    // Internal: Determines if the given object `property` value is a
    // non-primitive.
    var isHostType = function (object, property) {
      var type = typeof object[property];
      return type == &apos;object&apos; ? !!object[property] : !PrimitiveTypes[type];
    };

    // Internal: Normalizes the `for...in` iteration algorithm across
    // environments. Each enumerated key is yielded to a `callback` function.
    forEach = function (object, callback) {
      var size = 0, Properties, members, property;

      // Tests for bugs in the current environment&apos;s `for...in` algorithm. The
      // `valueOf` property inherits the non-enumerable flag from
      // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
      (Properties = function () {
        this.valueOf = 0;
      }).prototype.valueOf = 0;

      // Iterate over a new instance of the `Properties` class.
      members = new Properties();
      for (property in members) {
        // Ignore all properties inherited from `Object.prototype`.
        if (isProperty.call(members, property)) {
          size++;
        }
      }
      Properties = members = null;

      // Normalize the iteration algorithm.
      if (!size) {
        // A list of non-enumerable properties inherited from `Object.prototype`.
        members = [&quot;valueOf&quot;, &quot;toString&quot;, &quot;toLocaleString&quot;, &quot;propertyIsEnumerable&quot;, &quot;isPrototypeOf&quot;, &quot;hasOwnProperty&quot;, &quot;constructor&quot;];
        // IE &lt;= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
        // properties.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, length;
          var hasProperty = !isFunction &amp;&amp; typeof object.constructor != &apos;function&apos; &amp;&amp; isHostType(object, &apos;hasOwnProperty&apos;) ? object.hasOwnProperty : isProperty;
          for (property in object) {
            // Gecko &lt;= 1.0 enumerates the `prototype` property of functions under
            // certain conditions; IE does not.
            if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; hasProperty.call(object, property)) {
              callback(property);
            }
          }
          // Manually invoke the callback for each non-enumerable property.
          for (length = members.length; property = members[--length]; hasProperty.call(object, property) &amp;&amp; callback(property));
        };
      } else if (size == 2) {
        // Safari &lt;= 2.0.4 enumerates shadowed properties twice.
        forEach = function (object, callback) {
          // Create a set of iterated properties.
          var members = {}, isFunction = getClass.call(object) == functionClass, property;
          for (property in object) {
            // Store each property name to prevent double enumeration. The
            // `prototype` property of functions is not enumerated due to cross-
            // environment inconsistencies.
            if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; !isProperty.call(members, property) &amp;&amp; (members[property] = 1) &amp;&amp; isProperty.call(object, property)) {
              callback(property);
            }
          }
        };
      } else {
        // No bugs detected; use the standard `for...in` algorithm.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, isConstructor;
          for (property in object) {
            if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; isProperty.call(object, property) &amp;&amp; !(isConstructor = property === &quot;constructor&quot;)) {
              callback(property);
            }
          }
          // Manually invoke the callback for the `constructor` property due to
          // cross-environment inconsistencies.
          if (isConstructor || isProperty.call(object, (property = &quot;constructor&quot;))) {
            callback(property);
          }
        };
      }
      return forEach(object, callback);
    };

    // Public: Serializes a JavaScript `value` as a JSON string. The optional
    // `filter` argument may specify either a function that alters how object and
    // array members are serialized, or an array of strings and numbers that
    // indicates which properties should be serialized. The optional `width`
    // argument may be either a string or number that specifies the indentation
    // level of the output.
    if (!has(&quot;json-stringify&quot;)) {
      // Internal: A map of control characters and their escaped equivalents.
      var Escapes = {
        92: &quot;\\\\&quot;,
        34: &apos;\\&quot;&apos;,
        8: &quot;\\b&quot;,
        12: &quot;\\f&quot;,
        10: &quot;\\n&quot;,
        13: &quot;\\r&quot;,
        9: &quot;\\t&quot;
      };

      // Internal: Converts `value` into a zero-padded string such that its
      // length is at least equal to `width`. The `width` must be &lt;= 6.
      var leadingZeroes = &quot;000000&quot;;
      var toPaddedString = function (width, value) {
        // The `|| 0` expression is necessary to work around a bug in
        // Opera &lt;= 7.54u2 where `0 == -0`, but `String(-0) !== &quot;0&quot;`.
        return (leadingZeroes + (value || 0)).slice(-width);
      };

      // Internal: Double-quotes a string `value`, replacing all ASCII control
      // characters (characters with code unit values between 0 and 31) with
      // their escaped equivalents. This is an implementation of the
      // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
      var unicodePrefix = &quot;\\u00&quot;;
      var quote = function (value) {
        var result = &apos;&quot;&apos;, index = 0, length = value.length, isLarge = length &gt; 10 &amp;&amp; charIndexBuggy, symbols;
        if (isLarge) {
          symbols = value.split(&quot;&quot;);
        }
        for (; index &lt; length; index++) {
          var charCode = value.charCodeAt(index);
          // If the character is a control character, append its Unicode or
          // shorthand escape sequence; otherwise, append the character as-is.
          switch (charCode) {
            case 8: case 9: case 10: case 12: case 13: case 34: case 92:
              result += Escapes[charCode];
              break;
            default:
              if (charCode &lt; 32) {
                result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                break;
              }
              result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];
          }
        }
        return result + &apos;&quot;&apos;;
      };

      // Internal: Recursively serializes an object. Implements the
      // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
      var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
        var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
        try {
          // Necessary for host object support.
          value = object[property];
        } catch (exception) {}
        if (typeof value == &quot;object&quot; &amp;&amp; value) {
          className = getClass.call(value);
          if (className == dateClass &amp;&amp; !isProperty.call(value, &quot;toJSON&quot;)) {
            if (value &gt; -1 / 0 &amp;&amp; value &lt; 1 / 0) {
              // Dates are serialized according to the `Date#toJSON` method
              // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
              // for the ISO 8601 date time string format.
              if (getDay) {
                // Manually compute the year, month, date, hours, minutes,
                // seconds, and milliseconds if the `getUTC*` methods are
                // buggy. Adapted from @Yaffle&apos;s `date-shim` project.
                date = floor(value / 864e5);
                for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) &lt;= date; year++);
                for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) &lt;= date; month++);
                date = 1 + date - getDay(year, month);
                // The `time` value specifies the time within the day (see ES
                // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                // to compute `A modulo B`, as the `%` operator does not
                // correspond to the `modulo` operation for negative numbers.
                time = (value % 864e5 + 864e5) % 864e5;
                // The hours, minutes, seconds, and milliseconds are obtained by
                // decomposing the time within the day. See section 15.9.1.10.
                hours = floor(time / 36e5) % 24;
                minutes = floor(time / 6e4) % 60;
                seconds = floor(time / 1e3) % 60;
                milliseconds = time % 1e3;
              } else {
                year = value.getUTCFullYear();
                month = value.getUTCMonth();
                date = value.getUTCDate();
                hours = value.getUTCHours();
                minutes = value.getUTCMinutes();
                seconds = value.getUTCSeconds();
                milliseconds = value.getUTCMilliseconds();
              }
              // Serialize extended years correctly.
              value = (year &lt;= 0 || year &gt;= 1e4 ? (year &lt; 0 ? &quot;-&quot; : &quot;+&quot;) + toPaddedString(6, year &lt; 0 ? -year : year) : toPaddedString(4, year)) +
                &quot;-&quot; + toPaddedString(2, month + 1) + &quot;-&quot; + toPaddedString(2, date) +
                // Months, dates, hours, minutes, and seconds should have two
                // digits; milliseconds should have three.
                &quot;T&quot; + toPaddedString(2, hours) + &quot;:&quot; + toPaddedString(2, minutes) + &quot;:&quot; + toPaddedString(2, seconds) +
                // Milliseconds are optional in ES 5.0, but required in 5.1.
                &quot;.&quot; + toPaddedString(3, milliseconds) + &quot;Z&quot;;
            } else {
              value = null;
            }
          } else if (typeof value.toJSON == &quot;function&quot; &amp;&amp; ((className != numberClass &amp;&amp; className != stringClass &amp;&amp; className != arrayClass) || isProperty.call(value, &quot;toJSON&quot;))) {
            // Prototype &lt;= 1.6.1 adds non-standard `toJSON` methods to the
            // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
            // ignores all `toJSON` methods on these objects unless they are
            // defined directly on an instance.
            value = value.toJSON(property);
          }
        }
        if (callback) {
          // If a replacement function was provided, call it to obtain the value
          // for serialization.
          value = callback.call(object, property, value);
        }
        if (value === null) {
          return &quot;null&quot;;
        }
        className = getClass.call(value);
        if (className == booleanClass) {
          // Booleans are represented literally.
          return &quot;&quot; + value;
        } else if (className == numberClass) {
          // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
          // `&quot;null&quot;`.
          return value &gt; -1 / 0 &amp;&amp; value &lt; 1 / 0 ? &quot;&quot; + value : &quot;null&quot;;
        } else if (className == stringClass) {
          // Strings are double-quoted and escaped.
          return quote(&quot;&quot; + value);
        }
        // Recursively serialize objects and arrays.
        if (typeof value == &quot;object&quot;) {
          // Check for cyclic structures. This is a linear search; performance
          // is inversely proportional to the number of unique nested objects.
          for (length = stack.length; length--;) {
            if (stack[length] === value) {
              // Cyclic structures cannot be serialized by `JSON.stringify`.
              throw TypeError();
            }
          }
          // Add the object to the stack of traversed objects.
          stack.push(value);
          results = [];
          // Save the current indentation level and indent one additional level.
          prefix = indentation;
          indentation += whitespace;
          if (className == arrayClass) {
            // Recursively serialize array elements.
            for (index = 0, length = value.length; index &lt; length; index++) {
              element = serialize(index, value, callback, properties, whitespace, indentation, stack);
              results.push(element === undef ? &quot;null&quot; : element);
            }
            result = results.length ? (whitespace ? &quot;[\n&quot; + indentation + results.join(&quot;,\n&quot; + indentation) + &quot;\n&quot; + prefix + &quot;]&quot; : (&quot;[&quot; + results.join(&quot;,&quot;) + &quot;]&quot;)) : &quot;[]&quot;;
          } else {
            // Recursively serialize object members. Members are selected from
            // either a user-specified list of property names, or the object
            // itself.
            forEach(properties || value, function (property) {
              var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
              if (element !== undef) {
                // According to ES 5.1 section 15.12.3: &quot;If `gap` {whitespace}
                // is not the empty string, let `member` {quote(property) + &quot;:&quot;}
                // be the concatenation of `member` and the `space` character.&quot;
                // The &quot;`space` character&quot; refers to the literal space
                // character, not the `space` {width} argument provided to
                // `JSON.stringify`.
                results.push(quote(property) + &quot;:&quot; + (whitespace ? &quot; &quot; : &quot;&quot;) + element);
              }
            });
            result = results.length ? (whitespace ? &quot;{\n&quot; + indentation + results.join(&quot;,\n&quot; + indentation) + &quot;\n&quot; + prefix + &quot;}&quot; : (&quot;{&quot; + results.join(&quot;,&quot;) + &quot;}&quot;)) : &quot;{}&quot;;
          }
          // Remove the object from the traversed object stack.
          stack.pop();
          return result;
        }
      };

      // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
      JSON3.stringify = function (source, filter, width) {
        var whitespace, callback, properties, className;
        if (typeof filter == &quot;function&quot; || typeof filter == &quot;object&quot; &amp;&amp; filter) {
          if ((className = getClass.call(filter)) == functionClass) {
            callback = filter;
          } else if (className == arrayClass) {
            // Convert the property names array into a makeshift set.
            properties = {};
            for (var index = 0, length = filter.length, value; index &lt; length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) &amp;&amp; (properties[value] = 1));
          }
        }
        if (width) {
          if ((className = getClass.call(width)) == numberClass) {
            // Convert the `width` to an integer and create a string containing
            // `width` number of space characters.
            if ((width -= width % 1) &gt; 0) {
              for (whitespace = &quot;&quot;, width &gt; 10 &amp;&amp; (width = 10); whitespace.length &lt; width; whitespace += &quot; &quot;);
            }
          } else if (className == stringClass) {
            whitespace = width.length &lt;= 10 ? width : width.slice(0, 10);
          }
        }
        // Opera &lt;= 7.54u2 discards the values associated with empty string keys
        // (`&quot;&quot;`) only if they are used directly within an object member list
        // (e.g., `!(&quot;&quot; in { &quot;&quot;: 1})`).
        return serialize(&quot;&quot;, (value = {}, value[&quot;&quot;] = source, value), callback, properties, whitespace, &quot;&quot;, []);
      };
    }

    // Public: Parses a JSON source string.
    if (!has(&quot;json-parse&quot;)) {
      var fromCharCode = String.fromCharCode;

      // Internal: A map of escaped control characters and their unescaped
      // equivalents.
      var Unescapes = {
        92: &quot;\\&quot;,
        34: &apos;&quot;&apos;,
        47: &quot;/&quot;,
        98: &quot;\b&quot;,
        116: &quot;\t&quot;,
        110: &quot;\n&quot;,
        102: &quot;\f&quot;,
        114: &quot;\r&quot;
      };

      // Internal: Stores the parser state.
      var Index, Source;

      // Internal: Resets the parser state and throws a `SyntaxError`.
      var abort = function() {
        Index = Source = null;
        throw SyntaxError();
      };

      // Internal: Returns the next token, or `&quot;$&quot;` if the parser has reached
      // the end of the source string. A token may be a string, number, `null`
      // literal, or Boolean literal.
      var lex = function () {
        var source = Source, length = source.length, value, begin, position, isSigned, charCode;
        while (Index &lt; length) {
          charCode = source.charCodeAt(Index);
          switch (charCode) {
            case 9: case 10: case 13: case 32:
              // Skip whitespace tokens, including tabs, carriage returns, line
              // feeds, and space characters.
              Index++;
              break;
            case 123: case 125: case 91: case 93: case 58: case 44:
              // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
              // the current position.
              value = charIndexBuggy ? source.charAt(Index) : source[Index];
              Index++;
              return value;
            case 34:
              // `&quot;` delimits a JSON string; advance to the next character and
              // begin parsing the string. String tokens are prefixed with the
              // sentinel `@` character to distinguish them from punctuators and
              // end-of-string tokens.
              for (value = &quot;@&quot;, Index++; Index &lt; length;) {
                charCode = source.charCodeAt(Index);
                if (charCode &lt; 32) {
                  // Unescaped ASCII control characters (those with a code unit
                  // less than the space character) are not permitted.
                  abort();
                } else if (charCode == 92) {
                  // A reverse solidus (`\`) marks the beginning of an escaped
                  // control character (including `&quot;`, `\`, and `/`) or Unicode
                  // escape sequence.
                  charCode = source.charCodeAt(++Index);
                  switch (charCode) {
                    case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                      // Revive escaped control characters.
                      value += Unescapes[charCode];
                      Index++;
                      break;
                    case 117:
                      // `\u` marks the beginning of a Unicode escape sequence.
                      // Advance to the first character and validate the
                      // four-digit code point.
                      begin = ++Index;
                      for (position = Index + 4; Index &lt; position; Index++) {
                        charCode = source.charCodeAt(Index);
                        // A valid sequence comprises four hexdigits (case-
                        // insensitive) that form a single hexadecimal value.
                        if (!(charCode &gt;= 48 &amp;&amp; charCode &lt;= 57 || charCode &gt;= 97 &amp;&amp; charCode &lt;= 102 || charCode &gt;= 65 &amp;&amp; charCode &lt;= 70)) {
                          // Invalid Unicode escape sequence.
                          abort();
                        }
                      }
                      // Revive the escaped character.
                      value += fromCharCode(&quot;0x&quot; + source.slice(begin, Index));
                      break;
                    default:
                      // Invalid escape sequence.
                      abort();
                  }
                } else {
                  if (charCode == 34) {
                    // An unescaped double-quote character marks the end of the
                    // string.
                    break;
                  }
                  charCode = source.charCodeAt(Index);
                  begin = Index;
                  // Optimize for the common case where a string is valid.
                  while (charCode &gt;= 32 &amp;&amp; charCode != 92 &amp;&amp; charCode != 34) {
                    charCode = source.charCodeAt(++Index);
                  }
                  // Append the string as-is.
                  value += source.slice(begin, Index);
                }
              }
              if (source.charCodeAt(Index) == 34) {
                // Advance to the next character and return the revived string.
                Index++;
                return value;
              }
              // Unterminated string.
              abort();
            default:
              // Parse numbers and literals.
              begin = Index;
              // Advance past the negative sign, if one is specified.
              if (charCode == 45) {
                isSigned = true;
                charCode = source.charCodeAt(++Index);
              }
              // Parse an integer or floating-point value.
              if (charCode &gt;= 48 &amp;&amp; charCode &lt;= 57) {
                // Leading zeroes are interpreted as octal literals.
                if (charCode == 48 &amp;&amp; ((charCode = source.charCodeAt(Index + 1)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57)) {
                  // Illegal octal literal.
                  abort();
                }
                isSigned = false;
                // Parse the integer component.
                for (; Index &lt; length &amp;&amp; ((charCode = source.charCodeAt(Index)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57); Index++);
                // Floats cannot contain a leading decimal point; however, this
                // case is already accounted for by the parser.
                if (source.charCodeAt(Index) == 46) {
                  position = ++Index;
                  // Parse the decimal component.
                  for (; position &lt; length &amp;&amp; ((charCode = source.charCodeAt(position)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57); position++);
                  if (position == Index) {
                    // Illegal trailing decimal.
                    abort();
                  }
                  Index = position;
                }
                // Parse exponents. The `e` denoting the exponent is
                // case-insensitive.
                charCode = source.charCodeAt(Index);
                if (charCode == 101 || charCode == 69) {
                  charCode = source.charCodeAt(++Index);
                  // Skip past the sign following the exponent, if one is
                  // specified.
                  if (charCode == 43 || charCode == 45) {
                    Index++;
                  }
                  // Parse the exponential component.
                  for (position = Index; position &lt; length &amp;&amp; ((charCode = source.charCodeAt(position)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57); position++);
                  if (position == Index) {
                    // Illegal empty exponent.
                    abort();
                  }
                  Index = position;
                }
                // Coerce the parsed value to a JavaScript number.
                return +source.slice(begin, Index);
              }
              // A negative sign may only precede numbers.
              if (isSigned) {
                abort();
              }
              // `true`, `false`, and `null` literals.
              if (source.slice(Index, Index + 4) == &quot;true&quot;) {
                Index += 4;
                return true;
              } else if (source.slice(Index, Index + 5) == &quot;false&quot;) {
                Index += 5;
                return false;
              } else if (source.slice(Index, Index + 4) == &quot;null&quot;) {
                Index += 4;
                return null;
              }
              // Unrecognized token.
              abort();
          }
        }
        // Return the sentinel `$` character if the parser has reached the end
        // of the source string.
        return &quot;$&quot;;
      };

      // Internal: Parses a JSON `value` token.
      var get = function (value) {
        var results, hasMembers;
        if (value == &quot;$&quot;) {
          // Unexpected end of input.
          abort();
        }
        if (typeof value == &quot;string&quot;) {
          if ((charIndexBuggy ? value.charAt(0) : value[0]) == &quot;@&quot;) {
            // Remove the sentinel `@` character.
            return value.slice(1);
          }
          // Parse object and array literals.
          if (value == &quot;[&quot;) {
            // Parses a JSON array, returning a new JavaScript array.
            results = [];
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing square bracket marks the end of the array literal.
              if (value == &quot;]&quot;) {
                break;
              }
              // If the array literal contains elements, the current token
              // should be a comma separating the previous element from the
              // next.
              if (hasMembers) {
                if (value == &quot;,&quot;) {
                  value = lex();
                  if (value == &quot;]&quot;) {
                    // Unexpected trailing `,` in array literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each array element.
                  abort();
                }
              }
              // Elisions and leading commas are not permitted.
              if (value == &quot;,&quot;) {
                abort();
              }
              results.push(get(value));
            }
            return results;
          } else if (value == &quot;{&quot;) {
            // Parses a JSON object, returning a new JavaScript object.
            results = {};
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing curly brace marks the end of the object literal.
              if (value == &quot;}&quot;) {
                break;
              }
              // If the object literal contains members, the current token
              // should be a comma separator.
              if (hasMembers) {
                if (value == &quot;,&quot;) {
                  value = lex();
                  if (value == &quot;}&quot;) {
                    // Unexpected trailing `,` in object literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each object member.
                  abort();
                }
              }
              // Leading commas are not permitted, object property names must be
              // double-quoted strings, and a `:` must separate each property
              // name and value.
              if (value == &quot;,&quot; || typeof value != &quot;string&quot; || (charIndexBuggy ? value.charAt(0) : value[0]) != &quot;@&quot; || lex() != &quot;:&quot;) {
                abort();
              }
              results[value.slice(1)] = get(lex());
            }
            return results;
          }
          // Unexpected token encountered.
          abort();
        }
        return value;
      };

      // Internal: Updates a traversed object member.
      var update = function(source, property, callback) {
        var element = walk(source, property, callback);
        if (element === undef) {
          delete source[property];
        } else {
          source[property] = element;
        }
      };

      // Internal: Recursively traverses a parsed JSON object, invoking the
      // `callback` function for each value. This is an implementation of the
      // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
      var walk = function (source, property, callback) {
        var value = source[property], length;
        if (typeof value == &quot;object&quot; &amp;&amp; value) {
          // `forEach` can&apos;t be used to traverse an array in Opera &lt;= 8.54
          // because its `Object#hasOwnProperty` implementation returns `false`
          // for array indices (e.g., `![1, 2, 3].hasOwnProperty(&quot;0&quot;)`).
          if (getClass.call(value) == arrayClass) {
            for (length = value.length; length--;) {
              update(value, length, callback);
            }
          } else {
            forEach(value, function (property) {
              update(value, property, callback);
            });
          }
        }
        return callback.call(source, property, value);
      };

      // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
      JSON3.parse = function (source, callback) {
        var result, value;
        Index = 0;
        Source = &quot;&quot; + source;
        result = get(lex());
        // If a JSON string contains multiple tokens, it is invalid.
        if (lex() != &quot;$&quot;) {
          abort();
        }
        // Reset the parser state.
        Index = Source = null;
        return callback &amp;&amp; getClass.call(callback) == functionClass ? walk((value = {}, value[&quot;&quot;] = result, value), &quot;&quot;, callback) : result;
      };
    }
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}(this));

},{}],50:[function(_dereq_,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i &lt; list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}]},{},[1])
(1)
});</stringProp>
          </JSR223PreProcessor>
          <hashTree/>
          <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname="JSR223 PreProcessor" enabled="false">
            <stringProp name="scriptLanguage">javascript</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="cacheKey">true</stringProp>
            <stringProp name="script">
//{scripttype=&quot;text/javascript&quot; src=&quot;https://adarshtest1.messageboxapp.com/socket.io/socket.io.js&quot;}



var ioOptions ={
	host:&quot;adarshtest1&quot;,
hostname:&quot;adarshtest1&quot;,
path:&quot;/socket.io&quot;,
port:&quot;4910&quot;,
query:{userid: &quot;704&quot;, email: &quot;rosepv123+1@gmail.com&quot;, namespace: &quot;gmm-adarshtest1&quot;},
//reconnection limit:1000,
secure:false
}
portjs = &quot;https://adarshtest1.messageboxapp.com/socket.io/socket.io.js&quot;;
socket = io.connect(portjs, ioOptions);
//refreshOpenRequests();
socket.on(&apos;connect&apos;, function(message) {
    ////
    console.info(&quot;__connected__&quot;);
    

    

});</stringProp>
          </JSR223PreProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="HTTP Request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">292:42/adarshtest1,4[&quot;userToUser&quot;,{&quot;userid&quot;:&quot;704&quot;,&quot;companyid&quot;:&quot;339&quot;,&quot;messageid&quot;:&quot;90807891530535030112&quot;,&quot;usergroupid&quot;:&quot;3&quot;,&quot;username&quot;:&quot;rosepv123+1@gmail.com&quot;,&quot;firstname&quot;:&quot;Dual &quot;,&quot;lastname&quot;:&quot;Rose&quot;,&quot;chatmediatype&quot;:&quot;Text&quot;,&quot;targetuserid&quot;:&quot;703&quot;,&quot;message&quot;:&quot;aGk=&quot;,&quot;chatid&quot;:&quot;0070300704&quot;,&quot;chattype&quot;:&quot;USER&quot;}]</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">socket.io/?t=1528987561812-3&amp;namespace=gmm-adarshtest1&amp;EIO=3&amp;transport=polling&amp;sid=${sid}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <JMeter.plugins.functional.samplers.websocket.WebSocketSampler guiclass="JMeter.plugins.functional.samplers.websocket.WebSocketSamplerGui" testclass="JMeter.plugins.functional.samplers.websocket.WebSocketSampler" testname="Connect to socket" enabled="true">
          <stringProp name="serverAddress">adarshtest1.messageboxapp.com</stringProp>
          <stringProp name="serverPort">4900</stringProp>
          <stringProp name="implementation">RFC6455 (v13)</stringProp>
          <stringProp name="protocol">wss</stringProp>
          <stringProp name="contextPath">socket.io</stringProp>
          <stringProp name="contentEncoding">UTF-8</stringProp>
          <stringProp name="requestPayload">292:42/adarshtest1,4[&quot;userToUser&quot;,{&quot;userid&quot;:&quot;704&quot;,&quot;companyid&quot;:&quot;339&quot;,&quot;messageid&quot;:&quot;90807891530535030112&quot;,&quot;usergroupid&quot;:&quot;3&quot;,&quot;username&quot;:&quot;rosepv123+1@gmail.com&quot;,&quot;firstname&quot;:&quot;Dual &quot;,&quot;lastname&quot;:&quot;Rose&quot;,&quot;chatmediatype&quot;:&quot;Text&quot;,&quot;targetuserid&quot;:&quot;703&quot;,&quot;message&quot;:&quot;aGk=&quot;,&quot;chatid&quot;:&quot;0070300704&quot;,&quot;chattype&quot;:&quot;USER&quot;}]</stringProp>
          <stringProp name="connectionTimeout">5000</stringProp>
          <stringProp name="responseTimeout">20000</stringProp>
          <boolProp name="ignoreSslErrors">true</boolProp>
          <boolProp name="streamingConnection">true</boolProp>
          <stringProp name="connectionId">${sid}</stringProp>
          <stringProp name="responsePattern"></stringProp>
          <stringProp name="closeConncectionPattern"></stringProp>
          <stringProp name="proxyAddress"></stringProp>
          <stringProp name="proxyPassword"></stringProp>
          <stringProp name="proxyPort"></stringProp>
          <stringProp name="proxyUsername"></stringProp>
          <stringProp name="messageBacklog">3</stringProp>
          <elementProp name="queryStringParameters" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="transport" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">polling</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">transport</stringProp>
              </elementProp>
              <elementProp name="t" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">1528987561812-3</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">t</stringProp>
              </elementProp>
              <elementProp name="sid" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${sid}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">sid</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
        </JMeter.plugins.functional.samplers.websocket.WebSocketSampler>
        <hashTree>
          <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname="JSR223 PreProcessor" enabled="false">
            <stringProp name="cacheKey">true</stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">
var ioOptions ={
	host:&quot;adarshtest1&quot;,
hostname:&quot;adarshtest1&quot;,
path:&quot;/socket.io&quot;,
port:&quot;4910&quot;,
query:{userid: &quot;704&quot;, email: &quot;rosepv123+1@gmail.com&quot;, namespace: &quot;gmm-adarshtest1&quot;},
reconnection limit:1000,
secure:false
}
portjs = &quot;https://adarshtest1.messageboxapp.com/socket.io/socket.io.js&quot;;
socket = io.connect(portjs, ioOptions);
//refreshOpenRequests();
socket.on(&apos;connect&apos;, function(message) {
    ////
    console.info(&quot;__connected__&quot;);
    swal({
        title: gmmValAlerts[&quot;GMM_VAL_NW_CONNECTED_MSG&quot;],
        text: &quot;&quot;,
        type:&quot;success&quot;,
        showConfirmButton: false,
        allowEscapeKey: false
    });
    setTimeout(function() {
        swal.close();
        if(localStorage.getItem(&apos;browserAlertStatus&apos;) != &apos;true&apos;){
            showBrowserAlerts();
        }
    }, 1000);

    function showBrowserAlerts(){
        if(!categories){
            setTimeout(function(){
                swal(gmmValAlerts[&apos;GMM_WARNING&apos;], &quot;There are no active Service Categories in your account. Please create at least one category in Settings to start creating requests.&quot;)
            }, 3000);
        }
        if(!isChrome){
            setTimeout(function(){
                swal(gmmValAlerts[&apos;GMM_WARNING&apos;], gmmValAlerts[&quot;GMM_GOOGLE_CHROME_WARNING&quot;]);
                localStorage.setItem(&apos;browserAlertStatus&apos;, &apos;true&apos;);
            }, 4000);
        }
        var screenWidth = screen.width;
        if(screenWidth&lt;=1440){
            setTimeout(function(){
                swal(gmmValAlerts[&apos;GMM_WARNING&apos;], gmmValAlerts[&quot;GMM_SMALL_SCREEN_WARNING&quot;]);
                localStorage.setItem(&apos;browserAlertStatus&apos;, &apos;true&apos;);
            }, 6000);
        }
    }

    $(&apos;#network-status&apos;).html(&apos;&lt;div class=&quot;label&quot;&gt;&apos;+gmmValAlerts[&apos;GMM_NW_STATUS_MSG&apos;]+&apos;&amp;nbsp;&amp;nbsp;&apos;+gmmValAlerts[&apos;GMM_VAL_NW_CONNECTED_MSG&apos;]+&apos;&lt;/div&gt;&apos;).fadeOut(&apos;slow&apos;).fadeIn(&apos;slow&apos;);
    $(&apos;.nano1&apos;).removeClass(&apos;ajax-loader-kingsadmin&apos;);
    $(&apos;#load_contacts&apos;).removeClass(&apos;ajax-loader-kingsadmin&apos;);

    try
    {
        //        refreshOpenRequests();
        refreshContacts(0);
        var openedWindow = JSON.parse(localStorage.getItem(&apos;openedMsg&apos;));
        $.each(openedWindow, function(index, obj) {

            var explode = obj.split(&quot;#&quot;);

            if (explode[0] == &quot;CUSTOMER&quot;)
            {
                if( (explode[1])*1 ) {
                    getOldChat(removeChr(index), 1, explode[1]);
                    //console.log(&quot;Appending opened reference to widget table row.&quot;);
                    addOpenedRefToOpenRow(removeChr(index), explode[1]);
                }else{
                    if(!$(index).is(&apos;:visible&apos;) &amp;&amp; ($(&apos;.initialRequestWindow&apos;).length == 0))
                        getOldChat(removeChr(index), 1, explode[1]);
                }
            }
            else
            {
                var newIndex = appendChr(parseInt(removeChr(index)) -1);

                var internalChatId = removeChr(index);




                var reqData = new Object();
                reqData.chatId = internalChatId;
                ajax_loader_disable();
                $.ajax({
                    type: &apos;POST&apos;,
                    dataType: &quot;json&quot;,
                    url: baseUrl + &quot;/home/getrequestdetailsbyinternalchatid&quot;,
                    data: reqData,
                    success: function(data) {
                        if(data[0]){
                            setTimeout(function(){
                                $(&quot;#serviceregisterUpdateCHT&quot;+data[0][&apos;SR_ChatId&apos;]+&quot; .chtwitbut&quot;).click();
                            }, 2000);
                        }
                    }
                });
            }

        });
        if(companySelectedPackageId == 1) {
            if($.isEmptyObject(openedWindow)) {
                if($(&apos;.customerChat&apos;).length == 0) {
                    send_internalV3();
                }
            } else if (typeof(openedWindow.no) != &quot;undefined&quot;) { // Login condition
                if($(&apos;.customerChat&apos;).length == 0) {
                    send_internalV3();
                }
            }
        }
        else {
            if($.isEmptyObject(openedWindow)) {
                if($(&apos;.initialRequestWindow&apos;).length == 0) {
                    send_internalV3();
                }
            } else if (typeof(openedWindow.no) != &quot;undefined&quot;) { // Login condition
                if($(&apos;.initialRequestWindow&apos;).length == 0) {
                    send_internalV3();
                }
            }
        }

    }
    catch (e) {
        //        console.log(e);
    }

});
socket.on(&apos;disconnect&apos;, function(err) {
    errorconnection();
    socket.io.reconnect();
});
socket.on(&apos;reconnect&apos;, function(message) {

});
socket.on(&apos;reconnecting&apos;, function(message) {

});
socket.on(&apos;connecting&apos;, function(message) {

    //$(&apos;#msg&apos;).html(&quot;&lt;p class=&apos;ui-state-error ui-corner-all socket-connecting&apos; &gt;Connecting...&lt;/p&gt;&quot;);
    // $(&apos;#msg&apos;).html(&quot;&lt;div class=&apos;label label-warning&apos; &gt;&quot;+gmmValAlerts[&apos;GMM_VAL_CONNECTING_MSG&apos;]+&quot;...&lt;/div&gt;&quot;).fadeOut(&apos;slow&apos;).fadeIn(&apos;slow&apos;);
    //$(&apos;#network-status&apos;).removeClass(&apos;btn-success&apos;);
    //$(&apos;#network-status&apos;).addClass(&apos;btn-warning&apos;);
    $(&apos;#network-status&apos;).html(gmmValAlerts[&apos;GMM_VAL_CONNECTING_MSG&apos;]+&apos;...&apos;);

});


// sample emit function
socket.emit(&apos;clientLoginInternal&apos;,
        {&quot;userid&quot;: 704,
           &quot;companyid&quot;: 339,
           &quot;username&quot;: rosepv123+1@gmail.com,
           &quot;password&quot;: &quot;abcd1234&quot;,
           &quot;usertype&quot;: Internal,
           &quot;usergroupid&quot;: 3, 
           &quot;usergroup&quot;: Agent,
           &quot;firstname&quot;: Dual ,
           &quot;lastname&quot;: Rose,
           &quot;propertycode&quot;: &quot;&quot;,
           &quot;chatcategoryid&quot;: &apos;&apos;,
           &quot;chatcategory&quot;: &apos;&apos;, 
           &quot;uniqueid&quot;: s20m9egdv699eii99bveltut35,
           &quot;targetuniqueid&quot;: &quot;&quot;});</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </JSR223PreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Host</stringProp>
                <stringProp name="Header.value">adarshtest1.getmymessage.co</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Origin</stringProp>
                <stringProp name="Header.value">https://adarshtest1.getmymessage.co</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="SocketPost" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="t" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">t</stringProp>
                <stringProp name="Argument.value">1528987561812-3</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="namespace" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">namespace</stringProp>
                <stringProp name="Argument.value">gmm-adarshtest1</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="EIO" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">EIO</stringProp>
                <stringProp name="Argument.value">3</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="transport" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">transport</stringProp>
                <stringProp name="Argument.value">polling</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="userid" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">userid</stringProp>
                <stringProp name="Argument.value">704</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="email" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">email</stringProp>
                <stringProp name="Argument.value">rosepv123+1@gmail.com</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="sid" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">sid</stringProp>
                <stringProp name="Argument.value">${sid}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">adarshtest1.messageboxapp.com</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">socket.io/</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="Origin" elementType="Header">
                <stringProp name="Header.name">Origin</stringProp>
                <stringProp name="Header.value">https://adarshtest1.getmymessage.co</stringProp>
              </elementProp>
              <elementProp name="Content-type" elementType="Header">
                <stringProp name="Header.name">Content-type</stringProp>
                <stringProp name="Header.value">text/plain;charset=UTF-8</stringProp>
              </elementProp>
              <elementProp name="Accept" elementType="Header">
                <stringProp name="Header.name">Accept</stringProp>
                <stringProp name="Header.value">*/*</stringProp>
              </elementProp>
              <elementProp name="Referer" elementType="Header">
                <stringProp name="Header.name">Referer</stringProp>
                <stringProp name="Header.value">https://adarshtest1.getmymessage.co/home</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Host</stringProp>
                <stringProp name="Header.value">adarshtest1.messageboxapp.com</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
        </hashTree>
        <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>false</message>
              <threadName>true</threadName>
              <dataType>false</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>false</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <hostname>true</hostname>
              <threadCounts>true</threadCounts>
              <sampleCount>true</sampleCount>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
